[{"id":"en/downloads.html","title":"Lite XL - Downloads","category":[],"content":"Downloads\nBinary packages\nBinary packages are available on the GitHub releases page.\nInstall via package management\nAlternatively, you can install lite-xl from your distribution's package manager.\nThese packages are maintained by the community and may be outdated.\nWindows (Chocolatey / Scoop)\nMac OS (MacPorts)\nArch Linux (AUR)\nNixOS (nixpkgs)\nFedora\nchoco install lite-xl\\t# chocolatey\nscoop bucket add extras && scoop install lite-xl\\t# scoop\nsudo port install lite-xl\\t# macports\nyay -S lite-xl\\t# or your favorite AUR helper\nnix-env -i lite-xl\\t# nixos\nsudo dnf install lite-xl\\t# fedora\nSource Code\nSource code is available on GitHub, by downloading zip or tar archives,\nor directly via git:\ngit clone https://github.com/lite-xl/lite-xl.git"},{"id":"en/documentation/keymap-macos.html","title":"Lite XL - MacOS Keymap","category":["documentation"],"content":"MacOS Keymap\nKeymaps on different operating systems have the same functionality, just bound slightly differently\nin order to conform to normal expectations for that operating system.\nCurrently, there are only two operating system layouts. MacOS, and everything else.\nKeymap\nKey Combination\tActions\ncmd+/\tdoc:toggle-line-comments\ncmd+1\troot:switch-to-tab-1\ncmd+2\troot:switch-to-tab-2\ncmd+3\troot:switch-to-tab-3\ncmd+4\troot:switch-to-tab-4\ncmd+5\troot:switch-to-tab-5\ncmd+6\troot:switch-to-tab-6\ncmd+7\troot:switch-to-tab-7\ncmd+8\troot:switch-to-tab-8\ncmd+9\troot:switch-to-tab-9\ncmd+[\tdoc:move-to-previous-block-start\ncmd+]\tdoc:move-to-next-block-end\ncmd+a\tdoc:select-all\ncmd+backspace\tdoc:delete-to-start-of-indentation\ncmd+c\tdoc:copy\ncmd+ctrl+i\troot:switch-to-up\ncmd+ctrl+j\troot:switch-to-left\ncmd+ctrl+k\troot:switch-to-down\ncmd+ctrl+l\troot:switch-to-right\ncmd+ctrl+return\tcore:toggle-fullscreen\ncmd+ctrl+shift+i\troot:split-up\ncmd+ctrl+shift+j\troot:split-left\ncmd+ctrl+shift+k\troot:split-down\ncmd+ctrl+shift+l\troot:split-right\ncmd+d\tdoc:select-word\ncmd+d\tfind-replace:select-add-next\ncmd+delete\tdoc:delete-to-end-of-line\ncmd+down\tdoc:move-to-end-of-doc\ncmd+f3\tfind-replace:select-next\ncmd+f\tfind-replace:find\ncmd+g\tdoc:go-to-line\ncmd+j\tdoc:join-lines\ncmd+l\tdoc:select-lines\ncmd+left\tdoc:move-to-start-of-indentation\ncmd+n\tcore:new-doc\ncmd+o\tcore:open-file\ncmd+option+down\tdoc:create-cursor-next-line\ncmd+option+up\tdoc:create-cursor-previous-line\ncmd+p\tcore:find-file\ncmd+pagedown\troot:move-tab-right\ncmd+pageup\troot:move-tab-left\ncmd+r\tfind-replace:replace\ncmd+return\tdoc:newline-below\ncmd+right\tdoc:move-to-end-of-line\ncmd+s\tdoc:save\ncmd+shift+[\tdoc:select-to-previous-block-start\ncmd+shift+]\tdoc:select-to-next-block-end\ncmd+shift+backspace\tdoc:delete-to-previous-word-start\ncmd+shift+c\tcore:change-project-folder\ncmd+shift+d\tdoc:duplicate-lines\ncmd+shift+delete\tdoc:delete-to-next-word-end\ncmd+shift+down\tdoc:select-to-end-of-doc\ncmd+shift+k\tdoc:delete-lines\ncmd+shift+l\tdoc:select-word\ncmd+shift+l\tfind-replace:select-add-all\ncmd+shift+left\tdoc:select-to-start-of-indentation\ncmd+shift+o\tcore:open-project-folder\ncmd+shift+p\tcore:find-command\ncmd+shift+return\tdoc:newline-above\ncmd+shift+right\tdoc:select-to-end-of-line\ncmd+shift+s\tdoc:save-as\ncmd+shift+up\tdoc:select-to-start-of-doc\ncmd+up\tdoc:move-to-start-of-doc\ncmd+v\tdoc:paste\ncmd+w\troot:close-or-quit\ncmd+x\tdoc:cut\ncmd+y\tdoc:redo\ncmd+z\tdoc:undo\nctrl+1lclick\tdoc:split-cursor\nctrl+insert\tdoc:copy\nctrl+shift+tab\troot:switch-to-previous-tab\nctrl+tab\troot:switch-to-next-tab\nf3\tfind-replace:repeat-find\noption+backspace\tdoc:delete-to-previous-word-start\noption+delete\tdoc:delete-to-next-word-end\noption+down\tdoc:move-lines-down\noption+left\tdoc:move-to-previous-word-start\noption+right\tdoc:move-to-next-word-end\noption+shift+left\tdoc:select-to-previous-word-start\noption+shift+right\tdoc:select-to-next-word-end\noption+up\tdoc:move-lines-up\nshift+f3\tfind-replace:previous-find"},{"id":"en/documentation/usage.html","title":"Lite XL - Usage","category":["documentation"],"content":"Usage\nLite XL is a lightweight text editor written mostly in Lua — it aims to provide\nsomething practical, pretty, small and fast, implemented as simply as\npossible; easy to modify and extend, or to use without doing either.\nLite XL is based on the Lite editor and provide some enhancements\nwhile remaining generally compatible with it.\nGetting Started\nLite XL works using a project directory — this is the directory where your\nproject's code and other data resides.\nTo open a specific project directory the directory name can be passed\nas a command-line argument (. can be passed to use the current directory)\nor the directory can be dragged onto either the executable or a running instance.\nOnce started the project directory can be changed using the command\ncore:change-project-folder. The command will close all the documents\ncurrently opened and switch to the new project directory.\nIf you want to open a project directory in a new window the command\ncore:open-project-folder will open a new editor window with the selected\nproject directory.\nThe main way of opening files in Lite XL is through the core:find-file command\n— this provides a fuzzy finder over all of the project's files and can be\nopened using the ctrl+p shortcut by default.\nCommands can be run using keyboard shortcuts, or by using the core:find-command\ncommand bound to ctrl+shift+p by default. For example, pressing\nthe above combination and typing newdoc then pressing return\nwould open a new document. The current keyboard shortcut for a command\ncan be seen to the right of the command name on the command finder, thus to find\nthe shortcut for a command ctrl+shift+p can be pressed\nand the command name typed.\nUser Data Directories\nLite XL uses standard systems user directories; the user data can be found in\n$HOME/.config/lite-xl on Linux and macOS.\nOn Windows, the variable $USERPROFILE will be used instead of\n$HOME.\nUser Module\nLite XL can be configured through use of the user module. The user module can be\nused for changing options in the config module, adding additional key bindings,\nloading custom color themes, modifying the style or changing any other part of\nthe editor to your personal preference.\nThe user module is loaded when the application starts,\nafter the plugins have been loaded.\nThe user module can be modified by running the core:open-user-module command\nor otherwise directly opening the $HOME/.config/lite-xl/init.lua file.\nOn Windows, the variable $USERPROFILE will be used instead of\n$HOME.\ntl;dr:\nWindows: C:\\Users\\(username)\\.config\\lite-xl\\init.lua\nMacOS: /Users/(usernmame)/.config/lite-xl/init.lua\nLinux: /home/(username)/.config/lite-xl/init.lua\nThese aren't the exact location, but it gives you an idea where to find.\nPlease note that Lite XL differs from the standard Lite editor for the location\nof the user's module.\nProject Module\nThe project module is an optional module which is loaded from the current\nproject's directory when Lite XL is started. Project modules can be useful for\nthings like adding custom commands for project-specific build systems, or\nloading project-specific plugins.\nThe project module is loaded when the application starts,\nafter both the plugins and user module have been loaded.\nThe project module can be edited by running the core:open-project-module\ncommand — if the module does not exist for the current project when the\ncommand is run it will be created.\nAdd directories to a project\nIn addition to the project directories it is possible to add other directories\nusing the command core:add-directory.\nOnce added a directory it will be shown in the tree-view on the left side and\nthe additional files will be reachable using the ctrl+p command (find file).\nThe additonal files will be also visible when searching across the project.\nThe additional directories can be removed using the command core:remove-directory.\nWhen you will open again Lite XL on the same project folder the application will\nremember your workspace including the additonal project directories.\nSince version 1.15 Lite XL does not need a workspace plugin as it is now\nbundled with the editor.\nCreate new empty directory\nUsing the command files:create-directory or control-click in a directory in the\ntree-view to create a new empty subdirectory.\nCommands\nCommands are used both through the command finder (ctrl+shift+p) and\nby Lite XL's keyboard shortcut system. Commands consist of 3 components:\nName — The command name in the form of namespace:action-name, for\nexample: doc:select-all\nPredicate — A function that returns true if the command can be ran, for\nexample, for any document commands the predicate checks whether the active\nview is a document\nFunction — The function which performs the command itself\nCommands can be added using the command.add function provided by the\ncore.command module:\nlocal core = require \"core\"\nlocal command = require \"core.command\"\ncommand.add(\"core.docview\", {\n\\t[\"doc:save\"] = function()\n\\tcore.active_view.doc:save()\n\\tcore.log(\"Saved '%s'\", core.active_view.doc.filename)\n\\tend\n})\nCommands can be performed programatically (eg. from another command or by your\nuser module) by calling the command.perform function after requiring the\ncommand module:\nlocal command = require \"core.command\"\ncommand.perform \"core:quit\"\nKeymap\nAll keyboard shortcuts are handled by the core.keymap module.\nA key binding maps a \"stroke\" (eg. ctrl+q) to one or more commands\n(eg. core:quit). When the shortcut is pressed Lite XL will iterate each command\nassigned to that key and run the predicate function for that command — if the\npredicate passes it stops iterating and runs the command.\nAn example of where this used is the default binding of the tab key:\n\\t[\"tab\"] = { \"command:complete\", \"doc:indent\" },\nWhen tab is pressed the command:complete command is attempted which will only\nsucceed if the command-input at the bottom of the window is active. Otherwise\nthe doc:indent command is attempted which will only succeed if we have a\ndocument as our active view.\nA new mapping can be added by your user module as follows:\nlocal keymap = require \"core.keymap\"\nkeymap.add { [\"ctrl+q\"] = \"core:quit\" }\nA list of default mappings can be viewed here.\nGlobal variables\nThere are a few global variables set by the editor.\nThese variables are available everywhere and shouldn't be overwritten.\nARGS: command-line arguments. argv[1] is the program name, argv[2] is the 1st parameter, ...\nPLATFORM: Output from SDL_GetPlatform(). Can be Windows, Mac OS X, Linux, iOS and Android.\nSCALE: Font scale. Usually 1, but can be higher on HiDPI systems.\nEXEFILE: An absolute path to the executable.\nEXEDIR: The executable directory. DO NOT WRITE TO THIS DIRECTORY.\nVERSION: lite-xl version.\nMOD_VERSION: mod-version used in plugins. This is usually incremented when there are API changes.\nPATHSEP: Path seperator. \\ (Windows) or / (Other OSes)\nDATADIR: The data directory, where the Lua part of lite-xl resides. DO NOT WRITE TO THIS DIRECTORY.\nUSERDIR: User configuration directory.\nUSERDIR should be used instead of DATADIR when configuring the editor\nbecause DATADIR might not be writable.\n(for example, if the editor is installed in /usr, DATADIR will be /usr/share/lite-xl!)\nUSERDIR on the other hand should always be writable for the user, and allows multiple users to customize\ntheir own editor.\nPlugins\nPlugins in Lite XL are normal lua modules and are treated as such — no\ncomplicated plugin manager is provided, and, once a plugin is loaded, it is never\nexpected be to have to unload itself.\nTo install a plugin simply drop it in the plugins directory in the user\nmodule directory.\nWhen Lite XL starts it will first load the plugins included in the data directory\nand will then loads the plugins located in the user module directory.\nTo uninstall a plugin the plugin file can be deleted — any plugin\n(including those included with the default installation)\ncan be deleted to remove its functionality.\nIf you want to load a plugin only under a certain circumstance (for example,\nonly on a given project) the plugin can be placed somewhere other than the\nplugins directory so that it is not automatically loaded. The plugin can\nthen be loaded manually as needed by using the require function.\nPlugins can be downloaded from the plugins repository.\nRestarting the editor\nIf you modify the user configuration file or some of the Lua implementation files\nyou may restart the editor using the command core:restart.\nThe entire application will be restarting by keeping the window that is already in use.\nColor Themes\nColors themes in Lite XL are lua modules which overwrite the color fields of\nLite XL's core.style module.\nPre-defined color methods are located in the colors folder in the data directory.\nAdditional color themes can be installed in the user's directory in a folder named\ncolors.\nA color theme can be set by requiring it in your user module:\ncore.reload_module \"colors.winter\"\nIn the Lite editor the function require is used instead of core.reload_module.\nIn Lite XL core.reload_module should be used to ensure that the color module\nis actually reloaded when saving the user's configuration file.\nColor themes can be downloaded from the color themes repository.\nThey are included with Lite XL release packages."},{"id":"en/documentation/build.html","title":"Lite XL - Build","category":["documentation"],"content":"Build\nOnce you have downloaded the source code, you can build Lite XL yourself using Meson.\nIn addition, the build-packages.sh script can be used to compile Lite XL and\ncreate an OS-specific package for Linux, Windows or macOS.\nThe following libraries are required:\nfreetype2\nSDL2\nThe following libraries are optional:\nlibagg\nLua 5.2\nIf they are not found, they will be downloaded and compiled by Meson.\nOtherwise, if they are present, they will be used to compile Lite XL.\nBuild Script\nIf you compile Lite XL yourself,\nit is recommended to use the script build-packages.sh:\nbash build-packages.sh -h\nThe script will run Meson and create a tar compressed archive with the application or,\nfor Windows, a zip file. Lite XL can be easily installed\nby unpacking the archive in any directory of your choice.\nOn Windows two packages will be created, one called \"portable\" using the \"data\"\nfolder next to the executable and the other one using a unix-like file layout.\nBoth packages works correctly. The one with unix-like file layout is meant\nfor people using a unix-like shell and the command line.\nPlease note that there aren't any hard-coded directories in the executable,\nso that the package can be extracted and used in any directory.\nPortable\nWhen performing the meson setup command you may enable the -Dportable=true\noption to specify whether files should be installed as in a portable application.\nIf portable is enabled, Lite XL is built to use a data directory placed next\nto the executable.\nOtherwise, Lite XL will use unix-like directory locations.\nIn this case, the data directory will be $prefix/share/lite-xl\nand the executable will be located in $prefix/bin.\n$prefix is determined when the application starts as a directory such that\n$prefix/bin corresponds to the location of the executable.\nThe user directory does not depend on the portable option and will always be\n$HOME/.config/lite-xl.\n$HOME is determined from the corresponding environment variable.\nAs a special case on Windows the variable $USERPROFILE will be used instead.\nLinux\nOn Debian-based systems the required libraries and Meson can be installed\nusing the following commands:\n# To install the required libraries:\nsudo apt install libfreetype6-dev libsdl2-dev\n# To install Meson:\nsudo apt install meson\n# or pip3 install --user meson\nTo build Lite XL with Meson the commands below can be used:\nmeson setup --buildtype=release --prefix <prefix> build\nmeson compile -C build\nDESTDIR=\"$(pwd)/lite-xl\" meson install --skip-subprojects -C build\nwhere <prefix> depends on the OS you are using:\n- on Linux is /usr\n- on macOS application bundle can be \"/Lite XL.app\"\nIf you are using a version of Meson below 0.54\nyou need to use diffent commands to compile and install:\nmeson setup --buildtype=release build\nninja -C build\nninja -C build install\nmacOS\nmacOS is fully supported and a notarized app disk image is provided in the\nrelease page. \nIn addition the application can be compiled using the generic instructions given above.\nWindows MSYS2\nThe build environment chosen for Lite XL on Windows is MSYS2.\nFollow the install instructions in the link.\nOpen MinGW 64-bit or MinGW 32-bit shell from the start menu.\nUpdate the MSYS2 installation with pacman -Syu\nRestart the shell\nInstall the dependencies:\npacman -S \\\n\\t${MINGW_PACKAGE_PREFIX}-freetype \\\n\\t${MINGW_PACKAGE_PREFIX}-gcc \\\n\\t${MINGW_PACKAGE_PREFIX}-ninja \\\n\\t${MINGW_PACKAGE_PREFIX}-pcre2 \\\n\\t${MINGW_PACKAGE_PREFIX}-pkg-config \\\n\\t${MINGW_PACKAGE_PREFIX}-python-pip \\\n\\t${MINGW_PACKAGE_PREFIX}-SDL2\npip3 install meson\n${MINGW_PACKAGE_PREFIX} expands either to mingw-w64-i686 or mingw-w64-x86_64\ndepending if the current shell is 32 or 64 bit."},{"id":"en/documentation/keymap.html","title":"Lite XL - Default Keymap","category":["documentation"],"content":"Default Keymap\nKeymaps on different operating systems have the same functionality, just bound slightly differently\nin order to conform to normal expectations for that operating system.\nCurrently, there are only two operating system layouts. MacOS, and everything else.\nKeymap\nKey Combination\tActions\nalt+1\troot:switch-to-tab-1\nalt+2\troot:switch-to-tab-2\nalt+3\troot:switch-to-tab-3\nalt+4\troot:switch-to-tab-4\nalt+5\troot:switch-to-tab-5\nalt+6\troot:switch-to-tab-6\nalt+7\troot:switch-to-tab-7\nalt+8\troot:switch-to-tab-8\nalt+9\troot:switch-to-tab-9\nalt+i\troot:switch-to-up\nalt+j\troot:switch-to-left\nalt+k\troot:switch-to-down\nalt+l\troot:switch-to-right\nalt+return\tcore:toggle-fullscreen\nalt+shift+i\troot:split-up\nalt+shift+j\troot:split-left\nalt+shift+k\troot:split-down\nalt+shift+l\troot:split-right\nctrl+/\tdoc:toggle-line-comments\nctrl+1lclick\tdoc:split-cursor\nctrl+[\tdoc:move-to-previous-block-start\nctrl+]\tdoc:move-to-next-block-end\nctrl+a\tdoc:select-all\nctrl+backspace\tdoc:delete-to-previous-word-start\nctrl+c\tdoc:copy\nctrl+d\tdoc:select-word\nctrl+d\tfind-replace:select-add-next\nctrl+delete\tdoc:delete-to-next-word-end\nctrl+down\tdoc:move-lines-down\nctrl+end\tdoc:move-to-end-of-doc\nctrl+f3\tfind-replace:select-next\nctrl+f\tfind-replace:find\nctrl+g\tdoc:go-to-line\nctrl+home\tdoc:move-to-start-of-doc\nctrl+i\tfind-replace:toggle-sensitivity\nctrl+insert\tdoc:copy\nctrl+j\tdoc:join-lines\nctrl+l\tdoc:select-lines\nctrl+left\tdoc:move-to-previous-word-start\nctrl+n\tcore:new-doc\nctrl+o\tcore:open-file\nctrl+p\tcore:find-file\nctrl+pagedown\troot:move-tab-right\nctrl+pageup\troot:move-tab-left\nctrl+r\tfind-replace:replace\nctrl+return\tdoc:newline-below\nctrl+right\tdoc:move-to-next-word-end\nctrl+s\tdoc:save\nctrl+shift+[\tdoc:select-to-previous-block-start\nctrl+shift+]\tdoc:select-to-next-block-end\nctrl+shift+backspace\tdoc:delete-to-previous-word-start\nctrl+shift+c\tcore:change-project-folder\nctrl+shift+d\tdoc:duplicate-lines\nctrl+shift+delete\tdoc:delete-to-next-word-end\nctrl+shift+down\tdoc:create-cursor-next-line\nctrl+shift+end\tdoc:select-to-end-of-doc\nctrl+shift+f3\tfind-replace:select-previous\nctrl+shift+home\tdoc:select-to-start-of-doc\nctrl+shift+i\tfind-replace:toggle-regex\nctrl+shift+k\tdoc:delete-lines\nctrl+shift+l\tdoc:select-word\nctrl+shift+l\tfind-replace:select-add-all\nctrl+shift+left\tdoc:select-to-previous-word-start\nctrl+shift+o\tcore:open-project-folder\nctrl+shift+p\tcore:find-command\nctrl+shift+return\tdoc:newline-above\nctrl+shift+right\tdoc:select-to-next-word-end\nctrl+shift+s\tdoc:save-as\nctrl+shift+tab\troot:switch-to-previous-tab\nctrl+shift+up\tdoc:create-cursor-previous-line\nctrl+tab\troot:switch-to-next-tab\nctrl+up\tdoc:move-lines-up\nctrl+v\tdoc:paste\nctrl+w\troot:close\nctrl+x\tdoc:cut\nctrl+y\tdoc:redo\nctrl+z\tdoc:undo\nf11\tcore:toggle-fullscreen\nf3\tfind-replace:repeat-find\nshift+f3\tfind-replace:previous-find"},{"id":"en/documentation/index.html","title":"Lite XL - Documentation","category":["documentation"],"content":"Documentation\nThese pages contain documentation to build, run and use Lite XL.\nBuild\nKeymap (MacOS)\nKeymap\nUsage"},{"id":"en/tutorials/api-overview.html","title":"Lite XL - API Overview","category":["tutorials"],"content":"API Overview\nThis is a work in progress.\nHere we provide some resources and explanation to some API and aspects of Lite XL.\nFor API docs, it's available in the repo\nThus, we'll not explain everything, only the more important and frequently used features.\nBuilt-in APIs:\nProcess API\nSystem API\nRegex API"},{"id":"en/tutorials/system-fonts.html","title":"Lite XL - Using system fonts","category":["tutorials"],"content":"Using system fonts\nlite-xl does not provide a convenient way to use fonts on the system.\nThere is literally _different APIs for the each platforms we support (Windows, Linux and Mac).\nThis is where fontconfig comes to our rescue. fontconfig is\ninstallable on a lot of OSes.\nlite-xl has a fontconfig plugin that we can use to find system fonts.\nInstalling fontconfig\nWindows\nmingw-w64-fontconfig provides a build that can be used directly on Windows.\nDownload the file, extract it to somewhere and (optionally) add it to the PATH.\nLinux\nCheck your distro-specific instructions.\n# ubuntu / debian\napt install fontconfig\n# arch\npacman -Su fontconfig\n# fedora\ndnf install fontconfig\n...\nMacOS\nbrew install fontconfig\nSetting up\nInstall the plugin\nPut this in your user module:\nlocal fontconfig = require \"plugins.fontconfig\"\nfontconfig.use {\n\\tfont = { name = \"sans\", size = 13 * SCALE },\n\\tcode_font = { name = \"monospace\", size = 13 * SCALE }\n}\n\"sans\" and \"monospace\" can be any fontconfig syntax. (check \"Font Names\")\nNote that the font might not load immediately (because we need to wait for fc-match to return.\nIf you want that, replace fontconfig.use with fontconfig.use_blocking. Doing this will force\nlite-xl to wait for fc-match, which can be much slower."},{"id":"en/tutorials/overview/system.html","title":"Lite XL - System API","category":["tutorials","overview"],"content":"System API\nThis is where Lite XL's lua code interact with its underlying C engine.\nSome of the functions here will be omitted because they're not useful for\nplugins.\nClipboard\nsystem.set_clipboard(text) sets the clipboard content.\nsystem.get_clipboard() retrieves the content of the clipboard.\nFile / Directory manipulation\nsystem.list_dir(dir) returns a list of filenames in a directory.\nsystem.rmdir(dir) removes a directory. Use this instead of os.remove().\nThe directory must be empty.\nsystem.chdir(dir) changes the current working directory (like cd).\nsystem.mkdir(dir) creates a new directory.\nIt does not recursively create directories.\nsystem.absolute_path(path) resolves the path components (.. and .) to an absolute path.\nsystem.get_file_info(path) returns info about a path.\nmodified: last modification time of the file in seconds since UNIX epoch.\nsize: file size in bytes.\ntype: Path type (\"file\" or \"dir\").\nTiming\nsystem.get_time() returns time in seconds (as floating point number) since Lite XL started.\nUse this instead of os.time() for higher precision timers.\nsystem.sleep(time) sleeps for time in milliseconds.\nDo not use this. Write asynchronous code.\nWindow manipulation\nsystem.set_window_opacity(o) sets the window opacity from 0 to 1.\nsystem.set_window_title(title) sets the window title.\nsystem.set_window_mode(mode) sets window mode:\n\"normal\": also known as \"restored\" on Windows.\n\"maximized\": Maximize the window.\n\"minimized\": Minimize the window.\n\"fullscreen\": Fullscreen\nsystem.set_window_bordered(bordered) enables or disable window border (decoration).\nsystem.set_window_hit_test(height, control_width, resize_border) sets window hit test (used for\nconfig.borderless to make custom drawn border interactable).\nIf no argument is supplied, reset the hit test values.\nheight: height of the title bar.\ncontrols_width: Not too sure about this, but it should be the size of the title bar controls\n(Maximize, Minimize and Normal buttons on the right).\nIt seems to be fixed at the right side of the title bar.\nresize_border: Number of pixels reserved for resizing the window.\n(setting this to a large value means that you can resize the window way easier)\nsystem.get_window_size() gets the window size.\nsystem.set_window_size(w, h, x, y) sets the window size (and also position).\nsystem.window_has_focus() checks whether the window is in focus.\nsystem.show_fatal_error(title, msg) shows an system error message box.\nUse nagview whenever possible.\nMisc\nsystem.exec(command) runs a command. Use the Process API instead of this.\nsystem.fuzzy_match(haystack, needle, file) generates a score depends on how close the needle\nmatches the haystack.\nfile: match backwards (more accurate for filename matching)."},{"id":"en/tutorials/overview/regex.html","title":"Lite XL - Regex API","category":["tutorials","overview"],"content":"Regex API\nThis API provides PCRE regular expressions for those who needs more power in matching text.\nThis API written in C and Lua.\nCreating a regex\nUse regex.compile(pattern, options) to compile a regex.\npattern: The regex pattern\noptions: regex modifiers as a string, eg \"im\"\n\"i\": Case-insensitive search\n\"m\": Multiline search\n\"s\": Match all characters with dot (.), including newlines.\nMatching\nLow level functions\nregex:cmatch(str, offset, options) low-level matching function\nstr: The string to match against\noffset: Where to start matching\noptions: A bit field of options\nregex.ANCHORED: Only match from the start of the string\nregex.ENDANCHORED: Only match from the end of the string\nregex.NOTBOL: String is not beginning of line\nregex.NOTEOL: String is not the end of line\nregex.NOTEMPTY: Do not match an empty string\nregex.NOTEMPTY_ATSTART: Do not match empty string at the start\nNote: regex:cmatch() returns wrong indexes (currently at version 2.0.2).\n\\tThe end index returned by regex:cmatch() is always off by 1 (-1 to get the actual end index).\nHigh level functions\nAll the functions below can be in 2 forms:\n- regex:fn(...) where regex is the compiled regex instance\n- regex.fn(pattern, ...) where pattern is a pattern string to be compiled and used directly.\nWe will only document the first form.\nregex:match(str, offset, options) high level matching function. This function accepts\nthe same arguments as regex:cmatch()\nregex:gsub(str, replacement) replaces matches in str with replacement.\nCapture groups are identified with \\\\0 to \\\\9, this might change in the future."},{"id":"en/tutorials/overview/process.html","title":"Lite XL - Process API","category":["tutorials","overview"],"content":"Process API\nLite XL provides a process API to launch external applications. This API is meant to replace\nlua's io.popen and lite's pipe-to-a-file approach.\nAdvantages of this API includes:\nProper argument escaping (arguments are supplied via a table)\nNonblocking IO\nAble to detach processes from Lite XL (in progress)\nDoes not create temporary files\nMostly cross-platform (does not require special code for each shell)\nUsing the Process API\nError handling\nprocess.start() may throw errors if it cannot run the program.\nprocess.read* and process.write functions may throw errors if\nthe process ended\nthe process closed the stream\nyou closed the stream\nthere might be other errors to look forward to too\nStarting a process\nTo start a process, use process.start(args, options).\nHere are some of the more useful arguments.\nargs: The executable and any arguments, eg: { \"sh\", \"-c\", \"echo hello world\" }\noptions: Options for process.start()\nenv: A key-value table containing the env. Note that if this is provided,\n\\tenvironment variables will not be inherited.\nstdin: Specify where to redirect stdin\nstdout: Specify where to redirect stdout\nstderr: Specify where to redirect stderr\nfor options.std{in,out,err}, valid values are:\nprocess.REDIRECT_PIPE (Make it available to subprocess API for reading / writing)\nprocess.REDIRECT_DISCARD (Discard the output. Use this to prevent buffering)\nprocess.REDIRECT_STDOUT (stderr only, for redirecting stderr to stdout)\nReading from process\nTo read from stdout or stderr of a process, use process:read_stdout() and\nprocess:read_stderr() respectively.\nYou can specify a numeric argument to them, which will change the size of internal buffer used\nto read the output.\nAlternatively, you could use process:read() with process.STREAM_STDERR and process.STREAM_STDOUT.\nExample:\nlocal proc = process.start { \"sh\", \"-c\", \"echo hello world!\" }\n-- do not use `while proc:running()` if you care about output.\n-- The process could die and leave data in the buffer\n-- You should just read until `proc:read_stdout()` returns nil\nwhile true do\n\\tlocal rdbuf = proc:read_stdout()\n\\tif not rdbuf then break end\n\\t-- yay, output\nend\nWriting to process\nYou can use process:write(data) to write a string to stdin.\nChecking completion\nprocess:running() returns a boolean to indicate whether if the process is running.\nprocess:wait(time) also does the same thing, but you specify how long it should wait (or 0 to return immediately).\nTerminating process\nprocess:terminate() sends SIGTERM (or Windows equivalent) to the process.\nprocess:kill() sends SIGKILL (or Windows equivalent) to the progress.\nUse this only if process:terminate() cannot kill the process, as it can cause issues.\nMisc\nprocess:pid() returns the PID of the process.\nThere are no guarantees for this PID to be correct if the process terminated early.\nprocess:returncode() returns the exit code of the process, if any\nprocess:close_stream() closes stdin, stdout or stderr stream of the process."},{"id":"en/tutorials/syntax-highlighting.html","title":"Lite XL - Syntax Highlighting","category":["tutorials"],"content":"Syntax Highlighting\nHow to create syntax highlighting plugins for Lite XL\nSyntax highlighting plugins for Lite XL are Lua files. These define some patterns or regular expressions that\nmatch different parts of a given language, assigning token types to each match.\nThese different token types are then given different colors by your chosen color scheme.\nLike other plugins, syntax definitions are sourced from the following folders, in order:\n/usr/share/lite-xl/plugins/\n$HOME/.config/lite-xl/plugins/\nNOTE: The exact location of these folders will depend on your OS and installation method. For example, on Windows, the variable $USERPROFILE will be used instead of $HOME.\nThe user module folder for Lite XL can generally be found in these places on different OSes:\nWindows: C:\\Users\\(username)\\.config\\lite-xl\nMacOS: /Users/(usernmame)/.config/lite-xl\nLinux: /home/(username)/.config/lite-xl\nSo, to create a new syntax definition on Linux, you can just create a .lua file in your $HOME/.config/lite-xl/plugins/ folder.\nWhat syntax token types are supported?\nThe supported syntax token types, defined by lite-xl/core/style.lua, are:\nnormal\nsymbol\ncomment\nkeyword\nkeyword2\nnumber\nliteral\nstring\noperator\nfunction\nIn your syntax highlighting plugin, you write patterns to match parts of the language syntax, assigning these token types to matches. You don't have to use them all - just use as many as you need for your language.\nLet's walk through an example syntax definition and see how this works.\nExample syntax: ssh config files\nThis is a small, simple example of a syntax definition. It's intended to highlight SSH Config files and looks like this:\n-- mod-version:2 -- lite-xl 2.0\nlocal syntax = require \"core.syntax\"\nsyntax.add {\n\\tfiles = { \"sshd?/?_?config$\" },\n\\tcomment = '#',\n\\tpatterns = {\n\\t{ pattern = \"#.*\\n\",\\ttype = \"comment\"\\t},\n\\t{ pattern = \"%d+\",\\ttype = \"number\"\\t},\n\\t{ pattern = \"[%a_][%w_]*\",\\ttype = \"symbol\"\\t},\n\\t{ pattern = \"@\",\\ttype = \"operator\" },\n\\t},\n\\tsymbols = {\n\\t-- ssh config\n\\t[\"Host\"]\\t= \"function\",\n\\t[\"ProxyCommand\"]\\t= \"function\",\n\\t[\"HostName\"]\\t= \"keyword\",\n\\t[\"IdentityFile\"]\\t= \"keyword\",\n\\t...\n\\t-- sshd config\n\\t[\"Subsystem\"]\\t= \"keyword2\",\n\\t-- Literals\n\\t[\"yes\"]\\t= \"literal\",\n\\t[\"no\"]\\t= \"literal\",\n\\t[\"any\"]\\t= \"literal\",\n\\t[\"ask\"]\\t= \"literal\",\n\\t},\n}\nLet's take each section in turn and see how it works.\nHeader\nThe first line is a Lua comment & tells Lite XL which version this plugin requires. The second imports the core.syntax module\nfor us to use:\n-- mod-version:2 -- lite-xl 2.0\nlocal syntax = require \"core.syntax\"\nWe then add a syntax definition to lite, using syntax.add {...}. The contents of this definition are covered next.\nFiles\nThe files property tells Lite XL which files this syntax should be used for. This is a Lua pattern that matches against the full path of the file being opened. For example, to match against Markdown files - with either a .md or a .markdown extension,\nyou could do this:\nfiles = { \"%.md$\", \"%.markdown$\" },\nIn our original example, we match against the end of the path rather than the extension, because SSH config files don't have extensions - and we don't want to match all config files. We expect the path for SSH config files to look something like one of these:\n~/.ssh/config\n/etc/ssh/ssh_config\n/etc/ssh/sshd_config\nThis pattern matches paths that look like that:\nfiles = { \"sshd?/?_?config$\" },\nComment\nThe comment property doesn't define which parts of the syntax are comments - see Patterns for that, below. This property tells Lite XL which character to insert at the start of selected lines when you press ctrl+/.\nYou can also use block_comment to tell Lite XL how to create multiline / block comments.\nPatterns\nA given piece of text can only match one pattern. Once Lite XL decides that a piece of text matches a pattern, it will assign that token type to that piece and move on.\nPatterns are tested in the order that they are written in the syntax definition, so the first match will win.\nEach pattern takes one of the following forms:\nSimple Pattern\n{ pattern = \"#.*\\n\",\\ttype = \"comment\" },\nThis form matches the line against the pattern and if it matches, assigns the matching text to the given token type - comment, in this case.\nStart & End Pattern\n{ pattern = { \"%[\", \"%]\" }, type = \"keyword\" },\nThis form has two patterns - one that matches against the start of the range and one that matches against the end. Everything between the start and the end will be assigned the given token type.\nStart & End Pattern, with Escape\n{ pattern = { '\"', '\"', '\\\\' }, type = \"string\" },\nThis is the same as the previous form, but with an extra, third parameter.\nThe 3rd part, the '\\\\' part in this example, specifies the character that allows escaping the closing match.\nFor more on Lua Patterns, see: Lua Pattern Reference\nIf you need to use PCRE Regular Expressions, instead of Lua Patterns, you can use the regex keyword here, instead of pattern.\nSymbols\nThis is not related to the symbol token type.\nThe symbols section allows you to assign token types to particular keywords or strings - usually reserved words in the language you are highlighting.\nThe token type in this section always take precedence over token types declared in patterns.\nFor example this highlights Host using the function token type, HostName as a keyword and yes, no, any & ask as a literal:\n[\"Host\"]\\t= \"function\",\n[\"HostName\"]\\t= \"keyword\",\n[\"yes\"]\\t= \"literal\",\n[\"no\"]\\t= \"literal\",\n[\"any\"]\\t= \"literal\",\n[\"ask\"]\\t= \"literal\",\nTips: double check your patterns!\nThere are a few common mistakes that can be made when using the symbols table in conjunction with patterns.\nCase 1: Spaces between two symbols tokens\nLet's have an example:\n{ pattern = \"[%a_][%w_]+%s+()[%a_][%w_]+\", type = { \"keyword2\", \"symbol\" } }\nLet's explain the pattern a bit (omitting the empty parentheses):\n[%a_] = any alphabet and underscore\n[%w_] = any alphabet, numbers and underscore\n%s = any whitespace character\nWORD =\n\\t[%a_] followed by (1 or more [%w_])\npattern =\n\\tWORD followed by (one or more %s) followed by WORD\nAfterwards, you add an entry [\"my\"] = \"literal\" in the symbols table.\nYou test the syntax with my function found that \"my\" isn't highlighted as literal. Why did that happen?\nsymbols table requires an exact match.\nIf you look carefully, the empty parentheses (()) is placed after the space!\nThis tells Lite XL that WORD followed by (one or more %s) is a token, which will match my (note the space in the match).\nThe fix is to add a normal token for the whitespace between the two tokens:\n{ pattern = \"[%a_][%w_]+()%s+()[%a_][%w_]+\", type = { \"keyword2\", \"normal\", \"symbol\" } }\nCase 2: Patterns & symbols tokens\nOne might assume that Lite XL magically matches text against the symbols table. This is not the case.\nIn some languages, people may add a generic pattern to delegate the matching to the symbols table.\n{ pattern = \"[%a_][%w_]*\", \"symbol\" }\nHowever, the symbols table may look like this:\nsymbols = {\n\\t[\"my-symbol\"] = \"function\",\n\\t[\"..something_else\"] = \"literal\"\n}\n\"my-symbol contains a dash (-) and \"..something_else\" contains 2 dots (.).\nNone of the characters are matched by [%a_][%w_]*!\nBeware of the text you intend to match in the symbols table.\nIf you want to use it, you need to ensure that it can matched by one of the patterns.\nThe correct patterns are:\n{ pattern = \"[%a_][%w%-_]*\", \"symbol\" },\n{ pattern = \"%.%.[%a_][%w_]*\", \"symbol\" },\nTesting Your New Syntax\nTo test your new syntax highlighting you need to do two things:\nReload the Lite XL core\nLoad a file in your chosen language and see how it looks\nTo reload the core, you can either restart Lite XL, or reload the core from the command palette, without needing to restart.\nTo do this, type ctrl+shit+p to show the command palette, then select Core: Restart (or type crr or something similar to match it), then press Enter. You will need to restart the core after any changes you make to the syntax highlighting definition.\nExample advanced syntax: Markdown\nNote: This example has features from 2.1. It is not compatible with older versions of lite-xl.\nNot all languages are as simple as SSH config files. Markup languages like HTML and Markdown are especially hard to parse correctly. Here's the markdown syntax file in its full glory:\n-- mod-version:3\nlocal syntax = require \"core.syntax\"\nlocal style = require \"core.style\"\nlocal core = require \"core\"\nlocal initial_color = style.syntax[\"keyword2\"]\n-- Add 3 type of font styles for use on markdown files\nfor _, attr in pairs({\"bold\", \"italic\", \"bold_italic\"}) do\n\\tlocal attributes = {}\n\\tif attr ~= \"bold_italic\" then\n\\tattributes[attr] = true\n\\telse\n\\tattributes[\"bold\"] = true\n\\tattributes[\"italic\"] = true\n\\tend\n\\t-- no way to copy user custom font with additional attributes :(\n\\tstyle.syntax_fonts[\"markdown_\"..attr] = renderer.font.load(\n\\tDATADIR .. \"/fonts/JetBrainsMono-Regular.ttf\",\n\\tstyle.code_font:get_size(),\n\\tattributes\n\\t)\n\\t-- also add a color for it\n\\tstyle.syntax[\"markdown_\"..attr] = style.syntax[\"keyword2\"]\nend\nlocal in_squares_match = \"^%[%]\"\nlocal in_parenthesis_match = \"^%(%)\"\nsyntax.add {\n\\tname = \"Markdown\",\n\\tfiles = { \"%.md$\", \"%.markdown$\" },\n\\tblock_comment = { \"<!--\", \"-->\" },\n\\tspace_handling = false, -- turn off this feature to handle it our selfs\n\\tpatterns = {\n\\t---- Place patterns that require spaces at start to optimize matching speed\n\\t---- and apply the %s+ optimization immediately afterwards\n\\t-- bullets\n\\t{ pattern = \"^%s*%*%s\",\\ttype = \"number\" },\n\\t{ pattern = \"^%s*%-%s\",\\ttype = \"number\" },\n\\t{ pattern = \"^%s*%+%s\",\\ttype = \"number\" },\n\\t-- numbered bullet\n\\t{ pattern = \"^%s*[0-9]+[%.%)]%s\",\\ttype = \"number\" },\n\\t-- blockquote\n\\t{ pattern = \"^%s*>+%s\",\\ttype = \"string\" },\n\\t-- alternative bold italic formats\n\\t{ pattern = { \"%s___\", \"___%f[%s]\" },\\ttype = \"markdown_bold_italic\" },\n\\t{ pattern = { \"%s__\", \"__%f[%s]\" },\\ttype = \"markdown_bold\" },\n\\t{ pattern = { \"%s_[%S]\", \"_%f[%s]\" },\\ttype = \"markdown_italic\" },\n\\t-- reference links\n\\t{\n\\tpattern = \"^%s*%[%^()[\"..in_squares_match..\"]+()%]: \",\n\\ttype = { \"function\", \"number\", \"function\" }\n\\t},\n\\t{\n\\tpattern = \"^%s*%[%^?()[\"..in_squares_match..\"]+()%]:%s+.+\\n\",\n\\ttype = { \"function\", \"number\", \"function\" }\n\\t},\n\\t-- optimization\n\\t{ pattern = \"%s+\",\\ttype = \"normal\" },\n\\t---- HTML rules imported and adapted from language_html\n\\t---- to not conflict with markdown rules\n\\t-- Inline JS and CSS\n\\t{\n\\tpattern = {\n\\t\"<%s*[sS][cC][rR][iI][pP][tT]%s+[tT][yY][pP][eE]%s*=%s*\" ..\n\\t\"['\\\"]%a+/[jJ][aA][vV][aA][sS][cC][rR][iI][pP][tT]['\\\"]%s*>\",\n\\t\"<%s*/[sS][cC][rR][iI][pP][tT]>\"\n\\t},\n\\tsyntax = \".js\",\n\\ttype = \"function\"\n\\t},\n\\t{\n\\tpattern = {\n\\t\"<%s*[sS][cC][rR][iI][pP][tT]%s*>\",\n\\t\"<%s*/%s*[sS][cC][rR][iI][pP][tT]>\"\n\\t},\n\\tsyntax = \".js\",\n\\ttype = \"function\"\n\\t},\n\\t{\n\\tpattern = {\n\\t\"<%s*[sS][tT][yY][lL][eE][^>]*>\",\n\\t\"<%s*/%s*[sS][tT][yY][lL][eE]%s*>\"\n\\t},\n\\tsyntax = \".css\",\n\\ttype = \"function\"\n\\t},\n\\t-- Comments\n\\t{ pattern = { \"<!%-%-\", \"%-%->\" },\\ttype = \"comment\" },\n\\t-- Tags\n\\t{ pattern = \"%f[^<]![%a_][%w_]*\",\\ttype = \"keyword2\" },\n\\t{ pattern = \"%f[^<][%a_][%w_]*\",\\ttype = \"function\" },\n\\t{ pattern = \"%f[^<]/[%a_][%w_]*\",\\ttype = \"function\" },\n\\t-- Attributes\n\\t{\n\\tpattern = \"[a-z%-]+%s*()=%s*()\\\".-\\\"\",\n\\ttype = { \"keyword\", \"operator\", \"string\" }\n\\t},\n\\t{\n\\tpattern = \"[a-z%-]+%s*()=%s*()'.-'\",\n\\ttype = { \"keyword\", \"operator\", \"string\" }\n\\t},\n\\t{\n\\tpattern = \"[a-z%-]+%s*()=%s*()%-?%d[%d%.]*\",\n\\ttype = { \"keyword\", \"operator\", \"number\" }\n\\t},\n\\t-- Entities\n\\t{ pattern = \"&#?[a-zA-Z0-9]+;\",\\ttype = \"keyword2\" },\n\\t---- Markdown rules\n\\t-- math\n\\t{ pattern = { \"%$%$\", \"%$%$\", \"\\\\\"\\t},\\ttype = \"string\", syntax = \".tex\"},\n\\t{ pattern = { \"%$\", \"%$\", \"\\\\\" },\\ttype = \"string\", syntax = \".tex\"},\n\\t-- code blocks\n\\t{ pattern = { \"```c++\", \"```\" },\\ttype = \"string\", syntax = \".cpp\" },\n\\t-- ... there's some other patterns here, but I removed them for brevity\n\\t{ pattern = { \"```lobster\", \"```\" },\\ttype = \"string\", syntax = \".lobster\" },\n\\t{ pattern = { \"```\", \"```\" },\\ttype = \"string\" },\n\\t{ pattern = { \"``\", \"``\" },\\ttype = \"string\" },\n\\t{ pattern = { \"%f[\\\\`]%`[%S]\", \"`\" },\\ttype = \"string\" },\n\\t-- strike\n\\t{ pattern = { \"~~\", \"~~\" },\\ttype = \"keyword2\" },\n\\t-- highlight\n\\t{ pattern = { \"==\", \"==\" },\\ttype = \"literal\" },\n\\t-- lines\n\\t{ pattern = \"^%-%-%-+\\n\",\\ttype = \"comment\" },\n\\t{ pattern = \"^%*%*%*+\\n\",\\ttype = \"comment\" },\n\\t{ pattern = \"^___+\\n\",\\ttype = \"comment\" },\n\\t-- bold and italic\n\\t{ pattern = { \"%*%*%*%S\", \"%*%*%*\" },\\ttype = \"markdown_bold_italic\" },\n\\t{ pattern = { \"%*%*%S\", \"%*%*\" },\\ttype = \"markdown_bold\" },\n\\t-- handle edge case where asterisk can be at end of line and not close\n\\t{\n\\tpattern = { \"%f[\\\\%*]%*[%S]\", \"%*%f[^%*]\" },\n\\ttype = \"markdown_italic\"\n\\t},\n\\t-- alternative bold italic formats\n\\t{ pattern = \"^___[%s%p%w]+___%s\" ,\\ttype = \"markdown_bold_italic\" },\n\\t{ pattern = \"^__[%s%p%w]+__%s\" ,\\ttype = \"markdown_bold\" },\n\\t{ pattern = \"^_[%s%p%w]+_%s\" ,\\ttype = \"markdown_italic\" },\n\\t-- heading with custom id\n\\t{\n\\tpattern = \"^#+%s[%w%s%p]+(){()#[%w%-]+()}\",\n\\ttype = { \"keyword\", \"function\", \"string\", \"function\" }\n\\t},\n\\t-- headings\n\\t{ pattern = \"^#+%s.+\\n\",\\ttype = \"keyword\" },\n\\t-- superscript and subscript\n\\t{\n\\tpattern = \"%^()%d+()%^\",\n\\ttype = { \"function\", \"number\", \"function\" }\n\\t},\n\\t{\n\\tpattern = \"%~()%d+()%~\",\n\\ttype = { \"function\", \"number\", \"function\" }\n\\t},\n\\t-- definitions\n\\t{ pattern = \"^:%s.+\",\\ttype = \"function\" },\n\\t-- emoji\n\\t{ pattern = \":[a-zA-Z0-9_%-]+:\",\\ttype = \"literal\" },\n\\t-- images and link\n\\t{\n\\tpattern = \"!?%[!?%[()[\"..in_squares_match..\"]+()%]%(()[\"..in_parenthesis_match..\"]+()%)%]%(()[\"..in_parenthesis_match..\"]+()%)\",\n\\ttype = { \"function\", \"string\", \"function\", \"number\", \"function\", \"number\", \"function\" }\n\\t},\n\\t{\n\\tpattern = \"!?%[!?%[?()[\"..in_squares_match..\"]+()%]?%]%(()[\"..in_parenthesis_match..\"]+()%)\",\n\\ttype = { \"function\", \"string\", \"function\", \"number\", \"function\" }\n\\t},\n\\t-- reference links\n\\t{\n\\tpattern = \"%[()[\"..in_squares_match..\"]+()%] *()%[()[\"..in_squares_match..\"]+()%]\",\n\\ttype = { \"function\", \"string\", \"function\", \"function\", \"number\", \"function\" }\n\\t},\n\\t{\n\\tpattern = \"!?%[%^?()[\"..in_squares_match..\"]+()%]\",\n\\ttype = { \"function\", \"number\", \"function\" }\n\\t},\n\\t-- url's and email\n\\t{\n\\tpattern = \"<[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+%.[a-zA-Z0-9-.]+>\",\n\\ttype = \"function\"\n\\t},\n\\t{ pattern = \"<https?://%S+>\",\\ttype = \"function\" },\n\\t{ pattern = \"https?://%S+\",\\ttype = \"function\" },\n\\t-- optimize consecutive dashes used in tables\n\\t{ pattern = \"%-+\",\\ttype = \"normal\" },\n\\t},\n\\tsymbols = { },\n}\n-- Adjust the color on theme changes\ncore.add_thread(function()\n\\twhile true do\n\\tif initial_color ~= style.syntax[\"keyword2\"] then\n\\tfor _, attr in pairs({\"bold\", \"italic\", \"bold_italic\"}) do\n\\tstyle.syntax[\"markdown_\"..attr] = style.syntax[\"keyword2\"]\n\\tend\n\\tinitial_color = style.syntax[\"keyword2\"]\n\\tend\n\\tcoroutine.yield(1)\n\\tend\nend)\nSyntax fonts (Since 1.16.10)\nThe syntax allows users to set different font styles (bold, italic, etc.) for different patterns.\nTo change the font style of a token, add a Font to style.syntax_fonts[token_type].\nFor example:\n-- will ensure every \"fancysyntax_fancy_token\" is italic\nstyle.syntax_fonts[\"fancysyntax_fancy_token\"] = renderer.font.load(\"myfont.ttf\", 14 * SCALE, { italic = true })\nThe markdown example automates this with a for loop.\nThe limitations here are that fonts cannot be copied with different attributes, thus the font path has to be hardcoded.\nOther than that, abusing style.syntax_fonts may lead to slow performance and high memory consumption.\nThis is very obvious when the user tries to resize the editor with ctrl-scroll or ctrl+ and ctrl-.\nPlease use it in moderation.\nSpace handling (v2.1 (upcoming) / master)\nBy default, Lite XL prepends a pattern { pattern = \"%s+\", type = \"normal\" } to the syntax.\nThis improves the performance drastically on lines that starts with whitespaces (eg. heavily indented lines)\nby matching the whitespace before other patterns in order to prevent Lite XL from iterating the entire syntax.\nHowever, there may be syntaxes that require matching spaces (eg. Markdown with indented blocks)\nso this can be disabled by setting space_handling to false.\nTo keep the space handling optimization or to support older versions of Lite XL,\n{ pattern = \"%s+\", type = \"normal\" } can be added after patterns that require space.\nSimple patterns with multiple tokens (v1.16.10)\nThis is an excerpt taken from the markdown plugin:\nlocal in_squares_match = \"^%[%]\"\n-- reference links\n{\n\\tpattern = \"^%s*%[%^()[\"..in_squares_match..\"]+()%]: \",\n\\ttype = { \"function\", \"number\", \"function\" }\n},\nSometimes it makes sense to highlight different parts of a pattern differently.\nAn empty parentheses (()) in Lua patterns will return the position of the text in the parentheses.\nThis will tell Lite XL when to change the type of token.\nFor instance, ^%s*%[%^ is \"function\", [\"..in_squares_match..\"]+ is \"number\" and %]: is \"function\".\nSubsyntaxes (Since v1.16.10)\nLite XL supports embedding another syntax into the existing syntax.\nThis is used to support code blocks inside the markdown syntax.\nFor example:\nlua\n{ pattern = { \"cpp\", \"\" },\\ttype = \"string\", syntax = \".cpp\" },\nThis would highlight `` cpp `` and `` `with\"string\"while everything inside them will be highlighted with a syntax that matches\".cpp\"`."},{"id":"en/tutorials/simple-plugin.html","title":"Lite XL - Simple Plugin","category":["tutorials"],"content":"Simple Plugin\nWhat is Simple?\nSimple is a very basic plugin written with the intention of introducing developers\nwho are new to Lite XL to the process of writing plugins for the editor.\nWhat does the plugin do?\nThe plugin displays a message (that is taken as input from the user) at the top\nright corner of the editor window. It also allows the user to toggle\nthe visibility of the message.\nI can't write Lua!\nIf you come from other programming languages, take a look at Lua cheatsheet.\nIf you're new to programming, you can read this.\nFormat of the tutorial\nThe code contains comments detailing what most (if not all)\nof the code in the file does.\nThe code :\n-- mod-version:3\n-- you MUST put mod-version:x on the first line of your plugin\n-- mod-version usually maps to lite-xl releases (eg. mod-version: 2 == lite-xl 2.0)\n-- lite-xl won't load the plugin if the mod-version mismatches\n-----------------------------------------------------------------------\n-- NAME\\t: Simple\n-- DESCRIPTION: A simple guide on how to make your first Lite XL plugin\n-- AUTHOR\\t: Ashwin Godbole (aelobdog)\n-- GOALS\\t: To render some text inside the editor\n-----------------------------------------------------------------------\n-- Disclaimer :\n-- I am not a lua developer, and my knowledge about writing plugins for\n-- Lite XL is very limited. This file serves the purpose of helping the\n-- reader get started with plugin development for Lite XL, and therefore\n-- demonstrates only some very basic features. For more complex plugin\n-- development, be sure to check out the source code of some other\n-- plugins after going through this file.\n-----------------------------------------------------------------------\n-- Before we start writing any code for the plugin, we must import the\n-- required modules from the \"core\" package.\n-- the \"core\" module\nlocal core = require \"core\"\n-- the \"command\" module will help us register commands for our plugin.\nlocal command = require \"core.command\"\n-- the \"style\" module will allow us to use styling options\nlocal style = require \"core.style\"\n-- the \"config\" module will be used to store certain things like colors\n-- and functions\nlocal config = require \"core.config\"\n-- the \"keymap\" module will allow us to set keybindings for our commands\nlocal keymap = require \"core.keymap\"\n-- since we want to modify RootView, we'll need to require it first\nlocal RootView = require \"core.rootview\"\n-----------------------------------------------------------------------\n-- per-plugin config must stay in config.plugins.(plugin name)\nconfig.plugins.simple = {}\n-- colors are just three or four comma separated values (RGBA) (range 0 - 255)\n-- put inside of '{ }'. We will add our color to the config module.\nconfig.plugins.simple.text_color = {200, 140, 220} -- or use `{ common.color \"#C88CDC\" }`\n-----------------------------------------------------------------------\n-- Let's create a function to calculate the coordinates of our text.\n-- While we're at it, let's add our function to the `config` module.\n-- We'll take the message we want to display as the argument to the\n-- function to determine the x and y coordinates of the text.\nfunction config.plugins.simple.get_text_coordinates(message)\n\\t-- For this plugin, we want to display the text on the top right\n\\t-- corner of the screen. For this, we need to know the editor's width\n\\t-- and height.\n\\t-- The current font's size can be obtained from the \"style\" module.\n\\t-- The editor's dimensions can be obtained by\n\\t--\\t1. WIDTH\\t: core.root_view.size.x\n\\t--\\t2. HEIGHT : core.root_view.size.y\n\\tlocal message_width = style.code_font:get_width(message..\" \")\n\\tlocal font_height = style.code_font:get_size()\n\\tlocal x = core.root_view.size.x - message_width\n\\tlocal y = font_height / 2\n\\treturn x, y\nend\n-----------------------------------------------------------------------\n-- Let's now get to actually drawing the text inside the editor.\n-- In order to \"inject\" our own code to draw text,\n-- we'll need to save the original draw function\n-- We'll save `RootView.draw` to a variable we call `parent_draw`\nlocal parent_draw = RootView.draw\n-- Now let's overload the original definition of `draw` in RootView\n-- by redefining the function.\nfunction RootView:draw()\n\\t-- We call the parent's function to keep the editor functional...\n\\t-- obviously we must still draw all the other stuff !\n\\t-- So we call the `parent_draw` function before doing anything else.\n\\tparent_draw(self)\n\\t-- we'll add an option to toggle the message on and off. let's use a\n\\t-- boolean variable to keep track of whether we want to display the\n\\t-- message or not.\n\\tif config.plugins.simple.show_my_message then\n\\t-- We'll be getting the message to display as input from the user\n\\t-- later. We'll store that user input in `config.plugins.simple.hw_message`.\n\\t-- (NOTE: this variable does not come in-built in lite-xl;\n\\t--\\tit is a variable that we will define later.)\n\\t-- let's store the value of config.plugins.simple.hw_message in a local variable\n\\t-- `message` in case config.plugins.simple.hw_message we set the message to\n\\t-- \"message not set yet!\"\n\\tlocal message\n\\tif config.plugins.simple.hw_message then\n\\tmessage = config.plugins.simple.hw_message\n\\telse\n\\tmessage = \"Message not set yet !\"\n\\tend\n\\t-- let's get the coordinates for our text\n\\tlocal x, y = config.plugins.simple.get_text_coordinates(message)\n\\t-- let's finally draw the text to the window !\n\\t-- the draw_text function from `renderer` is an important function\n\\t-- as it is used to display any and all text inside of the editor\n\\t-- window\n\\trenderer.draw_text(style.code_font, message, x, y, config.plugins.simple.text_color)\n\\tend\nend\n-----------------------------------------------------------------------\n-- Let's allow the user to turn the message on and off\n-- we'll write a function to flip our \"show\" boolean variable.\nlocal function toggle_helloworld()\n\\tconfig.plugins.simple.show_my_message = not config.plugins.simple.show_my_message\nend\n-----------------------------------------------------------------------\n-- Finally, let's add the toggle function to the command list so that\n-- we can call it from the C-S-p command panel. Let's add one command\n-- to toggle the visibility of the message on and off and one to get\n-- the user's message and then display it.\ncommand.add(nil, {\n\\t-- Toggle the visibility of the message\n\\t[\"simple:toggle\"] = toggle_helloworld,\n\\t-- Set and show the message\n\\t-- This is the way to get user input through the command bar.\n\\t-- `core.command_view:enter` takes 2 arguments:\n\\t--\\t* the prompt to display before taking input\n\\t--\\t* a function that takes the \"input\" as its argument\n\\t-- (NOTE: here the variable we are reading input into is `text`)\n\\t[\"simple:setshow\"] = function()\n\\tcore.command_view:enter(\"Test to display\", {\n\\tsubmit = function(text)\n\\tconfig.plugins.simple.hw_message = text\n\\tconfig.plugins.simple.show_my_message = true\n\\tend\n\\t})\n\\tend\n})\n-----------------------------------------------------------------------\n-- Just for fun, let's assign our commands their own keybindings.\n-- Here, we assign the keybinding the same string(its name) as the one\n-- that we set while creating the command\nkeymap.add {\n\\t[\"alt+s\"] = \"simple:setshow\",\n\\t[\"alt+t\"] = \"simple:toggle\",\n}\nFurther reading\nLite: An Implementation Overview, an excellent post by rxi that stays mostly relevant to lite-xl.\nAPI overview, where some of the APIs are explained."},{"id":"en/tutorials/index.html","title":"Lite XL - Tutorials","category":["tutorials"],"content":"Tutorials\nThese pages contain tutorials and documentations for building plugins in Lite XL.\nAPI Overview\nSimple Plugin\nSyntax Highlighting\nSystem Fonts"},{"id":"en/about/contributors.html","title":"Lite XL - Contributors","category":["about"],"content":"Contributors\nName\tContributions\nrxi\tOriginal development of lite editor.\nFrancesco\tCreator of lite-xl fork from rxi/lite.\nTakase\tNagView and X Window database resource query for Xft.dpi setting.\nNils Kvist\tPopup window replacement with CommandView dialog.\nliquidev\tTab style and animations improvements.\nAdam\tMulti-language syntax highlighting and many other improvements.\nCukmekerb\tSyntax highlighting improvements.\nJanis-Leuenberger\tAdd keymap bindings help file and macOS testing.\nMat Mariani\tHelp for macOS port. Some resources taken from mathewmariani/lite-macos.\ndaubaris\tInitial implementation of Xft.dpi query using xrdb command.\nRobert Štojs\tContinuos integration configuration."},{"id":"en/about/faq.html","title":"Lite XL - FAQ","category":["about"],"content":"FAQ\nCan I get smart autocompletion (intellisense/LSP)?\nCheck out the LSP plugin.\nWhere is the integrated terminal?\nYou can try lite-xl-terminal.\nTabs and indent size?\nIn your user config (the cog icon in the file tree):\nconfig.tab_type = \"soft\" -- soft for spaces, hard for real tabs (\\t)\nconfig.indent_size = 4\\t-- 4 spaces\nHow to bind commands to keys?\nlocal keymap = require \"core.keymap\"\nkeymap.add { [\"ctrl+escape\"] = \"core:quit\" }\nHow to unbind commands for certain keys?\n-- the second parameter lets you override commands for certain keys\n-- in this case it maps it to nothing\nkeymap.add({ [\"ctrl+escape\"] = {} }, true)\nHow to get commands for those keybinds?\nYou can search for commands in the command palette.\nFor each command, replace the spaces in the right side with dashes.\nFor example: Core: Find Command → core:find-command\nWhat version of Lua does Lite XL use?\nLua 5.4.\nVim mode?\nYou need to vibe.\nPlugin recommendations\nJust in case you don't want to comb through our plugin repository,\nthese are a list of plugins that just makes Lite XL a lot more pleasant.\nPlugin\tUse case\nautoinsert\tAutomatically insert closing brackets and quotes\nbracketmatch\tHighlight matching brackets\nephemeral_tabs\tEphemeral tabs (previewing files without creating multiple tabs)\ngitdiff_highlight\tGit diff gutter\nlint+\tLinter support\nminimap\tMinimap\nselectionhighlight\tHighlight code that matches the selection\nlite-xl-discord\tDiscord rich presence\nWhere's feature X? How about Y?\nYou can get more info in the Features page."},{"id":"en/about/features.html","title":"Lite XL - Features","category":["about"],"content":"Features\nCurrently, Lite XL offers a lot of features out of the box.\nCross-Platform\nWe currently support Windows, Linux and MacOS (with Retina display support).\nLightweight\nWe are currently around 3MB in size and takes about 10MB in RAM (can be lower). No Electron / WebView involved. The whole thing is just Lua running on a rendering engine.\nExtensible\nWhile the editor is minimal by default, it is very extensible using Lua. In fact, a lot of features are provided by plugins. For example, VSC-like intellisense\nBetter font rendering\nThe editor looks good in screen of any sizes. Some other options are also configurable, such as hinting and antialiasing.\nMulti-cursor editing\nYou can now place multiple cursors by ctrl + lclick on lines or ctrl + shift + up or ctrl + shift + down.\nHere are some features that aren't implemented with the rationales behind it.\nSome of these may be implemented via plugins.\nWe encourage you to give it a shot.\nHardware accelerated rendering\ntl;dr -\\tfranko stated that he isn't considering using OpenGL due to the skills and work involved.\nHardware acceleration was brought up in this discussion.\nTakase had made 2 attempts at this - at first using NanoVG and then forcing SDL to use GPU rendering.\nIn both attempts, the performance gains at best is negligible, while at worst its completely unusable.\nRight now, we decided to focus on optimizing the software renderer and various part of Lua code.\nSystem fonts\nThis is painful because various systems has their own mechanism of managing fonts.\nFor now, users can use the fontconfig plugin.\nFontconfig is widely available on Linux and installable on MacOS, while Windows builds are available.\nIn the future, we might consider adding API to read font metadata, allowing us to write a fontconfig alternative in Lua. (no promises here)\nOpening UNC paths on Windows (network drives, accessing WSL2 files from Windows)\nOur path handling code can only handle POSIX and Windows paths.\nWe also aren't sure how Lite XL will behave in these scenarios.\nInter-window communication (dragging tabs between windows and other magic)\nThis is by far the hardest to achieve.\nLite XL has no intention to link to any widget toolkits (Qt and GTK) which are required for these features.\nAn alternative approach is to create our own IPC mechanism, but that's reinventing the wheel.\nIntegrated terminal\nA terminal is complex to implement.\nThere are projects that can be ported to Lua, such as xterm.js.\nIf someone is interested, they can do so."},{"id":"en/about/index.html","title":"Lite XL - About","category":["about"],"content":"About\nThese pages contain information about Lite XL's features, screenshots and developers. It also contains a FAQ section.\nContributors\nFAQ\nFeatures\nScreenshots"},{"id":"en/about/screenshots.html","title":"Lite XL - Screenshots","category":["about"],"content":"Screenshots\nScreenshot 1 /assets/img/editor.png\nScreenshot 2 /assets/img/editor2.png"},{"id":"en/404.html","title":"Lite XL - Not Found","category":[],"content":"Not Found\nThis page couldn't be found. Please note, that the site is undergoing testing at present, so pages may be missing/moved."},{"id":"en/index.html","title":"Lite XL","category":[],"content":"Lite XL\nA lightweight, simple, fast, feature-filled, and extremely extensible text editor written in C, and Lua, adapted from lite.\nLite XL Editor /assets/img/editor.png"},{"id":"de/downloads.html","title":"Lite XL - Downloads","category":[],"content":"Downloads\nBinary Packete\nBinär Packete sind verfügbar in der GitHub Veröffentlichungensseite.\nInstallieren über Packetverwaltung\nOder du kannst Lite-XL über den Paketmanager deiner Distribution installieren.\nDiese Packete werden von der Community erhalten und sind vielleicht veraltet.\nWindows (Chocolatey / Scoop)\nMac OS (MacPorts)\nArch Linux (AUR)\nNixOS (nixpkgs)\nFedora\nchoco install lite-xl\\t# chocolatey\nscoop bucket add extras && scoop install lite-xl\\t# scoop\nsudo port install lite-xl\\t# macports\nyay -S lite-xl\\t# oder dein lieblings AUR helper\nnix-env -i lite-xl\\t# nixos\nsudo dnf install lite-xl # fedora\nQuellcode\nDas Quellcode ist verfügbar auf GitHub, durch Herunterladen von Zip- oder Tar Archiven,\noder direkt über Git:\ngit clone https://github.com/lite-xl/lite-xl.git"},{"id":"de/documentation/keymap-macos.html","title":"Lite XL - MacOS Keymap","category":["documentation"],"content":"MacOS Keymap\nTastaturkürzeln haben die gleichen Funktionen auf jeden Betriebssystem, sie sind einfach nur anders gebunden\num sich für normale Erwartungen für dem Betriebssystem anzupassen.\nMomentan gibt es nur two Betriebssystemlayouts. MacOS, und alles andere.\nKeymap\nTasten Kombination\tAktionen\ncmd+/\tdoc:toggle-line-comments\ncmd+1\troot:switch-to-tab-1\ncmd+2\troot:switch-to-tab-2\ncmd+3\troot:switch-to-tab-3\ncmd+4\troot:switch-to-tab-4\ncmd+5\troot:switch-to-tab-5\ncmd+6\troot:switch-to-tab-6\ncmd+7\troot:switch-to-tab-7\ncmd+8\troot:switch-to-tab-8\ncmd+9\troot:switch-to-tab-9\ncmd+[\tdoc:move-to-previous-block-start\ncmd+]\tdoc:move-to-next-block-end\ncmd+a\tdoc:select-all\ncmd+backspace\tdoc:delete-to-start-of-indentation\ncmd+c\tdoc:copy\ncmd+ctrl+i\troot:switch-to-up\ncmd+ctrl+j\troot:switch-to-left\ncmd+ctrl+k\troot:switch-to-down\ncmd+ctrl+l\troot:switch-to-right\ncmd+ctrl+return\tcore:toggle-fullscreen\ncmd+ctrl+shift+i\troot:split-up\ncmd+ctrl+shift+j\troot:split-left\ncmd+ctrl+shift+k\troot:split-down\ncmd+ctrl+shift+l\troot:split-right\ncmd+d\tdoc:select-word\ncmd+d\tfind-replace:select-add-next\ncmd+delete\tdoc:delete-to-end-of-line\ncmd+down\tdoc:move-to-end-of-doc\ncmd+f3\tfind-replace:select-next\ncmd+f\tfind-replace:find\ncmd+g\tdoc:go-to-line\ncmd+j\tdoc:join-lines\ncmd+l\tdoc:select-lines\ncmd+left\tdoc:move-to-start-of-indentation\ncmd+n\tcore:new-doc\ncmd+o\tcore:open-file\ncmd+option+down\tdoc:create-cursor-next-line\ncmd+option+up\tdoc:create-cursor-previous-line\ncmd+p\tcore:find-file\ncmd+pagedown\troot:move-tab-right\ncmd+pageup\troot:move-tab-left\ncmd+r\tfind-replace:replace\ncmd+return\tdoc:newline-below\ncmd+right\tdoc:move-to-end-of-line\ncmd+s\tdoc:save\ncmd+shift+[\tdoc:select-to-previous-block-start\ncmd+shift+]\tdoc:select-to-next-block-end\ncmd+shift+backspace\tdoc:delete-to-previous-word-start\ncmd+shift+c\tcore:change-project-folder\ncmd+shift+d\tdoc:duplicate-lines\ncmd+shift+delete\tdoc:delete-to-next-word-end\ncmd+shift+down\tdoc:select-to-end-of-doc\ncmd+shift+k\tdoc:delete-lines\ncmd+shift+l\tdoc:select-word\ncmd+shift+l\tfind-replace:select-add-all\ncmd+shift+left\tdoc:select-to-start-of-indentation\ncmd+shift+o\tcore:open-project-folder\ncmd+shift+p\tcore:find-command\ncmd+shift+return\tdoc:newline-above\ncmd+shift+right\tdoc:select-to-end-of-line\ncmd+shift+s\tdoc:save-as\ncmd+shift+up\tdoc:select-to-start-of-doc\ncmd+up\tdoc:move-to-start-of-doc\ncmd+v\tdoc:paste\ncmd+w\troot:close-or-quit\ncmd+x\tdoc:cut\ncmd+y\tdoc:redo\ncmd+z\tdoc:undo\nctrl+1lclick\tdoc:split-cursor\nctrl+insert\tdoc:copy\nctrl+shift+tab\troot:switch-to-previous-tab\nctrl+tab\troot:switch-to-next-tab\nf3\tfind-replace:repeat-find\noption+backspace\tdoc:delete-to-previous-word-start\noption+delete\tdoc:delete-to-next-word-end\noption+down\tdoc:move-lines-down\noption+left\tdoc:move-to-previous-word-start\noption+right\tdoc:move-to-next-word-end\noption+shift+left\tdoc:select-to-previous-word-start\noption+shift+right\tdoc:select-to-next-word-end\noption+up\tdoc:move-lines-up\nshift+f3\tfind-replace:previous-find"},{"id":"de/documentation/usage.html","title":"Lite XL - Nutzen","category":["documentation"],"content":"Nutzen\nLite XL ist ein leichter Texteditor dass größtensteils geschrieben in Lua - es zielt darauf ab etwas praktisches, schönes, kleines und schnelles zu bieten. \nSo leicht wie möglich umgesetzt; leicht zur modifizieren und erweitern, oder zum Benutzen ohne beides zu machen.\nLite XL ist auf dem Lite Editor basiert und bietet paar Verbesserungen an\nwährend es immernoch kompatible bleibt.\nErste Schritte\nLite XL funktioniert mit Projektverzeichnissen - dies sind Ordnern indem der Code \ndeines Projektes und andere Daten beinhaltet sind.\nUm ein spezifisches Projektverzeichnis zu öffnen kann der Ordnername als Befehlzeilenargument angegeben werden. (. kann angegeben werden um den jetzigen Ordner zu benutzen)\noder der Ordner kann ins Fenster gezogen werden.\nEinmal angefangen kann das Projektverzeichnis mit dem Befehl core:change-project-folder geändert werden. Der Befehl wird alle Dokumente schließen \ndie zu Zeit offen sind und wechselt zum neuen Projektverzeichnis.\nWenn du ein neues Projektverzeichnis in einem neuen Fenster öffnen willst kannst du den Befehl core:open-project-folder ausführen.\nEs wird ein neues Fenster mit dem ausgewählten Projektverzeichnis öffnen.\nDie Hauptmethode um Dateien in Lite XL zu öffnen ist der Befehl core:find-file - \ndies bietet eine fuzzy finder über alle Dateien des Projekts an \nund kann mit dem ctrl+p Abkürzung geöffnet werden.\nBefehle können durch Tastaturkürzel aktiviert werden, oder wenn man core:find-command benutzt.\nDas core:find-command Befehl ist normalerweise an ctrl+shift+p gebunden. Zum Beispiel,\nwenn man die Tastaturkürzel oben drückt und newdoc schreibt und dann return drückt, öffnet man ein neues Dokument.\nDie eingestellte Tastaturkürzel für jedes Befehl kann man auf der rechten Seite des Namens sehen. Also kann man mit ctrl+shift+p drücken, um Tastaturkürzel für Befehle zu finden.\nBenutzerdatenverzeichnisse\nLite XL benutzt Standardsystembenutzerverzeichnisse; Die Nutzerdaten können in $HOME/.config/lite-xl auf Linux und MacOS gefunden werden.\nAuf Windows wird das Variable $USERPROFILE anstatt $HOME benutzt.\nBenutzermodule\nLite XL wird durch Benutzermodule konfiguriert. Das Benutzermodul kann benutzt werden um neue Tastaturkürzel und\nneue Farbschemen hinzuzufügen, oder den Stil oder andere Teile des Editors zu ändern.\nDas Benutzermodul wird geladen nachdem die Anwendung gestartet wurde, nachdem Plugins geladen wurden.\nDas Benutzermodul kann modifiziert werden indem man das core:open-user-module Befehl ausführt\nsonst kann es auch modifiziert werden indem man die $HOME/.config/lite-xl/init.lua Datei öffnet.\nAuf Windows wird das Variable $USERPROFILE anstatt $HOME benutzt.\ntl;dr:\nWindows: C:\\Users\\(username)\\.config\\lite-xl\\init.lua\nMacOS: /Users/(usernmame)/.config/lite-xl/init.lua\nLinux: /home/(username)/.config/lite-xl/init.lua\nDies sind nicht die genauen Orte, aber sie helfen dir sie zu finden.\nBitte bemerke dass Lite XLs Benutzermodul ein ganz anderen Ort hat als Lite Editors.\nProjektmodul\nDas Projektmodul ist ein optionaler Modul der vom aktuellen Verzeichnis des Projekts geladen wird, wenn Lite XL startet.\nProjektmodule können nützlich sein wenn man eigene Befehle für projektspezifische Befehle für Buildsysteme oder das Laden von projektspezifische Plugins braucht.\nNachdem die Plugins- und Benutzermodule geladen wurden,\nDas Projektmodul kann editiert werden indem man core:open-project-module ausführt - Wenn das Modul nicht existiert, wird das Befehl eines erstellen.\nFüge Ordner zum Projekt hinzu\nEs ist möglich andere Projektverzeichnisse hinzuzufügen indem man den core:add-directory Befehl ausführt.\nEs wird auf der rechten Seite angezeigt werden und du kannst die Dateien im Ordner mit den ctrl+p Befehl auswählen.\nAndere Projektverzeichnisse können mit dem core:remove-directory Befehl entfernt werden.\nWenn du dann Lite XL wiederöffnest werden die gleichen Projektverzeichnisse bleiben.\nDie Anwendung merkt sich dein Arbeitsplatz und auch die hinzugefügten Projektverzeichnisse.\nSeit Version 1.15 braucht Lite XL kein Arbeitsplatz Plugin, es ist ein Teil des Editors.\nErstelle einen leeren Ordner\nMit dem files:create-directory Befehl oder control-click im Treeview kann man leere subordner erstellen.\nBefehle\nBefehle werden im Befehlfinder und im Tastaturkürzelsystem von Lite XL benutzt.\nEin Befehl besteht aus diesen drei Komponenten:\nName - der Befehl name in Form von Namensraum:aktion-name, z.B doc:select-all\nAussagen - Eine Funktion die true zurückgibt wenn der Befehl ausgeführt werden kann, z.B für alle Dokumentenbefehle wird geschaut ob das ausgewählte View ein Dokument ist\nFunktion - Die Funktion die das Befehl ausführt\nBefehle können hinzugefügt werden mit der command.add Funktion die vom core.command Modul bereitgestellt wird:\nlocal core = require \"core\"\nlocal command = require \"core.command\"\ncommand.add(\"core.docview\", {\n\\t[\"doc:save\"] = function()\n\\tcore.active_view.doc:save()\n\\tcore.log(\"Saved '%s'\", core.active_view.doc.filename)\n\\tend\n})\nBefehle können programmatisch ausgeführt werden, indem man die command.perform Funktion vom core.command Modul benutzt:\nlocal command = require \"core.command\"\ncommand.perform \"core:quit\"\nTastaturkürzel\nAlle Tastaturkürzel werden vom core.keymap Modul verarbeitet.\nEine Tastaturkürzel verbindet ein \"Kürzel\" (z.B ctrl+q) mit ein oder mehreren Befehlen (z.B core:quit).\nWenn eine Tastaturkürzel gedrückt wird, iteratiert Lite XL über jedes Befehl dass zu dieser Tastaturkürzel zugewiesen wurde\nund führt die Aussage Funktion für diesem Befehl aus - wenn eine Aussage erfolgreich ist, dann stoppt es die Iteration und führt den Befehl aus.\nEin Beispiel ist die tab Taste:\n\\t[\"tab\"] = { \"command:complete\", \"doc:indent\" },\nWenn Tab gedrückt wird, wird command:complete nur ausgeführt wenn die ausgewählte View das Befehleingang ist. Sonst\nwird das doc:indent ausgeführt wenn das ausgewählte View das Dokument ist.\nEin neues Tastaturkürzel kann so in dein Benutzermodul hinzugefügt werden:\nlocal keymap = require \"core.keymap\"\nkeymap.add { [\"ctrl+q\"] = \"core:quit\" }\nEine Liste der Standard Tastaturkürzel kann hier gefunden werden.\nGlobale Variablen\nEs gibt ein paar globale Variablen die vom Editor gesetzt werden.\nDiese Variablen sind überall und sollten nicht überschrieben werden.\nARGS: Befehlszeilenargumente. argv[1] ist der Name der Anwendung, argv[2] ist das erste Parameter, ...\nPLATFORM: Ausgabe von SDL_GetPlatform(). Kann Windows, Mac OS X, Linux, iOS und Android sein.\nSCALE: Schriftartengröße. Normalerweise 1, Aber kann bei HiDPI Systemen höher sein.\nEXEFILE: Absoluter Pfad zur ausführdatei.\nEXEDIR: Der ausführpfad. Schreibe nicht zu diesem Ordner\nVERSION: lite-xl Version.\nMOD_VERSION: mod-version die in Plugins benutzt wird. Wird geändert wenn die API sich ändert.\nPATHSEP: Pfad Trennzeichen. \\ (Windows) or / (Anderen Betriebssystemen)\nDATADIR: Der Daten Ordner, wo der Lua Teil von lite-xl ist. Schreibe nicht zu diesem Ordner.\nUSERDIR: Benutzerkonfiguration Ordner.\nUSERDIR soll anstatt DATADIR benutzet werden wenn man den Editor konfiguriert\nweil DATADIR vielleicht nicht schreibbar ist.\n(Zum Beispiel, wenn der Editor in /usr installiert ist, dann ist DATADIR in /usr/share/lite-xl!)\nUSERDIR ist immer für den Nutzer schreibbar, es erlaubt mehrere Nutzer ihren Editor zu konfigurieren\nPlugins\nPlugins in Lite XL sind normale Lua Module und werden auch so behandelt - Kein komplizierter Pluginmanager wird bereitgestellt, und wenn einmal ein Plugin geladen ist, kann es sich nicht selber entladen.\nUm ein Plugins zu installieren kannst du es einfach im plugins Ordner im Benutzermodulordner reingeben.\nWenn Lite XL startet, ladet es zuerst die Plugins im Datenordner, dann wird es die Plugins im Benutzermodulordner laden.\nUm ein Plugin zu deinstallieren, kann man einfach die Plugin Datei löschen - alle Plugins \n(Auch die was mit dem Editor installiert kommen) können gelöscht werden, um ihre Funktionen zu entfernen.\nWenn du Plugins nur unter bestimmten Umstanden laden willst (z.B nur in einem bestimmen Project), \ndann kann der Plugin irgendwo außer im plugins Ordner gegeben werden. Der Plugin kann dann manuell geladen werden mit der\nrequire Funktion.\nPlugins können vom Plugins Repository heruntergeladen werden.\nDen Editor neustarten\nWenn du eine Benutzerkonfiguration Datei oder eine Lua Implementation Datei modifizierst, \ndann kannst du mit core:restart Befehl den Editor neustarten.\nDie ganze Anwendung wird neugeladen indem es ein existierendes Fenster neustartet.\nColor Themes\nFarbthemen in Lite XL sind Lua Module die Farbfelder von Lite XLs core.style Modul überschreiben.\nVordefinierte Farbenmethoden sind im colors Ordner im Datenordner.\nNeue Farbthemen können installiert werden im colors Ordner dass in dein Benutzermodulordner ist.\nEin Farbthema kann benutzt werden indem man es in dein Benutzermodulordner erfordert:\ncore.reload_module \"colors.winter\"\nIm Lite Editor wird die require funktion benutzt anstatt core.reload_module.\nIn Lite XL soll core.reload_module benutzt werden um sicher zu sein, dass ein Farbmodul echt neugeladen wird,\nwenn man die Benutzerkonfiguration speichert.\nFarbthemen können vom Farbthemen Repository heruntergeladen werden.\nSie sind in Lite XL Veröffentlichungpacketen enthalten."},{"id":"de/documentation/build.html","title":"Lite XL - Bauen","category":["documentation"],"content":"Bauen\nWenn du dann den Quellcode hast, kannst du Lite XL mit Meson für dich selber bauen.\nZusätzlich gibt es das build-packages.sh Script dass benutzt werden kann, um Lite XL zu kompilieren und\nein Betriebsystemspezifisches Packet für Linux, Windows oder MacOS zu erstellen.\nDie folgenen Bibliotheken werden gebraucht:\nfreetype2\nSDL2\nDie folgenden Bibliotheken sind optional:\nlibagg\nLua 5.2\nWenn sie nicht gefunden werden können, werden sie von Meson heruntergeladen und kompiliert.\nSonst wenn sie present sind, werden sie benutzt um Lite XL zu bauen.\nBau Script\nWenn du Lite XL selber kompilieren willst, \nist es empfohlen, den build-packages.sh Script zu benutzen:\nbash build-packages.sh -h\nDer Script wird Meson ausführen und erstellt ein tar komprimiertes Archiv mit der Anwendung, oder\nfür Windows, eine zip Datei. Lite XL kann leicht installiert werden, indem man das Archiv auspackt.\nUnter Windows werden zwei Packete erstellt, eines heißt \"portable\" dass den Datenordner neben der Ausführbarendatei haben wird.\nDas andere Packet benutzt ein unix-ähnlichen Layout, es ist gemeint für die Leute, die ein unix-ähnliches Shell und Befehlszeile benutzen.\nBitte bemerke dass es keine fest codierte Ordner in der Ausführenbarendatei gibt, also können Packete in allen Ordnern benutzt werden.\nPortable\nWenn man meson setup ausführt, gibt es eine Option -Dportable=true die sagt, ob Dateien als tragbare Anwendung installiert werden soll.\nWenn portable berechtigt wurde, wird Lite XL den Datenordner neben der Anwendung platzieren.\nSonst wird Lite XL Unix-ähnliche Ordner benutzen.\nIn diesen fall wird der Datenordner in $prefix/share/lite-xl sein und die Anwendung wird in $prefix/bin sein.\n$prefix wird bestimmt wenn die Anwendung in einem Ordner wie $prefix/bin gestartet wird.\nDer Benutzermodulordner hängt nicht von der portable Option ab und wird immer $HOME/.config/lite-xl sein.\nAuf Windows wird das Variable $USERPROFILE benutzt.\nLinux\nAuf Debianbasierten Systemen können die gebrauchten Bibliotheken und Meson mit den folgenden Befehlen installiert werden:\n# Um die gebrauchten Bibliotheken zu installieren:\nsudo apt install libfreetype6-dev libsdl2-dev\n# Um Meson zu installieren:\nsudo apt install meson\n# or pip3 install --user meson\nUm Lite XL mit Meson zu bauen werden die folgenden Befehle benutzt:\nmeson setup --buildtype=release --prefix <prefix> build\nmeson compile -C build\nDESTDIR=\"$(pwd)/lite-xl\" meson install --skip-subprojects -C build\nWo <prefix> ist, hängt von dein Betriebssystem ab:\n- Auf Linux ist es in /usr sein\n- Auf MacOS kann es in \"/Lite XL.app\" sein\nWenn du eine Version von Meson benutzt die unter 0.54 ist, musst du andere Befehle benutzen:\nmeson setup --buildtype=release build\nninja -C build\nninja -C build install\nMacOS\nMacOS ist voll unterstützt und eine notarierte App-Disk-Image ist auf der Veröffenlichungsseite bereitgestellt.\nDie Anwendung kann mit den Schritten oben kompiliert werden.\nWindows MSYS2\nDie Bauumgebung für Lite XL auf Windows ist MSYS2.\nFolge die Installationsschritte im Link.\nÖffne MinGW 64-bit oder MinGW 32-bit vom Startmenü\nAktualisiere die \"MSYS\" Installation mit pacman -Syu\nStarte Shell neu\nInstalliere die Abhängigkeiten:\npacman -S \\\n\\t${MINGW_PACKAGE_PREFIX}-freetype \\\n\\t${MINGW_PACKAGE_PREFIX}-gcc \\\n\\t${MINGW_PACKAGE_PREFIX}-ninja \\\n\\t${MINGW_PACKAGE_PREFIX}-pcre2 \\\n\\t${MINGW_PACKAGE_PREFIX}-pkg-config \\\n\\t${MINGW_PACKAGE_PREFIX}-python-pip \\\n\\t${MINGW_PACKAGE_PREFIX}-SDL2\npip3 install meson\n${MINGW_PACKAGE_PREFIX} ist entweder auf mingw-w64-i686 oder mingw-w64-x86_64\nabhängig ob deine Shell 32- oder 64bit ist."},{"id":"de/documentation/keymap.html","title":"Lite XL - Standard Keymap","category":["documentation"],"content":"Standard Keymap\nTastaturkürzeln haben die gleichen Funktionen auf jeden Betriebssystem, sie sind einfach nur anders gebunden\num sich für normale Erwartungen für dem Betriebssystem anzupassen.\nMomentan gibt es nur two Betriebssystemlayouts. MacOS, und alles andere.\nKeymap\nTasten Kombination\tAktionen\nalt+1\troot:switch-to-tab-1\nalt+2\troot:switch-to-tab-2\nalt+3\troot:switch-to-tab-3\nalt+4\troot:switch-to-tab-4\nalt+5\troot:switch-to-tab-5\nalt+6\troot:switch-to-tab-6\nalt+7\troot:switch-to-tab-7\nalt+8\troot:switch-to-tab-8\nalt+9\troot:switch-to-tab-9\nalt+i\troot:switch-to-up\nalt+j\troot:switch-to-left\nalt+k\troot:switch-to-down\nalt+l\troot:switch-to-right\nalt+return\tcore:toggle-fullscreen\nalt+shift+i\troot:split-up\nalt+shift+j\troot:split-left\nalt+shift+k\troot:split-down\nalt+shift+l\troot:split-right\nctrl+/\tdoc:toggle-line-comments\nctrl+1lclick\tdoc:split-cursor\nctrl+[\tdoc:move-to-previous-block-start\nctrl+]\tdoc:move-to-next-block-end\nctrl+a\tdoc:select-all\nctrl+backspace\tdoc:delete-to-previous-word-start\nctrl+c\tdoc:copy\nctrl+d\tdoc:select-word\nctrl+d\tfind-replace:select-add-next\nctrl+delete\tdoc:delete-to-next-word-end\nctrl+down\tdoc:move-lines-down\nctrl+end\tdoc:move-to-end-of-doc\nctrl+f3\tfind-replace:select-next\nctrl+f\tfind-replace:find\nctrl+g\tdoc:go-to-line\nctrl+home\tdoc:move-to-start-of-doc\nctrl+i\tfind-replace:toggle-sensitivity\nctrl+insert\tdoc:copy\nctrl+j\tdoc:join-lines\nctrl+l\tdoc:select-lines\nctrl+left\tdoc:move-to-previous-word-start\nctrl+n\tcore:new-doc\nctrl+o\tcore:open-file\nctrl+p\tcore:find-file\nctrl+pagedown\troot:move-tab-right\nctrl+pageup\troot:move-tab-left\nctrl+r\tfind-replace:replace\nctrl+return\tdoc:newline-below\nctrl+right\tdoc:move-to-next-word-end\nctrl+s\tdoc:save\nctrl+shift+[\tdoc:select-to-previous-block-start\nctrl+shift+]\tdoc:select-to-next-block-end\nctrl+shift+backspace\tdoc:delete-to-previous-word-start\nctrl+shift+c\tcore:change-project-folder\nctrl+shift+d\tdoc:duplicate-lines\nctrl+shift+delete\tdoc:delete-to-next-word-end\nctrl+shift+down\tdoc:create-cursor-next-line\nctrl+shift+end\tdoc:select-to-end-of-doc\nctrl+shift+f3\tfind-replace:select-previous\nctrl+shift+home\tdoc:select-to-start-of-doc\nctrl+shift+i\tfind-replace:toggle-regex\nctrl+shift+k\tdoc:delete-lines\nctrl+shift+l\tdoc:select-word\nctrl+shift+l\tfind-replace:select-add-all\nctrl+shift+left\tdoc:select-to-previous-word-start\nctrl+shift+o\tcore:open-project-folder\nctrl+shift+p\tcore:find-command\nctrl+shift+return\tdoc:newline-above\nctrl+shift+right\tdoc:select-to-next-word-end\nctrl+shift+s\tdoc:save-as\nctrl+shift+tab\troot:switch-to-previous-tab\nctrl+shift+up\tdoc:create-cursor-previous-line\nctrl+tab\troot:switch-to-next-tab\nctrl+up\tdoc:move-lines-up\nctrl+v\tdoc:paste\nctrl+w\troot:close\nctrl+x\tdoc:cut\nctrl+y\tdoc:redo\nctrl+z\tdoc:undo\nf11\tcore:toggle-fullscreen\nf3\tfind-replace:repeat-find\nshift+f3\tfind-replace:previous-find"},{"id":"de/documentation/index.html","title":"Lite XL - Documentation","category":["documentation"],"content":"Documentation\nDiese Seiten beinhalten Dokumention um Lite XL zu bauen und zu benutzen.\nBauen\nKeymap (MacOS)\nKeymap\nNutzen"},{"id":"de/tutorials/api-overview.html","title":"Lite XL - API Overview","category":["tutorials"],"content":"API Overview\nThis is a work in progress.\nHere we provide some resources and explanation to some API and aspects of Lite XL.\nFor API docs, it's available in the repo\nThus, we'll not explain everything, only the more important and frequently used features.\nBuilt-in APIs:\nProcess API\nSystem API\nRegex API"},{"id":"de/tutorials/system-fonts.html","title":"Lite XL - Systemschriftarten Benutzen","category":["tutorials"],"content":"Systemschriftarten Benutzen\nLite XL bietet keinen Weg um Schriftarten vom System zu benutzen.\nWeil jede Platform die wir unterstützen (Windows, Linux und Mac) es anders macht.\nHier kommt fontconfig zur Rettung. fontconfig kann man auf verschiedene Betriebssysteme installieren.\nlite-xl hat ein fontconfig Plugin dass wir benutzen können um Systemschriftarten zu finden.\nfontconfig Installieren\nWindows\nmingw-w64-fontconfig bietet einen Build, der direkt auf Windows benutzt werden kann.\nLade die Datei herunter, extrahiere es irgendwo und (optional) füge es zu den PATH hinzu.\nLinux\nÜberprüfe distro-spezifische Anweisungen.\n# ubuntu / debian\napt install fontconfig\n# arch\npacman -Su fontconfig\n# fedora\ndnf install fontconfig\n...\nMacOS\nbrew install fontconfig\nEinstellen\nInstalliere das Plugin\nGebe es in dein Benutzer Modul:\nlocal fontconfig = require \"plugins.fontconfig\"\nfontconfig.use {\n\\tfont = { name = \"sans\", size = 13 * SCALE },\n\\tcode_font = { name = \"monospace\", size = 13 * SCALE }\n}\n\"sans\" und \"monospace\" kann eine beliebige fontconfig Syntax sein. (sehe \"Font Names\")\nBeachte: Die Schriftart könnte nicht sofort laden (Weil wir auf fc-match warten müssen).\nWenn du es so haben willst, dann ersetze fontconfig.use mit fontconfig.use_blocking. Wenn du dass machst dann\nmuss lite-xl auf fc-match warten, was viel langsamer sein kann."},{"id":"de/tutorials/overview/system.html","title":"Lite XL - System API","category":["tutorials","overview"],"content":"System API\nThis is where Lite XL's lua code interact with its underlying C engine.\nSome of the functions here will be omitted because they're not useful for\nplugins.\nClipboard\nsystem.set_clipboard(text) sets the clipboard content.\nsystem.get_clipboard() retrieves the content of the clipboard.\nFile / Directory manipulation\nsystem.list_dir(dir) returns a list of filenames in a directory.\nsystem.rmdir(dir) removes a directory. Use this instead of os.remove().\nThe directory must be empty.\nsystem.chdir(dir) changes the current working directory (like cd).\nsystem.mkdir(dir) creates a new directory.\nIt does not recursively create directories.\nsystem.absolute_path(path) resolves the path components (.. and .) to an absolute path.\nsystem.get_file_info(path) returns info about a path.\nmodified: last modification time of the file in seconds since UNIX epoch.\nsize: file size in bytes.\ntype: Path type (\"file\" or \"dir\").\nTiming\nsystem.get_time() returns time in seconds (as floating point number) since Lite XL started.\nUse this instead of os.time() for higher precision timers.\nsystem.sleep(time) sleeps for time in milliseconds.\nDo not use this. Write asynchronous code.\nWindow manipulation\nsystem.set_window_opacity(o) sets the window opacity from 0 to 1.\nsystem.set_window_title(title) sets the window title.\nsystem.set_window_mode(mode) sets window mode:\n\"normal\": also known as \"restored\" on Windows.\n\"maximized\": Maximize the window.\n\"minimized\": Minimize the window.\n\"fullscreen\": Fullscreen\nsystem.set_window_bordered(bordered) enables or disable window border (decoration).\nsystem.set_window_hit_test(height, control_width, resize_border) sets window hit test (used for\nconfig.borderless to make custom drawn border interactable).\nIf no argument is supplied, reset the hit test values.\nheight: height of the title bar.\ncontrols_width: Not too sure about this, but it should be the size of the title bar controls\n(Maximize, Minimize and Normal buttons on the right).\nIt seems to be fixed at the right side of the title bar.\nresize_border: Number of pixels reserved for resizing the window.\n(setting this to a large value means that you can resize the window way easier)\nsystem.get_window_size() gets the window size.\nsystem.set_window_size(w, h, x, y) sets the window size (and also position).\nsystem.window_has_focus() checks whether the window is in focus.\nsystem.show_fatal_error(title, msg) shows an system error message box.\nUse nagview whenever possible.\nMisc\nsystem.exec(command) runs a command. Use the Process API instead of this.\nsystem.fuzzy_match(haystack, needle, file) generates a score depends on how close the needle\nmatches the haystack.\nfile: match backwards (more accurate for filename matching)."},{"id":"de/tutorials/overview/regex.html","title":"Lite XL - Regex API","category":["tutorials","overview"],"content":"Regex API\nThis API provides PCRE regular expressions for those who needs more power in matching text.\nThis API written in C and Lua.\nCreating a regex\nUse regex.compile(pattern, options) to compile a regex.\npattern: The regex pattern\noptions: regex modifiers as a string, eg \"im\"\n\"i\": Case-insensitive search\n\"m\": Multiline search\n\"s\": Match all characters with dot (.), including newlines.\nMatching\nLow level functions\nregex:cmatch(str, offset, options) low-level matching function\nstr: The string to match against\noffset: Where to start matching\noptions: A bit field of options\nregex.ANCHORED: Only match from the start of the string\nregex.ENDANCHORED: Only match from the end of the string\nregex.NOTBOL: String is not beginning of line\nregex.NOTEOL: String is not the end of line\nregex.NOTEMPTY: Do not match an empty string\nregex.NOTEMPTY_ATSTART: Do not match empty string at the start\nNote: regex:cmatch() returns wrong indexes (currently at version 2.0.2).\n\\tThe end index returned by regex:cmatch() is always off by 1 (-1 to get the actual end index).\nHigh level functions\nAll the functions below can be in 2 forms:\n- regex:fn(...) where regex is the compiled regex instance\n- regex.fn(pattern, ...) where pattern is a pattern string to be compiled and used directly.\nWe will only document the first form.\nregex:match(str, offset, options) high level matching function. This function accepts\nthe same arguments as regex:cmatch()\nregex:gsub(str, replacement) replaces matches in str with replacement.\nCapture groups are identified with \\\\0 to \\\\9, this might change in the future."},{"id":"de/tutorials/overview/process.html","title":"Lite XL - Process API","category":["tutorials","overview"],"content":"Process API\nLite XL provides a process API to launch external applications. This API is meant to replace\nlua's io.popen and lite's pipe-to-a-file approach.\nAdvantages of this API includes:\nProper argument escaping (arguments are supplied via a table)\nNonblocking IO\nAble to detach processes from Lite XL (in progress)\nDoes not create temporary files\nMostly cross-platform (does not require special code for each shell)\nUsing the Process API\nError handling\nprocess.start() may throw errors if it cannot run the program.\nprocess.read* and process.write functions may throw errors if\nthe process ended\nthe process closed the stream\nyou closed the stream\nthere might be other errors to look forward to too\nStarting a process\nTo start a process, use process.start(args, options).\nHere are some of the more useful arguments.\nargs: The executable and any arguments, eg: { \"sh\", \"-c\", \"echo hello world\" }\noptions: Options for process.start()\nenv: A key-value table containing the env. Note that if this is provided,\n\\tenvironment variables will not be inherited.\nstdin: Specify where to redirect stdin\nstdout: Specify where to redirect stdout\nstderr: Specify where to redirect stderr\nfor options.std{in,out,err}, valid values are:\nprocess.REDIRECT_PIPE (Make it available to subprocess API for reading / writing)\nprocess.REDIRECT_DISCARD (Discard the output. Use this to prevent buffering)\nprocess.REDIRECT_STDOUT (stderr only, for redirecting stderr to stdout)\nReading from process\nTo read from stdout or stderr of a process, use process:read_stdout() and\nprocess:read_stderr() respectively.\nYou can specify a numeric argument to them, which will change the size of internal buffer used\nto read the output.\nAlternatively, you could use process:read() with process.STREAM_STDERR and process.STREAM_STDOUT.\nExample:\nlocal proc = process.start { \"sh\", \"-c\", \"echo hello world!\" }\n-- do not use `while proc:running()` if you care about output.\n-- The process could die and leave data in the buffer\n-- You should just read until `proc:read_stdout()` returns nil\nwhile true do\n\\tlocal rdbuf = proc:read_stdout()\n\\tif not rdbuf then break end\n\\t-- yay, output\nend\nWriting to process\nYou can use process:write(data) to write a string to stdin.\nChecking completion\nprocess:running() returns a boolean to indicate whether if the process is running.\nprocess:wait(time) also does the same thing, but you specify how long it should wait (or 0 to return immediately).\nTerminating process\nprocess:terminate() sends SIGTERM (or Windows equivalent) to the process.\nprocess:kill() sends SIGKILL (or Windows equivalent) to the progress.\nUse this only if process:terminate() cannot kill the process, as it can cause issues.\nMisc\nprocess:pid() returns the PID of the process.\nThere are no guarantees for this PID to be correct if the process terminated early.\nprocess:returncode() returns the exit code of the process, if any\nprocess:close_stream() closes stdin, stdout or stderr stream of the process."},{"id":"de/tutorials/syntax-highlighting.html","title":"Lite XL - Syntaxhervorhebung","category":["tutorials"],"content":"<!-- Delete later: continue at line 161 -->\nSyntaxhervorhebung\nSo erstellt man Syntaxhervorhebung für Lite XL\nSyntaxhervorhebung Plugins für Lite XL sind Lua Dateien. Diese Dateien definieren Muster oder Regex\nverschiedene teile einer gegebenen Sprache, man ordnet Token-Typen zu Übereinstimmung zu.\nDiese verschiedenen Token-Typen werden dann verschiedene farben von deinem ausgesuchten Color Scheme gegeben.\nWie andere Plugins, Syntax Definitionen werden von den folgenden Ordnern empfangen, in der folgenden Reihenfolge:\n/usr/share/lite-xl/plugins/\n$HOME/.config/lite-xl/plugins/\nBEMERKE: Der genaue Ort von diesen Ordnern wird von dein Betriebssystem und Installationsmethode abhängen. Zum Beispiel, unter Windows wird das Variable $USERPROFILE benutzt werden anstatt $HOME.\nDer Benutzer Modul Ordner für Lite Xl kann in diesen Orten auf different Betriebssystemen gefunden werden:\nWindows: C:\\Users\\(nutzername)\\.config\\lite-xl\nMacOS: /Users/(nutzername)/.config/lite-xl\nLinux: /home/(nutzername)/.config/lite-xl\nAlso, um eine neue Syntax Definition auf Linux zu erstellen, musst du eine .lua Datei in dein $HOME/.config/lite-xl/plugins/ Ordner machen.\nWelche Syntax-Token arten sind unterstützt?\nDie unterstützten Syntax_Token art, definiert von lite-xl/core/style.lua, sind:\nnormal\nsymbol\ncomment\nkeyword\nkeyword2\nnumber\nliteral\nstring\noperator\nfunction\nIn dein Syntaxhervorhebung Plugin, schreibst du Muster um Teile der Sprachen-Syntax zu entsprechen, und um Token-Typen zu übereinstimmen. Du musst nicht alle benutzen - benutze so viele die du brauchst für deine Sprache.\nLet's walk through an example syntax definition and see how this works.\nGehen wir mal durch eine Beispiel Syntax Definition und wir werden sehen wie es funktioniert.\nBeispiel Syntax: ssh config Dateien\nDas ist ein kleines, simples Beispiel von einer Syntax Definition, Es soll eine SSH config Datei hervorheben und es sieht so aus:\n-- mod-version:2 -- lite-xl 2.0\nlocal syntax = require \"core.syntax\"\nsyntax.add {\n\\tfiles = { \"sshd?/?_?config$\" },\n\\tcomment = '#',\n\\tpatterns = {\n\\t{ pattern = \"#.*\\n\",\\ttype = \"comment\"\\t},\n\\t{ pattern = \"%d+\",\\ttype = \"number\"\\t},\n\\t{ pattern = \"[%a_][%w_]*\",\\ttype = \"symbol\"\\t},\n\\t{ pattern = \"@\",\\ttype = \"operator\" },\n\\t},\n\\tsymbols = {\n\\t-- ssh config\n\\t[\"Host\"]\\t= \"function\",\n\\t[\"ProxyCommand\"]\\t= \"function\",\n\\t[\"HostName\"]\\t= \"keyword\",\n\\t[\"IdentityFile\"]\\t= \"keyword\",\n\\t...\n\\t-- sshd config\n\\t[\"Subsystem\"]\\t= \"keyword2\",\n\\t-- Literals\n\\t[\"yes\"]\\t= \"literal\",\n\\t[\"no\"]\\t= \"literal\",\n\\t[\"any\"]\\t= \"literal\",\n\\t[\"ask\"]\\t= \"literal\",\n\\t},\n}\nSchauen wir uns mal jeden Teil an und schauen wie es funktioniert.\nHeader\nDie erste Zeile ist ein Lua kommentar und sagt Lite XL welche version dieses Plugin braucht. Die zweite Zeile importiert das core.syntax Modul\ndass wir nutzen können:\n-- mod-version:2 -- lite-xl 2.0\nlocal syntax = require \"core.syntax\"\nDann fügen wir eine Syntax Definition mit syntax.add {...} zu lite ein.\nFiles\nDie files Eigenschaft sagt Lite XL welche Dateien these Syntax benutzt werden soll. Das ist ein Lua Muster, das mit dem vollständigen Pfad der geöffneten Datei übereinstimmt. Zum Beispiel, um gegen Markdown Dateien zu übereinstimmen - mit entweder eine .md oder eine .markdown Erweiterung,\ndu könntest das machen:\nfiles = { \"%.md$\", \"%.markdown$\" },\nIn unseren original Beispiel, gleichen wir mit dem Ende des Pfads und nicht mit der Erweiterung ab, weil SSH config Dateien keine Erweiterung hat - und wir nicht alle config Dateien abgleichen. Wir erwarten den Pfad für SSH config Dateien so auszusehen:\n~/.ssh/config\n/etc/ssh/ssh_config\n/etc/ssh/sshd_config\nDieses Muster gleicht Pfade ab die so aussehen:\nfiles = { \"sshd?/?_?config$\" },\nKommentare\nDie Kommentar Eigenschaft definiert nicht welche Teile der Syntax Kommentare sind - Schaue auf Muster für das unten. Diese Eigenschaft sagt Lite XL welche Charaktere beim Anfang der ausgewählten Zeilen hinzufügt werden sollen, wenn du ctrl+/ drückst.\nDu kannst auch block_comment benutzen um Lite XL zu sagen, wie es multiline oder Block Kommentare machen soll.\nMuster\nEin gegebener Textabschnitt kann nur ein Muster abgleicht werden. Wenn Lite XL einmal einschieden hat, dass es mit einem Muster übereinstimmt, dann wird es den Token-Typen zuweisen und es wird weitergehen.\nMuster werden getestet in der Reihenfolge wie es in der Syntax Definition geschrieben wurde, also wird das erste Übereinstimmen gewinnen.\nJedes Muster nimmt einer dieser Formen an:\nEinfaches Muster\n{ pattern = \"#.*\\n\",\\ttype = \"comment\" },\nDiese Form gleicht die Zeile mit dem Muster ab und wenn es abstimmt, weist es in diesem Fall den passenden Text den gebenen Token type - comment zu.\nStart- & Endmuster\n{ pattern = { \"%[\", \"%]\" }, type = \"keyword\" },\nDiese Form hat zwei Muster - eines das mit dem Anfang des Bereichs übereinstimmt und eines dass mit dem Ende übereinstimmt. Alles zwischen den Anfang und den Ende wird den Token type zugewiesen.\nStart- & Endmuster, mit Ausgang\n{ pattern = { '\"', '\"', '\\\\' }, type = \"string\" },\nDieses ist das Gleiche wie die letzte Form, aber mit einem dritten Parameter.\nDer dritte Teil, der '\\\\' Teil in diesem Beispiel, spezifiziert den Charakter dass entkommen vom Schlussübereinstimmung ermöglicht.\nFür mehr Information von Lua Muster, sehe Lua Muster Referenz (English)\nWenn du PCRE Regular Expressions anstatt Lua Muster benutzen musst, kannst du das Stichwort regex anstelle von pattern benutzen.\nSymbole\nDieser Teil ist nicht mit dem symbol Token-Typ verwandt.\nDieser Symbol Teil erlaubt dir Token-Typen zu bestimmten Schlüsselwörtern zuzuordnen - normalerweise sind das Wörter in der Sprache dass du hervorhebst.\nDer Token-Typ in diesem Teil nimmt immer Vorrang über Token-Typen deklariert im Muster.\nZum Beispiel, Dieses Code markiert Host als function Token-Typ, HostName als keyword und yes, no, any & ask als literal:\n[\"Host\"]\\t= \"function\",\n[\"HostName\"]\\t= \"keyword\",\n[\"yes\"]\\t= \"literal\",\n[\"no\"]\\t= \"literal\",\n[\"any\"]\\t= \"literal\",\n[\"ask\"]\\t= \"literal\",\nTips: Überprüfe deine Muster!\nEs gibt häufige Fehler die gemacht werden können wenn man das symbols Table in Verbindung mit Muster benutzt.\nFall 1: Leerzeichen zwischen zwei symbols Token:\nNehmen wir mal ein Beispiel:\n{ pattern = \"[%a_][%w_]+%s+()[%a_][%w_]+\", type = { \"keyword2\", \"symbol\" } }\nJetzt erklären wir mal das Muster ein bisschen (Lasse die Leeren Klammer weg):\n[%a_] = alle Buchstaben und Unterstriche\n[%w_] = alle Buchstaben, Nummern und Unterstriche\n%s = alle Leerzeichen Charaktere\nWORD =\n\\t[%a_] gefolgt von (1 oder mehr [%w_])\npattern =\n\\tWORD, gefolgt von (einem oder mehreren %s), gefolgt von WORD\nNachher fügst du einen Eintrag [\"my\"] = \"literal\" im symbols Table.\nDu kannst die Syntax testen mit my function, und findest heraus das \"my\" nicht als literal markiert wurde. Warum ist das passiert?\nsymbols table braucht eine genaue Übereinstimmung.\nWenn du sorgfältig schaust, siehst du dass leere Klammern nach dem Leerzeichen platziert wurden!\nDass sagt Lite XL dass [%a_] gefolgt von (1 oder mehr [%w_]) ein Token ist, dass my übereinstimmen soll (bemerke das Leerzeichen in der Übereinstimmung).\nDas Lösung steckt darin, ein normal Token für Leerzeichen zwischen zwei Tokens hinzuzufügen:\n{ pattern = \"[%a_][%w_]+()%s+()[%a_][%w_]+\", type = { \"keyword2\", \"normal\", \"symbol\" } }\nFall 2: Muster & symbols Token\nMan könnte annehmen dass Lite XL magisch Text mit den symbols Table vergleicht. Dies ist nicht der Fall.\nIn manchen Sprachen fügen Leute generische Muster hinzu, um den Abgleich an die Tabelle symbols zu delegieren.\n{ pattern = \"[%a_][%w_]*\", \"symbol\" }\nJedoch könnte das symbols Table so ausschauen:\nsymbols = {\n\\t[\"my-symbol\"] = \"function\",\n\\t[\"..something_else\"] = \"literal\"\n}\nmy-symbol enthält ein Strich (-) und \"..something_else\" enthält zwei Punkte (.).\nKeinen von diesen Charakteren stimmt mit [%a_][%w_]* überein!\nVorsicht vor dem Text den du im symbols Table übereinstimmen willst.\nWenn du es benutzen willst, musst du dir sicher sein, dass es mit einer dieser Muster übereinstimmt.\nDie richtigen Muster sind:\n{ pattern = \"[%a_][%w%-_]*\", \"symbol\" },\n{ pattern = \"%.%.[%a_][%w_]*\", \"symbol\" },\nDeine neue Syntax testen\nUm deine neue Syntaxhervorhebung zu testen musst du diesen zwei Dinge machen:\nLade den Lite XL Core neu\nLade eine Datei deiner ausgewählten Sprache und schaue an wie es ausschaut\nUm den Core neuzuladen kannst du entweder Lite XL neustarten, oder du ladest den Core über das Befehlspalette neu.\nUm dies zu machen, drücke ctrl+shit+ Befehlspalette zu zeigen, dann wähle Core: Restart aus (oder schreibe crr oder ähnliches um es zu finden), dann drücke Enter. Du musst den Core immer neustarten wenn du änderungen zur Syntaxhervorhebung machst.\nBeispiel des fortschrittlichen Syntax: Markdown\nBemerke: Dieses Beispiel hat Funktionen von 2.1. Es ist nicht kompatible mit älteren Versionen von lite-xl\nNicht alle Sprachen sind so leicht wie SSH config Dateien. Markup Sprache wie HTML und Markdown sind sehr schwer richtig zu analysieren. Hier ist die Markdown Syntaxhervorhebung Datei in seiner vollen Pracht:\n-- mod-version:3\nlocal syntax = require \"core.syntax\"\nlocal style = require \"core.style\"\nlocal core = require \"core\"\nlocal initial_color = style.syntax[\"keyword2\"]\n-- Add 3 type of font styles for use on markdown files\nfor _, attr in pairs({\"bold\", \"italic\", \"bold_italic\"}) do\n\\tlocal attributes = {}\n\\tif attr ~= \"bold_italic\" then\n\\tattributes[attr] = true\n\\telse\n\\tattributes[\"bold\"] = true\n\\tattributes[\"italic\"] = true\n\\tend\n\\t-- no way to copy user custom font with additional attributes :(\n\\tstyle.syntax_fonts[\"markdown_\"..attr] = renderer.font.load(\n\\tDATADIR .. \"/fonts/JetBrainsMono-Regular.ttf\",\n\\tstyle.code_font:get_size(),\n\\tattributes\n\\t)\n\\t-- also add a color for it\n\\tstyle.syntax[\"markdown_\"..attr] = style.syntax[\"keyword2\"]\nend\nlocal in_squares_match = \"^%[%]\"\nlocal in_parenthesis_match = \"^%(%)\"\nsyntax.add {\n\\tname = \"Markdown\",\n\\tfiles = { \"%.md$\", \"%.markdown$\" },\n\\tblock_comment = { \"<!--\", \"-->\" },\n\\tspace_handling = false, -- turn off this feature to handle it our selfs\n\\tpatterns = {\n\\t---- Place patterns that require spaces at start to optimize matching speed\n\\t---- and apply the %s+ optimization immediately afterwards\n\\t-- bullets\n\\t{ pattern = \"^%s*%*%s\",\\ttype = \"number\" },\n\\t{ pattern = \"^%s*%-%s\",\\ttype = \"number\" },\n\\t{ pattern = \"^%s*%+%s\",\\ttype = \"number\" },\n\\t-- numbered bullet\n\\t{ pattern = \"^%s*[0-9]+[%.%)]%s\",\\ttype = \"number\" },\n\\t-- blockquote\n\\t{ pattern = \"^%s*>+%s\",\\ttype = \"string\" },\n\\t-- alternative bold italic formats\n\\t{ pattern = { \"%s___\", \"___%f[%s]\" },\\ttype = \"markdown_bold_italic\" },\n\\t{ pattern = { \"%s__\", \"__%f[%s]\" },\\ttype = \"markdown_bold\" },\n\\t{ pattern = { \"%s_[%S]\", \"_%f[%s]\" },\\ttype = \"markdown_italic\" },\n\\t-- reference links\n\\t{\n\\tpattern = \"^%s*%[%^()[\"..in_squares_match..\"]+()%]: \",\n\\ttype = { \"function\", \"number\", \"function\" }\n\\t},\n\\t{\n\\tpattern = \"^%s*%[%^?()[\"..in_squares_match..\"]+()%]:%s+.+\\n\",\n\\ttype = { \"function\", \"number\", \"function\" }\n\\t},\n\\t-- optimization\n\\t{ pattern = \"%s+\",\\ttype = \"normal\" },\n\\t---- HTML rules imported and adapted from language_html\n\\t---- to not conflict with markdown rules\n\\t-- Inline JS and CSS\n\\t{\n\\tpattern = {\n\\t\"<%s*[sS][cC][rR][iI][pP][tT]%s+[tT][yY][pP][eE]%s*=%s*\" ..\n\\t\"['\\\"]%a+/[jJ][aA][vV][aA][sS][cC][rR][iI][pP][tT]['\\\"]%s*>\",\n\\t\"<%s*/[sS][cC][rR][iI][pP][tT]>\"\n\\t},\n\\tsyntax = \".js\",\n\\ttype = \"function\"\n\\t},\n\\t{\n\\tpattern = {\n\\t\"<%s*[sS][cC][rR][iI][pP][tT]%s*>\",\n\\t\"<%s*/%s*[sS][cC][rR][iI][pP][tT]>\"\n\\t},\n\\tsyntax = \".js\",\n\\ttype = \"function\"\n\\t},\n\\t{\n\\tpattern = {\n\\t\"<%s*[sS][tT][yY][lL][eE][^>]*>\",\n\\t\"<%s*/%s*[sS][tT][yY][lL][eE]%s*>\"\n\\t},\n\\tsyntax = \".css\",\n\\ttype = \"function\"\n\\t},\n\\t-- Comments\n\\t{ pattern = { \"<!%-%-\", \"%-%->\" },\\ttype = \"comment\" },\n\\t-- Tags\n\\t{ pattern = \"%f[^<]![%a_][%w_]*\",\\ttype = \"keyword2\" },\n\\t{ pattern = \"%f[^<][%a_][%w_]*\",\\ttype = \"function\" },\n\\t{ pattern = \"%f[^<]/[%a_][%w_]*\",\\ttype = \"function\" },\n\\t-- Attributes\n\\t{\n\\tpattern = \"[a-z%-]+%s*()=%s*()\\\".-\\\"\",\n\\ttype = { \"keyword\", \"operator\", \"string\" }\n\\t},\n\\t{\n\\tpattern = \"[a-z%-]+%s*()=%s*()'.-'\",\n\\ttype = { \"keyword\", \"operator\", \"string\" }\n\\t},\n\\t{\n\\tpattern = \"[a-z%-]+%s*()=%s*()%-?%d[%d%.]*\",\n\\ttype = { \"keyword\", \"operator\", \"number\" }\n\\t},\n\\t-- Entities\n\\t{ pattern = \"&#?[a-zA-Z0-9]+;\",\\ttype = \"keyword2\" },\n\\t---- Markdown rules\n\\t-- math\n\\t{ pattern = { \"%$%$\", \"%$%$\", \"\\\\\"\\t},\\ttype = \"string\", syntax = \".tex\"},\n\\t{ pattern = { \"%$\", \"%$\", \"\\\\\" },\\ttype = \"string\", syntax = \".tex\"},\n\\t-- code blocks\n\\t{ pattern = { \"```c++\", \"```\" },\\ttype = \"string\", syntax = \".cpp\" },\n\\t-- ... there's some other patterns here, but I removed them for brevity\n\\t{ pattern = { \"```lobster\", \"```\" },\\ttype = \"string\", syntax = \".lobster\" },\n\\t{ pattern = { \"```\", \"```\" },\\ttype = \"string\" },\n\\t{ pattern = { \"``\", \"``\" },\\ttype = \"string\" },\n\\t{ pattern = { \"%f[\\\\`]%`[%S]\", \"`\" },\\ttype = \"string\" },\n\\t-- strike\n\\t{ pattern = { \"~~\", \"~~\" },\\ttype = \"keyword2\" },\n\\t-- highlight\n\\t{ pattern = { \"==\", \"==\" },\\ttype = \"literal\" },\n\\t-- lines\n\\t{ pattern = \"^%-%-%-+\\n\",\\ttype = \"comment\" },\n\\t{ pattern = \"^%*%*%*+\\n\",\\ttype = \"comment\" },\n\\t{ pattern = \"^___+\\n\",\\ttype = \"comment\" },\n\\t-- bold and italic\n\\t{ pattern = { \"%*%*%*%S\", \"%*%*%*\" },\\ttype = \"markdown_bold_italic\" },\n\\t{ pattern = { \"%*%*%S\", \"%*%*\" },\\ttype = \"markdown_bold\" },\n\\t-- handle edge case where asterisk can be at end of line and not close\n\\t{\n\\tpattern = { \"%f[\\\\%*]%*[%S]\", \"%*%f[^%*]\" },\n\\ttype = \"markdown_italic\"\n\\t},\n\\t-- alternative bold italic formats\n\\t{ pattern = \"^___[%s%p%w]+___%s\" ,\\ttype = \"markdown_bold_italic\" },\n\\t{ pattern = \"^__[%s%p%w]+__%s\" ,\\ttype = \"markdown_bold\" },\n\\t{ pattern = \"^_[%s%p%w]+_%s\" ,\\ttype = \"markdown_italic\" },\n\\t-- heading with custom id\n\\t{\n\\tpattern = \"^#+%s[%w%s%p]+(){()#[%w%-]+()}\",\n\\ttype = { \"keyword\", \"function\", \"string\", \"function\" }\n\\t},\n\\t-- headings\n\\t{ pattern = \"^#+%s.+\\n\",\\ttype = \"keyword\" },\n\\t-- superscript and subscript\n\\t{\n\\tpattern = \"%^()%d+()%^\",\n\\ttype = { \"function\", \"number\", \"function\" }\n\\t},\n\\t{\n\\tpattern = \"%~()%d+()%~\",\n\\ttype = { \"function\", \"number\", \"function\" }\n\\t},\n\\t-- definitions\n\\t{ pattern = \"^:%s.+\",\\ttype = \"function\" },\n\\t-- emoji\n\\t{ pattern = \":[a-zA-Z0-9_%-]+:\",\\ttype = \"literal\" },\n\\t-- images and link\n\\t{\n\\tpattern = \"!?%[!?%[()[\"..in_squares_match..\"]+()%]%(()[\"..in_parenthesis_match..\"]+()%)%]%(()[\"..in_parenthesis_match..\"]+()%)\",\n\\ttype = { \"function\", \"string\", \"function\", \"number\", \"function\", \"number\", \"function\" }\n\\t},\n\\t{\n\\tpattern = \"!?%[!?%[?()[\"..in_squares_match..\"]+()%]?%]%(()[\"..in_parenthesis_match..\"]+()%)\",\n\\ttype = { \"function\", \"string\", \"function\", \"number\", \"function\" }\n\\t},\n\\t-- reference links\n\\t{\n\\tpattern = \"%[()[\"..in_squares_match..\"]+()%] *()%[()[\"..in_squares_match..\"]+()%]\",\n\\ttype = { \"function\", \"string\", \"function\", \"function\", \"number\", \"function\" }\n\\t},\n\\t{\n\\tpattern = \"!?%[%^?()[\"..in_squares_match..\"]+()%]\",\n\\ttype = { \"function\", \"number\", \"function\" }\n\\t},\n\\t-- url's and email\n\\t{\n\\tpattern = \"<[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+%.[a-zA-Z0-9-.]+>\",\n\\ttype = \"function\"\n\\t},\n\\t{ pattern = \"<https?://%S+>\",\\ttype = \"function\" },\n\\t{ pattern = \"https?://%S+\",\\ttype = \"function\" },\n\\t-- optimize consecutive dashes used in tables\n\\t{ pattern = \"%-+\",\\ttype = \"normal\" },\n\\t},\n\\tsymbols = { },\n}\n-- Adjust the color on theme changes\ncore.add_thread(function()\n\\twhile true do\n\\tif initial_color ~= style.syntax[\"keyword2\"] then\n\\tfor _, attr in pairs({\"bold\", \"italic\", \"bold_italic\"}) do\n\\tstyle.syntax[\"markdown_\"..attr] = style.syntax[\"keyword2\"]\n\\tend\n\\tinitial_color = style.syntax[\"keyword2\"]\n\\tend\n\\tcoroutine.yield(1)\n\\tend\nend)\nSyntaxschriftarten (Seit 1.16.10)\nDie Syntax erlaubt Benutzer verschiedene Schriftarten Stile (Bold, Italic, usw.) für verschiedene Muster zu setzen.\nUm ein Schriftarten Stil von ein Token zu ändern, füge eine Schriftarten bei style.syntax_fonts[token_type] hinzu.\nZum Beispiel:\n-- Wird sorgen, dass jedes \"fancysyntax_fancy_token\" Italic sein wird.\nstyle.syntax_fonts[\"fancysyntax_fancy_token\"] = renderer.font.load(\"myfont.ttf\", 14 * SCALE, { italic = true })\nDas Markdown Beispiele automatisiert dies mit einem for loop.\nDie Limitationen hier sind dass Schriftarten nicht von anderen Attributen kopiert werden können, also müssen Schriftartenpfade fest codiert werden.\nDer Missbrauch von style.syntax_fonts kann zur langsame Leistung und einen hohen Speicherverbrauch führen.\nDies ist bemerkbar wenn ein Benutzer versucht die Größe des Editors mit ctrl-scroll or ctrl+ and ctrl- zu ändern.\nBitte benutze es in Moderation.\nLeerzeichen Umgang (v2.1 (Bevorstehend) / master)\nNormalerweise stellt Lite XL das Muster { pattern = \"%s+\", type = \"normal\" } zu der Syntaxhervorhebung.\nDies verbessert die Leistung drastisch bei Zeilen die mit Leerzeichen (z.B schwer-eingerücke Zeilen)\nDurchs anpassen des Leerzeichens bevor andere Muster muss Lite XL nicht durch die ganze Syntax durchgehen.\nJedoch gibt es Syntaxen die Leerzeichen anpassen müssen (z.B Markdown mit einrückten Codeblocken)\nAlso kann dies deaktiviert werden indem man space_handling to false. stellt.\nUm die Leerzeichen Umgang Optimisierung zu behalten, oder um ältere Versionen von Lite XL zu unterstützen kann\n{ pattern = \"%s+\", type = \"normal\" } nach Muster, die Leerzeichen brauchen hinzugefügt werden.\nEinfache Muster mit mehrere Tokens (1.16.10)\nDies ist ein Ausschnitt dass von der Markdown Syntaxhervorhebung genommen wurde:\nlocal in_squares_match = \"^%[%]\"\n-- reference links\n{\n\\tpattern = \"^%s*%[%^()[\"..in_squares_match..\"]+()%]: \",\n\\ttype = { \"function\", \"number\", \"function\" }\n},\nManchmal macht es Sinn verschiedene Teile eines Musters anderst zu hervorheben.\nLeere Klammer (()) in Lua Muster werden die Position vom Text in den Klammern zurückgeben.\nDies wird Lite XL sagen, wenn es den Typ des Tokens ändern muss.\nZum Beispiel, ^%s*%[%^ ist \"function\", [\"..in_squares_match..\"]+ ist \"number\" und %]: ist \"function\".\nSubsyntaxen (Seit 1.16.10)\nLite XL unterschützt Einbettung von anderen Syntaxen in einer existierenden Syntax.\nDies kann benutzt werden, um Codeblöcke im Markdown Syntax zu Unterstützen.\nZum Beispiel:\nlua\n{ pattern = { \"cpp\", \"\" },\\ttype = \"string\", syntax = \".cpp\" },\nDies würde `` cpp `` und `` `mit\"string\"markieren während alles innerhalb mit der Syntax dass mit\".cpp\"` übereinstimmt markiert wird."},{"id":"de/tutorials/simple-plugin.html","title":"Lite XL - Einfache Plugins","category":["tutorials"],"content":"Einfache Plugins\nWas ist Simple?\nSimple ist ein einfaches Plugin dass geschrieben wurde mit der Absicht Entwickler\ndie neu bei Lite XL sind, den Prozess des Schreibens von Plugins für den Editor zu zeigen.\nWas macht das Plugin?\nDas Plugin zeigt eine Nachricht (Das als Eingabe Des Benutzers übernommen wird) \nam oberen rechten Eck des Editorfensters. Es erlaubt auch den Benutzer das Umschalten der Sichtbarkeit \nder Nachricht.\nIch kann nicht Lua schreiben!\nWenn du von anderen Programmierungsprachen kommst, dann schau dir das Lua cheatsheet an.\nWenn du neu bei programmieren bist, dann schau dir das (English) an.\nDas Format vom Tutorial\nDas Code enthält Kommentare die detailieren was das Meiste (wenn nicht alles) \nim Code macht.\nDie Kommentare sind gerade in Englisch, aber ich glaub das wirst du schon verstehen :)\nDas Code:\n-- mod-version:3\n-- you MUST put mod-version:x on the first line of your plugin\n-- mod-version usually maps to lite-xl releases (eg. mod-version: 2 == lite-xl 2.0)\n-- lite-xl won't load the plugin if the mod-version mismatches\n-----------------------------------------------------------------------\n-- NAME\\t: Simple\n-- DESCRIPTION: A simple guide on how to make your first Lite XL plugin\n-- AUTHOR\\t: Ashwin Godbole (aelobdog)\n-- GOALS\\t: To render some text inside the editor\n-----------------------------------------------------------------------\n-- Disclaimer :\n-- I am not a lua developer, and my knowledge about writing plugins for\n-- Lite XL is very limited. This file serves the purpose of helping the\n-- reader get started with plugin development for Lite XL, and therefore\n-- demonstrates only some very basic features. For more complex plugin\n-- development, be sure to check out the source code of some other\n-- plugins after going through this file.\n-----------------------------------------------------------------------\n-- Before we start writing any code for the plugin, we must import the\n-- required modules from the \"core\" package.\n-- the \"core\" module\nlocal core = require \"core\"\n-- the \"command\" module will help us register commands for our plugin.\nlocal command = require \"core.command\"\n-- the \"style\" module will allow us to use styling options\nlocal style = require \"core.style\"\n-- the \"config\" module will be used to store certain things like colors\n-- and functions\nlocal config = require \"core.config\"\n-- the \"keymap\" module will allow us to set keybindings for our commands\nlocal keymap = require \"core.keymap\"\n-- since we want to modify RootView, we'll need to require it first\nlocal RootView = require \"core.rootview\"\n-----------------------------------------------------------------------\n-- per-plugin config must stay in config.plugins.(plugin name)\nconfig.plugins.simple = {}\n-- colors are just three or four comma separated values (RGBA) (range 0 - 255)\n-- put inside of '{ }'. We will add our color to the config module.\nconfig.plugins.simple.text_color = {200, 140, 220} -- or use `{ common.color \"#C88CDC\" }`\n-----------------------------------------------------------------------\n-- Let's create a function to calculate the coordinates of our text.\n-- While we're at it, let's add our function to the `config` module.\n-- We'll take the message we want to display as the argument to the\n-- function to determine the x and y coordinates of the text.\nfunction config.plugins.simple.get_text_coordinates(message)\n\\t-- For this plugin, we want to display the text on the top right\n\\t-- corner of the screen. For this, we need to know the editor's width\n\\t-- and height.\n\\t-- The current font's size can be obtained from the \"style\" module.\n\\t-- The editor's dimensions can be obtained by\n\\t--\\t1. WIDTH\\t: core.root_view.size.x\n\\t--\\t2. HEIGHT : core.root_view.size.y\n\\tlocal message_width = style.code_font:get_width(message..\" \")\n\\tlocal font_height = style.code_font:get_size()\n\\tlocal x = core.root_view.size.x - message_width\n\\tlocal y = font_height / 2\n\\treturn x, y\nend\n-----------------------------------------------------------------------\n-- Let's now get to actually drawing the text inside the editor.\n-- In order to \"inject\" our own code to draw text,\n-- we'll need to save the original draw function\n-- We'll save `RootView.draw` to a variable we call `parent_draw`\nlocal parent_draw = RootView.draw\n-- Now let's overload the original definition of `draw` in RootView\n-- by redefining the function.\nfunction RootView:draw()\n\\t-- We call the parent's function to keep the editor functional...\n\\t-- obviously we must still draw all the other stuff !\n\\t-- So we call the `parent_draw` function before doing anything else.\n\\tparent_draw(self)\n\\t-- we'll add an option to toggle the message on and off. let's use a\n\\t-- boolean variable to keep track of whether we want to display the\n\\t-- message or not.\n\\tif config.plugins.simple.show_my_message then\n\\t-- We'll be getting the message to display as input from the user\n\\t-- later. We'll store that user input in `config.plugins.simple.hw_message`.\n\\t-- (NOTE: this variable does not come in-built in lite-xl;\n\\t--\\tit is a variable that we will define later.)\n\\t-- let's store the value of config.plugins.simple.hw_message in a local variable\n\\t-- `message` in case config.plugins.simple.hw_message we set the message to\n\\t-- \"message not set yet!\"\n\\tlocal message\n\\tif config.plugins.simple.hw_message then\n\\tmessage = config.plugins.simple.hw_message\n\\telse\n\\tmessage = \"Message not set yet !\"\n\\tend\n\\t-- let's get the coordinates for our text\n\\tlocal x, y = config.plugins.simple.get_text_coordinates(message)\n\\t-- let's finally draw the text to the window !\n\\t-- the draw_text function from `renderer` is an important function\n\\t-- as it is used to display any and all text inside of the editor\n\\t-- window\n\\trenderer.draw_text(style.code_font, message, x, y, config.plugins.simple.text_color)\n\\tend\nend\n-----------------------------------------------------------------------\n-- Let's allow the user to turn the message on and off\n-- we'll write a function to flip our \"show\" boolean variable.\nlocal function toggle_helloworld()\n\\tconfig.plugins.simple.show_my_message = not config.plugins.simple.show_my_message\nend\n-----------------------------------------------------------------------\n-- Finally, let's add the toggle function to the command list so that\n-- we can call it from the C-S-p command panel. Let's add one command\n-- to toggle the visibility of the message on and off and one to get\n-- the user's message and then display it.\ncommand.add(nil, {\n\\t-- Toggle the visibility of the message\n\\t[\"simple:toggle\"] = toggle_helloworld,\n\\t-- Set and show the message\n\\t-- This is the way to get user input through the command bar.\n\\t-- `core.command_view:enter` takes 2 arguments:\n\\t--\\t* the prompt to display before taking input\n\\t--\\t* a function that takes the \"input\" as its argument\n\\t-- (NOTE: here the variable we are reading input into is `text`)\n\\t[\"simple:setshow\"] = function()\n\\tcore.command_view:enter(\"Test to display\", {\n\\tsubmit = function(text)\n\\tconfig.plugins.simple.hw_message = text\n\\tconfig.plugins.simple.show_my_message = true\n\\tend\n\\t})\n\\tend\n})\n-----------------------------------------------------------------------\n-- Just for fun, let's assign our commands their own keybindings.\n-- Here, we assign the keybinding the same string(its name) as the one\n-- that we set while creating the command\nkeymap.add {\n\\t[\"alt+s\"] = \"simple:setshow\",\n\\t[\"alt+t\"] = \"simple:toggle\",\n}\nZusätzliches\nLite: Eine Implementation Übersicht (English), ein exzellentes Post von rxi dass meistens zu lite-xl relevant bleibt.\nAPI Übersicht (English), wo mache APIs erklärt werden."},{"id":"de/tutorials/index.html","title":"Lite XL - Tutorials","category":["tutorials"],"content":"Tutorials\nDiese Seiten enthalten Tutorials und Dokumentationen zum Erstellen von Plugins in Lite XL.\nAPI Overview\nEinfaches Plugin\nSyntaxhervorhebung\nSystem Schriftarten"},{"id":"de/about/contributors.html","title":"Lite XL - Mitwirkende","category":["about"],"content":"Mitwirkende\nName\tBeiträge\nrxi\tUrsprüngliche Entwicklung des Lite Editors.\nFrancesco\tAutor des lite-xl Forks von rxi/lite.\nTakase\tNagView und X Window Datenbank Ressourcen für Xft.dpi Einstellung.\nNils Kvist\tPopup Fenster Ersatz mit CommandView Dialog.\nliquidev\tTab Stil und Animationen Verbesserungen.\nAdam\tMehrsprachige Syntaxhervorhebung und viele andere Verbesserungen.\nCukmekerb\tSyntaxhervorhebung Verbesserungen.\nJanis-Leuenberger\tHilfedatei für Tastaturbelegungen und MacOS Testungen.\nMat Mariani\tHilfe mit MacOS Port. Paar Ressourcen von mathewmariani/lite-macos.\ndaubaris\tAnfängliche Implementation von Xft.dpi Query mit xrdb Befehl.\nRobert Štojs\tContinuous Integration Konfiguration."},{"id":"de/about/faq.html","title":"Lite XL - FAQ","category":["about"],"content":"FAQ\nKann ich smart autocompletion (intellisense/LSP) bekommen?\nSchaue dir das LSP Plugin an.\nWo ist das integrierte Terminal?\nDu kannst lite-xl-terminal ausprobieren.\nTabs und Indent Größe?\nIn deiner Benutzer Config (Das Zahnrad Symbol im File Tree):\nconfig.tab_type = \"soft\" -- soft für Leerzeichen, hard für echte Tabs (\\t)\nconfig.indent_size = 4\\t-- 4 Leerzeichen\nWie binde ich Befehle an Tasten?\nlocal keymap = require \"core.keymap\"\nkeymap.add { [\"ctrl+escape\"] = \"core:quit\" }\nWie entbinde ich Befehle für bestimmte Tasten?\n-- Das zweite Parameter lässt dir Befehle für bestimmte Tasten überschreiben\n-- in diesem Fall wird es auf nichts gebunden\nkeymap.add({ [\"ctrl+escape\"] = {} }, true)\nWie bekomme ich die Befehle für diese Tastenkombinationen?\nDu kannst für Befehle im Command Palette suchen.\nFür jedem Befehl, ersetze die Leerzeichen auf der rechten Seite mit Striche.\nZum Beispiel: Core: Find Command → core:find-command\nWelche Lua Version wird von Lite XL benutzt?\nLua 5.4.\nVim modus?\nDafür brauchst du vibe.\nPlugin Empfehlungen\nIm fall dass du nicht unser Plugin Repository durchforsten möchtest,\nhaben wir eine Liste von Plugins gemacht, die Lite XL viel mehr angenehmer machen.\nPlugin\tVerwendungszweck\nautoinsert\tFügt automatisch schließende Klammern und Anführungszeichen ein\nbracketmatch\tMarkiert übereinstimmende Klammern\nephemeral_tabs\tVorschau von Dateien ohne der Erstellung von mehrere Tabs (Ephemeral Tabs)\ngitdiff_highlight\tGit diff gutter\nlint+\tLinter Unterschützung\nminimap\tMinimap\nselectionhighlight\tHebe Code hervor dass zur Auswahl passt\nlite-xl-discord\tDiscord rich presence\nWo ist Funktion X? Wie wäre es mit Y?\nDu kannst mehr Informationen auf unserer Funktionen Seite bekommen."},{"id":"de/about/features.html","title":"Lite XL - Funktionen","category":["about"],"content":"Funktionen\nMomentan bietet Lite XL viele eingebaute Funktionen.\nCross-Platform\nMomentan unterstützen wir Windows, Linux und MacOS (Mit Unterschützung vom Retina-Display).\nLeicht\nWir sind momentan bei ungefähr 3MB in Größe und es braucht ungefähr 10MB in RAM (kann niedriger sein). Kein Electron / WebView ist involviert. Der ganze Editor läuft in Lua auf einer Rendering Engine.\nErweiterbar\nDer Editor is normalerweise minimal, es ist sehr erweiterbar mit Lua. Viele Funktionen werden von Plugins bereitgestellt. Zum Beispiel, VSCode-ähnliche Intellisense.\nBetteres Schriftartenwiedergabe\nDer Editor sieht auf jeder Bildschirmgröße gut aus. Paar andere Optionen sind auch konfigurierbar, wie zum Beispiel Hinting und Antialiasing.\nMulti-cursor Bearbeitung\nDu kannst mehrere Cursor platzieren indem du ctrl + lclick oder ctrl + shift + up oder ctrl + shift + down drückst.\nHier sind ein paar Funktionen dass nicht aus entsprechenden Gründen implementiert wurden.\nEinige davon können durch Plugins implementiert werden.\nWir ermutigen dir es einen Versuch zu geben.\nHardwarebeschleunigtes Rendering\n** tl;dr Franko (Entwickler) gab an dass er nicht OpenGL benutzen wird wegen seiner Fähigkeiten und der verbundenen Arbeit.**\nHardwarebeschleunigen wurde in dieser Diskussion besprochen.\nTakase (Entwickler) versuchte es zwei mal - zuerst mit NanoVG und dann durchs erzwingen von SDL GPU Rendering zu benutzen.\nIn beiden Versuchen war die Leistungsersteigerungen nicht bedeutend, im schlimmsten Fall war es komplet unverwendbar.\nGerade haben wir uns entschieden dass wir uns auf die Optimierung des Software-Renderers und mehrere Teile des Lua Codes konzentieren.\nSystemschriftarten\nDies ist schmerzhaft weil verschiedene Systeme ihren eigenen Mechanismus haben, wie sie Schriftarten verwalten.\nZur Zeit können Nutzer das Fontconfig Plugin benutzen.\nFontconfig ist auf Linux, Windows und MacOS weit verbreitet.\nIn der Zukunft werden wir vielleicht eine API hinzufügen um Font Metadaten zu lesen, dass uns erlaubt eine Fontconfig Alternative in Lua zu schreiben (Kein Versprechen).\nDas Öffnen von UNC Pfaden auf Windows (Netzwerklaufwerke, Zugriff auf Windows WSL2 Dateien)\nUnser Pfadumgangs Code kann nur mit POSIX- und Windowspfade umgehen.\nWir sind also nicht sicher wie sich Lite XL in diesen Szenarien verhält.\nKommunikation Zwischen Fenstern (Tabs zwischen Fenstern ziehen und andere Magie)\nDies ist bei weitem am schwierigsten zu erreichen.\nLite XL hat keine Absicht auf irgendwelche Widget-Toolkits (Qt und GTK) zu verlinken, die für diese Funktionen gebraucht werden.\nEine Alterative wäre, unser Eigenes IPC Mechanismus zu erstellen, aber dass wäre das Rad neu erfinden.\nIntegriertes Terminal\nEin Terminal kann sehr schwer zum implementieren sein.\nEs gibt Projekte dass man zu Lua porten kann, wie zum Beispiel xterm.js.\nWenn jemand interessiert ist, könnte es jemand machen."},{"id":"de/about/index.html","title":"Lite XL - About","category":["about"],"content":"About\nDiese Seiten beinhalten Informationen über Lite XLs Funktionen, Screenshots und Entwicklern. Es beinhaltet auch einen FAQ Abschnitt.\nMitwirkende\nFAQ\nFunktionen\nScreenshots"},{"id":"de/about/screenshots.html","title":"Lite XL - Screenshots","category":["about"],"content":"Screenshots\nScreenshot 1 /assets/img/editor.png\nScreenshot 2 /assets/img/editor2.png"},{"id":"de/404.html","title":"Lite XL - Nicht Gefunden","category":[],"content":"Nicht Gefunden\nDiese Seite konnte nicht gefunden werden. Bitte beachte dass diese Webseite gerade getestet wird, also werden Seiten entweder bewegt oder gelöscht."},{"id":"de/index.html","title":"Lite XL","category":[],"content":"Lite XL\nEin leichter, simpler, schneller, funktionsreicher, und extrem erweiterbarerer Texteditor geschrieben in C, und Lua, angepasst von lite.\nLite XL Editor /assets/img/editor.png"}]
[{"id":"de/404.html","title":"Lite XL - Nicht Gefunden","category":[],"content":"Nicht GefundenDiese Seite konnte nicht gefunden werden. Bitte beachte dass diese Webseite gerade getestet wird, also werden Seiten entweder bewegt oder gelöscht."},{"id":"de/about/contributors.html","title":"Lite XL - Mitwirkende","category":["about"],"content":"Mitwirkende"},{"id":"de/about/faq.html","title":"Lite XL - FAQ","category":["about"],"content":"FAQKann ich smart autocompletion (intellisense/LSP) bekommen?Schaue dir das LSP Plugin an.Wo ist das integrierte Terminal?Du kannst lite-xl-terminal ausprobieren.Tabs und Indent Größe?In deiner Benutzer Config (Das Zahnrad Symbol im File Tree):config.tab_type = \"soft\" -- soft für Leerzeichen, hard für echte Tabs (\\t)\nconfig.indent_size = 4\\t-- 4 Leerzeichen\nWie binde ich Befehle an Tasten?local keymap = require \"core.keymap\"\nkeymap.add { [\"ctrl+escape\"] = \"core:quit\" }\nWie entbinde ich Befehle für bestimmte Tasten?-- Das zweite Parameter lässt dir Befehle für bestimmte Tasten überschreiben\n-- in diesem Fall wird es auf nichts gebunden\nkeymap.add({ [\"ctrl+escape\"] = {} }, true)\nWie bekomme ich die Befehle für diese Tastenkombinationen?Du kannst für Befehle im Command Palette suchen.Für jedem Befehl, ersetze die Leerzeichen auf der rechten Seite mit Striche.Zum Beispiel: Core: Find Command → core:find-commandWelche Lua Version wird von Lite XL benutzt?Lua 5.4.Vim modus?Dafür brauchst du vibe.Plugin EmpfehlungenIm fall dass du nicht unser Plugin Repository durchforsten möchtest,\nhaben wir eine Liste von Plugins gemacht, die Lite XL viel mehr angenehmer machen.Wo ist Funktion X? Wie wäre es mit Y?Du kannst mehr Informationen auf unserer Funktionen Seite bekommen."},{"id":"de/about/features.html","title":"Lite XL - Funktionen","category":["about"],"content":"FunktionenMomentan bietet Lite XL viele eingebaute Funktionen.Cross-PlatformMomentan unterstützen wir Windows, Linux und MacOS (Mit Unterschützung vom Retina-Display).LeichtWir sind momentan bei ungefähr 3MB in Größe und es braucht ungefähr 10MB in RAM (kann niedriger sein). Kein Electron / WebView ist involviert. Der ganze Editor läuft in Lua auf einer Rendering Engine.ErweiterbarDer Editor is normalerweise minimal, es ist sehr erweiterbar mit Lua. Viele Funktionen werden von Plugins bereitgestellt. Zum Beispiel, VSCode-ähnliche Intellisense.Betteres SchriftartenwiedergabeDer Editor sieht auf jeder Bildschirmgröße gut aus. Paar andere Optionen sind auch konfigurierbar, wie zum Beispiel Hinting und Antialiasing.Multi-cursor BearbeitungDu kannst mehrere Cursor platzieren indem du ctrl + lclick oder ctrl + shift + up oder ctrl + shift + down drückst.Hier sind ein paar Funktionen dass nicht aus entsprechenden Gründen implementiert wurden.\nEinige davon können durch Plugins implementiert werden.\nWir ermutigen dir es einen Versuch zu geben.Hardwarebeschleunigtes Rendering** tl;dr Franko (Entwickler) gab an dass er nicht OpenGL benutzen wird wegen seiner Fähigkeiten und der verbundenen Arbeit.**Hardwarebeschleunigen wurde in dieser Diskussion besprochen.\nTakase (Entwickler) versuchte es zwei mal - zuerst mit NanoVG und dann durchs erzwingen von SDL GPU Rendering zu benutzen.\nIn beiden Versuchen war die Leistungsersteigerungen nicht bedeutend, im schlimmsten Fall war es komplet unverwendbar.\nGerade haben wir uns entschieden dass wir uns auf die Optimierung des Software-Renderers und mehrere Teile des Lua Codes konzentieren.SystemschriftartenDies ist schmerzhaft weil verschiedene Systeme ihren eigenen Mechanismus haben, wie sie Schriftarten verwalten.\nZur Zeit können Nutzer das Fontconfig Plugin benutzen.\nFontconfig ist auf Linux, Windows und MacOS weit verbreitet.\nIn der Zukunft werden wir vielleicht eine API hinzufügen um Font Metadaten zu lesen, dass uns erlaubt eine Fontconfig Alternative in Lua zu schreiben (Kein Versprechen).Das Öffnen von UNC Pfaden auf Windows (Netzwerklaufwerke, Zugriff auf Windows WSL2 Dateien)Unser Pfadumgangs Code kann nur mit POSIX- und Windowspfade umgehen.\nWir sind also nicht sicher wie sich Lite XL in diesen Szenarien verhält.Kommunikation Zwischen Fenstern (Tabs zwischen Fenstern ziehen und andere Magie)Dies ist bei weitem am schwierigsten zu erreichen.\nLite XL hat keine Absicht auf irgendwelche Widget-Toolkits (Qt und GTK) zu verlinken, die für diese Funktionen gebraucht werden.\nEine Alterative wäre, unser Eigenes IPC Mechanismus zu erstellen, aber dass wäre das Rad neu erfinden.Integriertes TerminalEin Terminal kann sehr schwer zum implementieren sein.\nEs gibt Projekte dass man zu Lua porten kann, wie zum Beispiel xterm.js.\nWenn jemand interessiert ist, könnte es jemand machen."},{"id":"de/about/index.html","title":"Lite XL - About","category":["about"],"content":"AboutDiese Seiten beinhalten Informationen über Lite XLs Funktionen, Screenshots und Entwicklern. Es beinhaltet auch einen FAQ Abschnitt.Mitwirkende\nFAQ\nFunktionen\nScreenshots"},{"id":"de/about/screenshots.html","title":"Lite XL - Screenshots","category":["about"],"content":"Screenshots![Screenshot 1](/assets/img/editor.png)\n![Screenshot 2](/assets/img/editor2.png)"},{"id":"de/documentation/build.html","title":"Lite XL - Bauen","category":["documentation"],"content":"BauenWenn du dann den Quellcode hast, kannst du Lite XL mit Meson für dich selber bauen.\nZusätzlich gibt es das build-packages.sh Script dass benutzt werden kann, um Lite XL zu kompilieren und\nein Betriebsystemspezifisches Packet für Linux, Windows oder MacOS zu erstellen.Die folgenen Bibliotheken werden gebraucht:freetype2\nSDL2\nDie folgenden Bibliotheken sind optional:libagg\nLua 5.2\nWenn sie nicht gefunden werden können, werden sie von Meson heruntergeladen und kompiliert.\nSonst wenn sie present sind, werden sie benutzt um Lite XL zu bauen.Bau ScriptWenn du Lite XL selber kompilieren willst, \nist es empfohlen, den build-packages.sh Script zu benutzen:bash build-packages.sh -h\nDer Script wird Meson ausführen und erstellt ein tar komprimiertes Archiv mit der Anwendung, oder\nfür Windows, eine zip Datei. Lite XL kann leicht installiert werden, indem man das Archiv auspackt.Unter Windows werden zwei Packete erstellt, eines heißt \"portable\" dass den Datenordner neben der Ausführbarendatei haben wird.\nDas andere Packet benutzt ein unix-ähnlichen Layout, es ist gemeint für die Leute, die ein unix-ähnliches Shell und Befehlszeile benutzen.Bitte bemerke dass es keine fest codierte Ordner in der Ausführenbarendatei gibt, also können Packete in allen Ordnern benutzt werden.PortableWenn man meson setup ausführt, gibt es eine Option -Dportable=true die sagt, ob Dateien als tragbare Anwendung installiert werden soll.Wenn portable berechtigt wurde, wird Lite XL den Datenordner neben der Anwendung platzieren.\nSonst wird Lite XL Unix-ähnliche Ordner benutzen.\nIn diesen fall wird der Datenordner in $prefix/share/lite-xl sein und die Anwendung wird in $prefix/bin sein.\n$prefix wird bestimmt wenn die Anwendung in einem Ordner wie $prefix/bin gestartet wird.Der Benutzermodulordner hängt nicht von der portable Option ab und wird immer $HOME/.config/lite-xl sein.\nAuf Windows wird das Variable $USERPROFILE benutzt.LinuxAuf Debianbasierten Systemen können die gebrauchten Bibliotheken und Meson mit den folgenden Befehlen installiert werden:# Um die gebrauchten Bibliotheken zu installieren:\nsudo apt install libfreetype6-dev libsdl2-dev\n# Um Meson zu installieren:\nsudo apt install meson\n# or pip3 install --user meson\nUm Lite XL mit Meson zu bauen werden die folgenden Befehle benutzt:meson setup --buildtype=release --prefix <prefix> build\nmeson compile -C build\nDESTDIR=\"$(pwd)/lite-xl\" meson install --skip-subprojects -C build\nWo <prefix> ist, hängt von dein Betriebssystem ab:\n- Auf Linux ist es in /usr sein\n- Auf MacOS kann es in \"/Lite XL.app\" seinWenn du eine Version von Meson benutzt die unter 0.54 ist, musst du andere Befehle benutzen:meson setup --buildtype=release build\nninja -C build\nninja -C build install\nMacOSMacOS ist voll unterstützt und eine notarierte App-Disk-Image ist auf der Veröffenlichungsseite bereitgestellt.\nDie Anwendung kann mit den Schritten oben kompiliert werden.Windows MSYS2Die Bauumgebung für Lite XL auf Windows ist MSYS2.\nFolge die Installationsschritte im Link.Öffne MinGW 64-bit oder MinGW 32-bit vom Startmenü\nAktualisiere die \"MSYS\" Installation mit pacman -Syu\nStarte Shell neu\nInstalliere die Abhängigkeiten:\npacman -S \\\n\\t${MINGW_PACKAGE_PREFIX}-freetype \\\n\\t${MINGW_PACKAGE_PREFIX}-gcc \\\n\\t${MINGW_PACKAGE_PREFIX}-ninja \\\n\\t${MINGW_PACKAGE_PREFIX}-pcre2 \\\n\\t${MINGW_PACKAGE_PREFIX}-pkg-config \\\n\\t${MINGW_PACKAGE_PREFIX}-python-pip \\\n\\t${MINGW_PACKAGE_PREFIX}-SDL2\npip3 install meson\n${MINGW_PACKAGE_PREFIX} ist entweder auf mingw-w64-i686 oder mingw-w64-x86_64\nabhängig ob deine Shell 32- oder 64bit ist."},{"id":"de/documentation/index.html","title":"Lite XL - Documentation","category":["documentation"],"content":"DocumentationDiese Seiten beinhalten Dokumention um Lite XL zu bauen und zu benutzen.Bauen\nKeymap (MacOS)\nKeymap\nNutzen"},{"id":"de/documentation/keymap-macos.html","title":"Lite XL - MacOS Keymap","category":["documentation"],"content":"MacOS KeymapTastaturkürzeln haben die gleichen Funktionen auf jeden Betriebssystem, sie sind einfach nur anders gebunden\num sich für normale Erwartungen für dem Betriebssystem anzupassen.Momentan gibt es nur two Betriebssystemlayouts. MacOS, und alles andere.Keymap"},{"id":"de/documentation/keymap.html","title":"Lite XL - Standard Keymap","category":["documentation"],"content":"Standard KeymapTastaturkürzeln haben die gleichen Funktionen auf jeden Betriebssystem, sie sind einfach nur anders gebunden\num sich für normale Erwartungen für dem Betriebssystem anzupassen.Momentan gibt es nur two Betriebssystemlayouts. MacOS, und alles andere.Keymap"},{"id":"de/documentation/usage.html","title":"Lite XL - Nutzen","category":["documentation"],"content":"NutzenLite XL ist ein leichter Texteditor dass größtensteils geschrieben in Lua - es zielt darauf ab etwas praktisches, schönes, kleines und schnelles zu bieten. \nSo leicht wie möglich umgesetzt; leicht zur modifizieren und erweitern, oder zum Benutzen ohne beides zu machen.Lite XL ist auf dem Lite Editor basiert und bietet paar Verbesserungen an\nwährend es immernoch kompatible bleibt.Erste SchritteLite XL funktioniert mit Projektverzeichnissen - dies sind Ordnern indem der Code \ndeines Projektes und andere Daten beinhaltet sind.Um ein spezifisches Projektverzeichnis zu öffnen kann der Ordnername als Befehlzeilenargument angegeben werden. (. kann angegeben werden um den jetzigen Ordner zu benutzen)\noder der Ordner kann ins Fenster gezogen werden.Einmal angefangen kann das Projektverzeichnis mit dem Befehl core:change-project-folder geändert werden. Der Befehl wird alle Dokumente schließen \ndie zu Zeit offen sind und wechselt zum neuen Projektverzeichnis.Wenn du ein neues Projektverzeichnis in einem neuen Fenster öffnen willst kannst du den Befehl core:open-project-folder ausführen.\nEs wird ein neues Fenster mit dem ausgewählten Projektverzeichnis öffnen.Die Hauptmethode um Dateien in Lite XL zu öffnen ist der Befehl core:find-file - \ndies bietet eine fuzzy finder über alle Dateien des Projekts an \nund kann mit dem ctrl+p Abkürzung geöffnet werden.Befehle können durch Tastaturkürzel aktiviert werden, oder wenn man core:find-command benutzt.\nDas core:find-command Befehl ist normalerweise an ctrl+shift+p gebunden. Zum Beispiel,\nwenn man die Tastaturkürzel oben drückt und newdoc schreibt und dann return drückt, öffnet man ein neues Dokument.\nDie eingestellte Tastaturkürzel für jedes Befehl kann man auf der rechten Seite des Namens sehen. Also kann man mit ctrl+shift+p drücken, um Tastaturkürzel für Befehle zu finden.BenutzerdatenverzeichnisseLite XL benutzt Standardsystembenutzerverzeichnisse; Die Nutzerdaten können in $HOME/.config/lite-xl auf Linux und MacOS gefunden werden.\nAuf Windows wird das Variable $USERPROFILE anstatt $HOME benutzt.BenutzermoduleLite XL wird durch Benutzermodule konfiguriert. Das Benutzermodul kann benutzt werden um neue Tastaturkürzel und\nneue Farbschemen hinzuzufügen, oder den Stil oder andere Teile des Editors zu ändern.Das Benutzermodul wird geladen nachdem die Anwendung gestartet wurde, nachdem Plugins geladen wurden.Das Benutzermodul kann modifiziert werden indem man das core:open-user-module Befehl ausführt\nsonst kann es auch modifiziert werden indem man die $HOME/.config/lite-xl/init.lua Datei öffnet.Auf Windows wird das Variable $USERPROFILE anstatt $HOME benutzt.tl;dr:Windows: C:\\Users\\(username)\\.config\\lite-xl\\init.lua\nMacOS: /Users/(usernmame)/.config/lite-xl/init.lua\nLinux: /home/(username)/.config/lite-xl/init.lua\nDies sind nicht die genauen Orte, aber sie helfen dir sie zu finden.Bitte bemerke dass Lite XLs Benutzermodul ein ganz anderen Ort hat als Lite Editors.ProjektmodulDas Projektmodul ist ein optionaler Modul der vom aktuellen Verzeichnis des Projekts geladen wird, wenn Lite XL startet.\nProjektmodule können nützlich sein wenn man eigene Befehle für projektspezifische Befehle für Buildsysteme oder das Laden von projektspezifische Plugins braucht.Nachdem die Plugins- und Benutzermodule geladen wurden,Das Projektmodul kann editiert werden indem man core:open-project-module ausführt - Wenn das Modul nicht existiert, wird das Befehl eines erstellen.Füge Ordner zum Projekt hinzuEs ist möglich andere Projektverzeichnisse hinzuzufügen indem man den core:add-directory Befehl ausführt.\nEs wird auf der rechten Seite angezeigt werden und du kannst die Dateien im Ordner mit den ctrl+p Befehl auswählen.Andere Projektverzeichnisse können mit dem core:remove-directory Befehl entfernt werden.Wenn du dann Lite XL wiederöffnest werden die gleichen Projektverzeichnisse bleiben.\nDie Anwendung merkt sich dein Arbeitsplatz und auch die hinzugefügten Projektverzeichnisse.Seit Version 1.15 braucht Lite XL kein Arbeitsplatz Plugin, es ist ein Teil des Editors.Erstelle einen leeren OrdnerMit dem files:create-directory Befehl oder control-click im Treeview kann man leere subordner erstellen.BefehleBefehle werden im Befehlfinder und im Tastaturkürzelsystem von Lite XL benutzt.\nEin Befehl besteht aus diesen drei Komponenten:Name - der Befehl name in Form von Namensraum:aktion-name, z.B doc:select-all\nAussagen - Eine Funktion die true zurückgibt wenn der Befehl ausgeführt werden kann, z.B für alle Dokumentenbefehle wird geschaut ob das ausgewählte View ein Dokument ist\nFunktion - Die Funktion die das Befehl ausführt\nBefehle können hinzugefügt werden mit der command.add Funktion die vom core.command Modul bereitgestellt wird:local core = require \"core\"\nlocal command = require \"core.command\"\ncommand.add(\"core.docview\", {\n\\t[\"doc:save\"] = function()\n\\tcore.active_view.doc:save()\n\\tcore.log(\"Saved '%s'\", core.active_view.doc.filename)\n\\tend\n})\nBefehle können programmatisch ausgeführt werden, indem man die command.perform Funktion vom core.command Modul benutzt:local command = require \"core.command\"\ncommand.perform \"core:quit\"\nTastaturkürzelAlle Tastaturkürzel werden vom core.keymap Modul verarbeitet.\nEine Tastaturkürzel verbindet ein \"Kürzel\" (z.B ctrl+q) mit ein oder mehreren Befehlen (z.B core:quit).\nWenn eine Tastaturkürzel gedrückt wird, iteratiert Lite XL über jedes Befehl dass zu dieser Tastaturkürzel zugewiesen wurde\nund führt die Aussage Funktion für diesem Befehl aus - wenn eine Aussage erfolgreich ist, dann stoppt es die Iteration und führt den Befehl aus.Ein Beispiel ist die tab Taste:\\t[\"tab\"] = { \"command:complete\", \"doc:indent\" },\nWenn Tab gedrückt wird, wird command:complete nur ausgeführt wenn die ausgewählte View das Befehleingang ist. Sonst\nwird das doc:indent ausgeführt wenn das ausgewählte View das Dokument ist.Ein neues Tastaturkürzel kann so in dein Benutzermodul hinzugefügt werden:local keymap = require \"core.keymap\"\nkeymap.add { [\"ctrl+q\"] = \"core:quit\" }\nEine Liste der Standard Tastaturkürzel kann hier gefunden werden.Globale VariablenEs gibt ein paar globale Variablen die vom Editor gesetzt werden.\nDiese Variablen sind überall und sollten nicht überschrieben werden.ARGS: Befehlszeilenargumente. argv[1] ist der Name der Anwendung, argv[2] ist das erste Parameter, ...\nPLATFORM: Ausgabe von SDL_GetPlatform(). Kann Windows, Mac OS X, Linux, iOS und Android sein.\nSCALE: Schriftartengröße. Normalerweise 1, Aber kann bei HiDPI Systemen höher sein.\nEXEFILE: Absoluter Pfad zur ausführdatei.\nEXEDIR: Der ausführpfad. Schreibe nicht zu diesem Ordner\nVERSION: lite-xl Version.\nMOD_VERSION: mod-version die in Plugins benutzt wird. Wird geändert wenn die API sich ändert.\nPATHSEP: Pfad Trennzeichen. \\ (Windows) or / (Anderen Betriebssystemen)\nDATADIR: Der Daten Ordner, wo der Lua Teil von lite-xl ist. Schreibe nicht zu diesem Ordner.\nUSERDIR: Benutzerkonfiguration Ordner.\nUSERDIR soll anstatt DATADIR benutzet werden wenn man den Editor konfiguriert\nweil DATADIR vielleicht nicht schreibbar ist.\n(Zum Beispiel, wenn der Editor in /usr installiert ist, dann ist DATADIR in /usr/share/lite-xl!)\nUSERDIR ist immer für den Nutzer schreibbar, es erlaubt mehrere Nutzer ihren Editor zu konfigurierenPluginsPlugins in Lite XL sind normale Lua Module und werden auch so behandelt - Kein komplizierter Pluginmanager wird bereitgestellt, und wenn einmal ein Plugin geladen ist, kann es sich nicht selber entladen.Um ein Plugins zu installieren kannst du es einfach im plugins Ordner im Benutzermodulordner reingeben.\nWenn Lite XL startet, ladet es zuerst die Plugins im Datenordner, dann wird es die Plugins im Benutzermodulordner laden.Um ein Plugin zu deinstallieren, kann man einfach die Plugin Datei löschen - alle Plugins \n(Auch die was mit dem Editor installiert kommen) können gelöscht werden, um ihre Funktionen zu entfernen.Wenn du Plugins nur unter bestimmten Umstanden laden willst (z.B nur in einem bestimmen Project), \ndann kann der Plugin irgendwo außer im plugins Ordner gegeben werden. Der Plugin kann dann manuell geladen werden mit der\nrequire Funktion.Plugins können vom Plugins Repository heruntergeladen werden.Den Editor neustartenWenn du eine Benutzerkonfiguration Datei oder eine Lua Implementation Datei modifizierst, \ndann kannst du mit core:restart Befehl den Editor neustarten.\nDie ganze Anwendung wird neugeladen indem es ein existierendes Fenster neustartet.Color ThemesFarbthemen in Lite XL sind Lua Module die Farbfelder von Lite XLs core.style Modul überschreiben.\nVordefinierte Farbenmethoden sind im colors Ordner im Datenordner.\nNeue Farbthemen können installiert werden im colors Ordner dass in dein Benutzermodulordner ist.Ein Farbthema kann benutzt werden indem man es in dein Benutzermodulordner erfordert:core.reload_module \"colors.winter\"\nIm Lite Editor wird die require funktion benutzt anstatt core.reload_module.\nIn Lite XL soll core.reload_module benutzt werden um sicher zu sein, dass ein Farbmodul echt neugeladen wird,\nwenn man die Benutzerkonfiguration speichert.Farbthemen können vom Farbthemen Repository heruntergeladen werden.\nSie sind in Lite XL Veröffentlichungpacketen enthalten."},{"id":"de/downloads.html","title":"Lite XL - Downloads","category":[],"content":"DownloadsBinary PacketeBinär Packete sind verfügbar in der GitHub Veröffentlichungensseite.Installieren über PacketverwaltungOder du kannst Lite-XL über den Paketmanager deiner Distribution installieren.\nDiese Packete werden von der Community erhalten und sind vielleicht veraltet.Windows (Chocolatey / Scoop)\nMac OS (MacPorts)\nArch Linux (AUR)\nNixOS (nixpkgs)\nFedora\nchoco install lite-xl\\t# chocolatey\nscoop bucket add extras && scoop install lite-xl\\t# scoop\nsudo port install lite-xl\\t# macports\nyay -S lite-xl\\t# oder dein lieblings AUR helper\nnix-env -i lite-xl\\t# nixos\nsudo dnf install lite-xl # fedora\nQuellcodeDas Quellcode ist verfügbar auf GitHub, durch Herunterladen von Zip- oder Tar Archiven,\noder direkt über Git:git clone https://github.com/lite-xl/lite-xl.git"},{"id":"de/index.html","title":"Lite XL","category":[],"content":"Lite XLEin leichter, simpler, schneller, funktionsreicher, und extrem erweiterbarerer Texteditor geschrieben in C, und Lua, angepasst von lite.![Lite XL Editor](/assets/img/editor.png)"},{"id":"de/tutorials/api-overview.html","title":"Lite XL - API Overview","category":["tutorials"],"content":"API OverviewThis is a work in progress.Here we provide some resources and explanation to some API and aspects of Lite XL.\nFor API docs, it's available in the repo\nThus, we'll not explain everything, only the more important and frequently used features.Built-in APIs:Process API\nSystem API\nRegex API"},{"id":"de/tutorials/index.html","title":"Lite XL - Tutorials","category":["tutorials"],"content":"TutorialsDiese Seiten enthalten Tutorials und Dokumentationen zum Erstellen von Plugins in Lite XL.API Overview\nEinfaches Plugin\nSyntaxhervorhebung\nSystem Schriftarten"},{"id":"de/tutorials/overview/process.html","title":"Lite XL - Process API","category":["tutorials","overview"],"content":"Process APILite XL provides a process API to launch external applications. This API is meant to replace\nlua's io.popen and lite's pipe-to-a-file approach.Advantages of this API includes:Proper argument escaping (arguments are supplied via a table)\nNonblocking IO\nAble to detach processes from Lite XL (in progress)\nDoes not create temporary files\nMostly cross-platform (does not require special code for each shell)\nUsing the Process APIError handlingprocess.start() may throw errors if it cannot run the program.\nprocess.read* and process.write functions may throw errors if\nthe process ended\nthe process closed the stream\nyou closed the stream\nthere might be other errors to look forward to too\nStarting a processTo start a process, use process.start(args, options).Here are some of the more useful arguments.args: The executable and any arguments, eg: { \"sh\", \"-c\", \"echo hello world\" }\noptions: Options for process.start()\nenv: A key-value table containing the env. Note that if this is provided,\n\\tenvironment variables will not be inherited.\nstdin: Specify where to redirect stdin\nstdout: Specify where to redirect stdout\nstderr: Specify where to redirect stderr\nfor options.std{in,out,err}, valid values are:process.REDIRECT_PIPE (Make it available to subprocess API for reading / writing)\nprocess.REDIRECT_DISCARD (Discard the output. Use this to prevent buffering)\nprocess.REDIRECT_STDOUT (stderr only, for redirecting stderr to stdout)\nReading from processTo read from stdout or stderr of a process, use process:read_stdout() and\nprocess:read_stderr() respectively.You can specify a numeric argument to them, which will change the size of internal buffer used\nto read the output.Alternatively, you could use process:read() with process.STREAM_STDERR and process.STREAM_STDOUT.Example:local proc = process.start { \"sh\", \"-c\", \"echo hello world!\" }\n-- do not use `while proc:running()` if you care about output.\n-- The process could die and leave data in the buffer\n-- You should just read until `proc:read_stdout()` returns nil\nwhile true do\n\\tlocal rdbuf = proc:read_stdout()\n\\tif not rdbuf then break end\n\\t-- yay, output\nend\nWriting to processYou can use process:write(data) to write a string to stdin.Checking completionprocess:running() returns a boolean to indicate whether if the process is running.\nprocess:wait(time) also does the same thing, but you specify how long it should wait (or 0 to return immediately).\nTerminating processprocess:terminate() sends SIGTERM (or Windows equivalent) to the process.\nprocess:kill() sends SIGKILL (or Windows equivalent) to the progress.\nUse this only if process:terminate() cannot kill the process, as it can cause issues.\nMiscprocess:pid() returns the PID of the process.\nThere are no guarantees for this PID to be correct if the process terminated early.\nprocess:returncode() returns the exit code of the process, if any\nprocess:close_stream() closes stdin, stdout or stderr stream of the process."},{"id":"de/tutorials/overview/regex.html","title":"Lite XL - Regex API","category":["tutorials","overview"],"content":"Regex APIThis API provides PCRE regular expressions for those who needs more power in matching text.\nThis API written in C and Lua.Creating a regexUse regex.compile(pattern, options) to compile a regex.pattern: The regex pattern\noptions: regex modifiers as a string, eg \"im\"\n\"i\": Case-insensitive search\n\"m\": Multiline search\n\"s\": Match all characters with dot (.), including newlines.\nMatchingLow level functionsregex:cmatch(str, offset, options) low-level matching function\nstr: The string to match against\noffset: Where to start matching\noptions: A bit field of options\nregex.ANCHORED: Only match from the start of the string\nregex.ENDANCHORED: Only match from the end of the string\nregex.NOTBOL: String is not beginning of line\nregex.NOTEOL: String is not the end of line\nregex.NOTEMPTY: Do not match an empty string\nregex.NOTEMPTY_ATSTART: Do not match empty string at the start\nNote: regex:cmatch() returns wrong indexes (currently at version 2.0.2).\n\\tThe end index returned by regex:cmatch() is always off by 1 (-1 to get the actual end index).High level functionsAll the functions below can be in 2 forms:\n- regex:fn(...) where regex is the compiled regex instance\n- regex.fn(pattern, ...) where pattern is a pattern string to be compiled and used directly.We will only document the first form.regex:match(str, offset, options) high level matching function. This function accepts\nthe same arguments as regex:cmatch()\nregex:gsub(str, replacement) replaces matches in str with replacement.\nCapture groups are identified with \\\\0 to \\\\9, this might change in the future."},{"id":"de/tutorials/overview/system.html","title":"Lite XL - System API","category":["tutorials","overview"],"content":"System APIThis is where Lite XL's lua code interact with its underlying C engine.\nSome of the functions here will be omitted because they're not useful for\nplugins.Clipboardsystem.set_clipboard(text) sets the clipboard content.\nsystem.get_clipboard() retrieves the content of the clipboard.\nFile / Directory manipulationsystem.list_dir(dir) returns a list of filenames in a directory.\nsystem.rmdir(dir) removes a directory. Use this instead of os.remove().\nThe directory must be empty.\nsystem.chdir(dir) changes the current working directory (like cd).\nsystem.mkdir(dir) creates a new directory.\nIt does not recursively create directories.\nsystem.absolute_path(path) resolves the path components (.. and .) to an absolute path.\nsystem.get_file_info(path) returns info about a path.\nmodified: last modification time of the file in seconds since UNIX epoch.\nsize: file size in bytes.\ntype: Path type (\"file\" or \"dir\").\nTimingsystem.get_time() returns time in seconds (as floating point number) since Lite XL started.\nUse this instead of os.time() for higher precision timers.\nsystem.sleep(time) sleeps for time in milliseconds.\nDo not use this. Write asynchronous code.\nWindow manipulationsystem.set_window_opacity(o) sets the window opacity from 0 to 1.\nsystem.set_window_title(title) sets the window title.\nsystem.set_window_mode(mode) sets window mode:\n\"normal\": also known as \"restored\" on Windows.\n\"maximized\": Maximize the window.\n\"minimized\": Minimize the window.\n\"fullscreen\": Fullscreen\nsystem.set_window_bordered(bordered) enables or disable window border (decoration).\nsystem.set_window_hit_test(height, control_width, resize_border) sets window hit test (used for\nconfig.borderless to make custom drawn border interactable).\nIf no argument is supplied, reset the hit test values.\nheight: height of the title bar.\ncontrols_width: Not too sure about this, but it should be the size of the title bar controls\n(Maximize, Minimize and Normal buttons on the right).\nIt seems to be fixed at the right side of the title bar.\nresize_border: Number of pixels reserved for resizing the window.\n(setting this to a large value means that you can resize the window way easier)\nsystem.get_window_size() gets the window size.\nsystem.set_window_size(w, h, x, y) sets the window size (and also position).\nsystem.window_has_focus() checks whether the window is in focus.\nsystem.show_fatal_error(title, msg) shows an system error message box.\nUse nagview whenever possible.\nMiscsystem.exec(command) runs a command. Use the Process API instead of this.\nsystem.fuzzy_match(haystack, needle, file) generates a score depends on how close the needle\nmatches the haystack.\nfile: match backwards (more accurate for filename matching)."},{"id":"de/tutorials/simple-plugin.html","title":"Lite XL - Einfache Plugins","category":["tutorials"],"content":"Einfache PluginsWas ist Simple?Simple ist ein einfaches Plugin dass geschrieben wurde mit der Absicht Entwickler\ndie neu bei Lite XL sind, den Prozess des Schreibens von Plugins für den Editor zu zeigen.Was macht das Plugin?Das Plugin zeigt eine Nachricht (Das als Eingabe Des Benutzers übernommen wird) \nam oberen rechten Eck des Editorfensters. Es erlaubt auch den Benutzer das Umschalten der Sichtbarkeit \nder Nachricht.Ich kann nicht Lua schreiben!Wenn du von anderen Programmierungsprachen kommst, dann schau dir das Lua cheatsheet an.\nWenn du neu bei programmieren bist, dann schau dir das (English) an.Das Format vom TutorialDas Code enthält Kommentare die detailieren was das Meiste (wenn nicht alles) \nim Code macht.Die Kommentare sind gerade in Englisch, aber ich glaub das wirst du schon verstehen :)Das Code:-- mod-version:3\n-- you MUST put mod-version:x on the first line of your plugin\n-- mod-version usually maps to lite-xl releases (eg. mod-version: 2 == lite-xl 2.0)\n-- lite-xl won't load the plugin if the mod-version mismatches\n-----------------------------------------------------------------------\n-- NAME\\t: Simple\n-- DESCRIPTION: A simple guide on how to make your first Lite XL plugin\n-- AUTHOR\\t: Ashwin Godbole (aelobdog)\n-- GOALS\\t: To render some text inside the editor\n-----------------------------------------------------------------------\n-- Disclaimer :\n-- I am not a lua developer, and my knowledge about writing plugins for\n-- Lite XL is very limited. This file serves the purpose of helping the\n-- reader get started with plugin development for Lite XL, and therefore\n-- demonstrates only some very basic features. For more complex plugin\n-- development, be sure to check out the source code of some other\n-- plugins after going through this file.\n-----------------------------------------------------------------------\n-- Before we start writing any code for the plugin, we must import the\n-- required modules from the \"core\" package.\n-- the \"core\" module\nlocal core = require \"core\"\n-- the \"command\" module will help us register commands for our plugin.\nlocal command = require \"core.command\"\n-- the \"style\" module will allow us to use styling options\nlocal style = require \"core.style\"\n-- the \"config\" module will be used to store certain things like colors\n-- and functions\nlocal config = require \"core.config\"\n-- the \"keymap\" module will allow us to set keybindings for our commands\nlocal keymap = require \"core.keymap\"\n-- since we want to modify RootView, we'll need to require it first\nlocal RootView = require \"core.rootview\"\n-----------------------------------------------------------------------\n-- per-plugin config must stay in config.plugins.(plugin name)\nconfig.plugins.simple = {}\n-- colors are just three or four comma separated values (RGBA) (range 0 - 255)\n-- put inside of '{ }'. We will add our color to the config module.\nconfig.plugins.simple.text_color = {200, 140, 220} -- or use `{ common.color \"#C88CDC\" }`\n-----------------------------------------------------------------------\n-- Let's create a function to calculate the coordinates of our text.\n-- While we're at it, let's add our function to the `config` module.\n-- We'll take the message we want to display as the argument to the\n-- function to determine the x and y coordinates of the text.\nfunction config.plugins.simple.get_text_coordinates(message)\n\\t-- For this plugin, we want to display the text on the top right\n\\t-- corner of the screen. For this, we need to know the editor's width\n\\t-- and height.\n\\t-- The current font's size can be obtained from the \"style\" module.\n\\t-- The editor's dimensions can be obtained by\n\\t--\\t1. WIDTH\\t: core.root_view.size.x\n\\t--\\t2. HEIGHT : core.root_view.size.y\n\\tlocal message_width = style.code_font:get_width(message..\" \")\n\\tlocal font_height = style.code_font:get_size()\n\\tlocal x = core.root_view.size.x - message_width\n\\tlocal y = font_height / 2\n\\treturn x, y\nend\n-----------------------------------------------------------------------\n-- Let's now get to actually drawing the text inside the editor.\n-- In order to \"inject\" our own code to draw text,\n-- we'll need to save the original draw function\n-- We'll save `RootView.draw` to a variable we call `parent_draw`\nlocal parent_draw = RootView.draw\n-- Now let's overload the original definition of `draw` in RootView\n-- by redefining the function.\nfunction RootView:draw()\n\\t-- We call the parent's function to keep the editor functional...\n\\t-- obviously we must still draw all the other stuff !\n\\t-- So we call the `parent_draw` function before doing anything else.\n\\tparent_draw(self)\n\\t-- we'll add an option to toggle the message on and off. let's use a\n\\t-- boolean variable to keep track of whether we want to display the\n\\t-- message or not.\n\\tif config.plugins.simple.show_my_message then\n\\t-- We'll be getting the message to display as input from the user\n\\t-- later. We'll store that user input in `config.plugins.simple.hw_message`.\n\\t-- (NOTE: this variable does not come in-built in lite-xl;\n\\t--\\tit is a variable that we will define later.)\n\\t-- let's store the value of config.plugins.simple.hw_message in a local variable\n\\t-- `message` in case config.plugins.simple.hw_message we set the message to\n\\t-- \"message not set yet!\"\n\\tlocal message\n\\tif config.plugins.simple.hw_message then\n\\tmessage = config.plugins.simple.hw_message\n\\telse\n\\tmessage = \"Message not set yet !\"\n\\tend\n\\t-- let's get the coordinates for our text\n\\tlocal x, y = config.plugins.simple.get_text_coordinates(message)\n\\t-- let's finally draw the text to the window !\n\\t-- the draw_text function from `renderer` is an important function\n\\t-- as it is used to display any and all text inside of the editor\n\\t-- window\n\\trenderer.draw_text(style.code_font, message, x, y, config.plugins.simple.text_color)\n\\tend\nend\n-----------------------------------------------------------------------\n-- Let's allow the user to turn the message on and off\n-- we'll write a function to flip our \"show\" boolean variable.\nlocal function toggle_helloworld()\n\\tconfig.plugins.simple.show_my_message = not config.plugins.simple.show_my_message\nend\n-----------------------------------------------------------------------\n-- Finally, let's add the toggle function to the command list so that\n-- we can call it from the C-S-p command panel. Let's add one command\n-- to toggle the visibility of the message on and off and one to get\n-- the user's message and then display it.\ncommand.add(nil, {\n\\t-- Toggle the visibility of the message\n\\t[\"simple:toggle\"] = toggle_helloworld,\n\\t-- Set and show the message\n\\t-- This is the way to get user input through the command bar.\n\\t-- `core.command_view:enter` takes 2 arguments:\n\\t--\\t* the prompt to display before taking input\n\\t--\\t* a function that takes the \"input\" as its argument\n\\t-- (NOTE: here the variable we are reading input into is `text`)\n\\t[\"simple:setshow\"] = function()\n\\tcore.command_view:enter(\"Test to display\", {\n\\tsubmit = function(text)\n\\tconfig.plugins.simple.hw_message = text\n\\tconfig.plugins.simple.show_my_message = true\n\\tend\n\\t})\n\\tend\n})\n-----------------------------------------------------------------------\n-- Just for fun, let's assign our commands their own keybindings.\n-- Here, we assign the keybinding the same string(its name) as the one\n-- that we set while creating the command\nkeymap.add {\n\\t[\"alt+s\"] = \"simple:setshow\",\n\\t[\"alt+t\"] = \"simple:toggle\",\n}\nZusätzlichesLite: Eine Implementation Übersicht (English), ein exzellentes Post von rxi dass meistens zu lite-xl relevant bleibt.\nAPI Übersicht (English), wo mache APIs erklärt werden."},{"id":"de/tutorials/syntax-highlighting.html","title":"Lite XL - Syntaxhervorhebung","category":["tutorials"],"content":"<!-- Delete later: continue at line 161 -->\nSyntaxhervorhebungSo erstellt man Syntaxhervorhebung für Lite XLSyntaxhervorhebung Plugins für Lite XL sind Lua Dateien. Diese Dateien definieren Muster oder Regex\nverschiedene teile einer gegebenen Sprache, man ordnet Token-Typen zu Übereinstimmung zu.\nDiese verschiedenen Token-Typen werden dann verschiedene farben von deinem ausgesuchten Color Scheme gegeben.Wie andere Plugins, Syntax Definitionen werden von den folgenden Ordnern empfangen, in der folgenden Reihenfolge:/usr/share/lite-xl/plugins/\n$HOME/.config/lite-xl/plugins/\nBEMERKE: Der genaue Ort von diesen Ordnern wird von dein Betriebssystem und Installationsmethode abhängen. Zum Beispiel, unter Windows wird das Variable $USERPROFILE benutzt werden anstatt $HOME.Der Benutzer Modul Ordner für Lite Xl kann in diesen Orten auf different Betriebssystemen gefunden werden:Windows: C:\\Users\\(nutzername)\\.config\\lite-xl\nMacOS: /Users/(nutzername)/.config/lite-xl\nLinux: /home/(nutzername)/.config/lite-xl\nAlso, um eine neue Syntax Definition auf Linux zu erstellen, musst du eine .lua Datei in dein $HOME/.config/lite-xl/plugins/ Ordner machen.Welche Syntax-Token arten sind unterstützt?Die unterstützten Syntax_Token art, definiert von lite-xl/core/style.lua, sind:normal\nsymbol\ncomment\nkeyword\nkeyword2\nnumber\nliteral\nstring\noperator\nfunction\nIn dein Syntaxhervorhebung Plugin, schreibst du Muster um Teile der Sprachen-Syntax zu entsprechen, und um Token-Typen zu übereinstimmen. Du musst nicht alle benutzen - benutze so viele die du brauchst für deine Sprache.Let's walk through an example syntax definition and see how this works.Gehen wir mal durch eine Beispiel Syntax Definition und wir werden sehen wie es funktioniert.Beispiel Syntax: ssh config DateienDas ist ein kleines, simples Beispiel von einer Syntax Definition, Es soll eine SSH config Datei hervorheben und es sieht so aus:-- mod-version:2 -- lite-xl 2.0\nlocal syntax = require \"core.syntax\"\nsyntax.add {\n\\tfiles = { \"sshd?/?_?config$\" },\n\\tcomment = '#',\n\\tpatterns = {\n\\t{ pattern = \"#.*\\n\",\\ttype = \"comment\"\\t},\n\\t{ pattern = \"%d+\",\\ttype = \"number\"\\t},\n\\t{ pattern = \"[%a_][%w_]*\",\\ttype = \"symbol\"\\t},\n\\t{ pattern = \"@\",\\ttype = \"operator\" },\n\\t},\n\\tsymbols = {\n\\t-- ssh config\n\\t[\"Host\"]\\t= \"function\",\n\\t[\"ProxyCommand\"]\\t= \"function\",\n\\t[\"HostName\"]\\t= \"keyword\",\n\\t[\"IdentityFile\"]\\t= \"keyword\",\n\\t...\n\\t-- sshd config\n\\t[\"Subsystem\"]\\t= \"keyword2\",\n\\t-- Literals\n\\t[\"yes\"]\\t= \"literal\",\n\\t[\"no\"]\\t= \"literal\",\n\\t[\"any\"]\\t= \"literal\",\n\\t[\"ask\"]\\t= \"literal\",\n\\t},\n}\nSchauen wir uns mal jeden Teil an und schauen wie es funktioniert.HeaderDie erste Zeile ist ein Lua kommentar und sagt Lite XL welche version dieses Plugin braucht. Die zweite Zeile importiert das core.syntax Modul\ndass wir nutzen können:-- mod-version:2 -- lite-xl 2.0\nlocal syntax = require \"core.syntax\"\nDann fügen wir eine Syntax Definition mit syntax.add {...} zu lite ein.FilesDie files Eigenschaft sagt Lite XL welche Dateien these Syntax benutzt werden soll. Das ist ein Lua Muster, das mit dem vollständigen Pfad der geöffneten Datei übereinstimmt. Zum Beispiel, um gegen Markdown Dateien zu übereinstimmen - mit entweder eine .md oder eine .markdown Erweiterung,\ndu könntest das machen:files = { \"%.md$\", \"%.markdown$\" },\nIn unseren original Beispiel, gleichen wir mit dem Ende des Pfads und nicht mit der Erweiterung ab, weil SSH config Dateien keine Erweiterung hat - und wir nicht alle config Dateien abgleichen. Wir erwarten den Pfad für SSH config Dateien so auszusehen:~/.ssh/config\n/etc/ssh/ssh_config\n/etc/ssh/sshd_config\nDieses Muster gleicht Pfade ab die so aussehen:files = { \"sshd?/?_?config$\" },\nKommentareDie Kommentar Eigenschaft definiert nicht welche Teile der Syntax Kommentare sind - Schaue auf Muster für das unten. Diese Eigenschaft sagt Lite XL welche Charaktere beim Anfang der ausgewählten Zeilen hinzufügt werden sollen, wenn du ctrl+/ drückst.\nDu kannst auch block_comment benutzen um Lite XL zu sagen, wie es multiline oder Block Kommentare machen soll.MusterEin gegebener Textabschnitt kann nur ein Muster abgleicht werden. Wenn Lite XL einmal einschieden hat, dass es mit einem Muster übereinstimmt, dann wird es den Token-Typen zuweisen und es wird weitergehen.\nMuster werden getestet in der Reihenfolge wie es in der Syntax Definition geschrieben wurde, also wird das erste Übereinstimmen gewinnen.Jedes Muster nimmt einer dieser Formen an:Einfaches Muster{ pattern = \"#.*\\n\",\\ttype = \"comment\" },\nDiese Form gleicht die Zeile mit dem Muster ab und wenn es abstimmt, weist es in diesem Fall den passenden Text den gebenen Token type - comment zu.Start- & Endmuster{ pattern = { \"%[\", \"%]\" }, type = \"keyword\" },\nDiese Form hat zwei Muster - eines das mit dem Anfang des Bereichs übereinstimmt und eines dass mit dem Ende übereinstimmt. Alles zwischen den Anfang und den Ende wird den Token type zugewiesen.Start- & Endmuster, mit Ausgang{ pattern = { '\"', '\"', '\\\\' }, type = \"string\" },\nDieses ist das Gleiche wie die letzte Form, aber mit einem dritten Parameter.\nDer dritte Teil, der '\\\\' Teil in diesem Beispiel, spezifiziert den Charakter dass entkommen vom Schlussübereinstimmung ermöglicht.Für mehr Information von Lua Muster, sehe Lua Muster Referenz (English)Wenn du PCRE Regular Expressions anstatt Lua Muster benutzen musst, kannst du das Stichwort regex anstelle von pattern benutzen.SymboleDieser Teil ist nicht mit dem symbol Token-Typ verwandt.Dieser Symbol Teil erlaubt dir Token-Typen zu bestimmten Schlüsselwörtern zuzuordnen - normalerweise sind das Wörter in der Sprache dass du hervorhebst.\nDer Token-Typ in diesem Teil nimmt immer Vorrang über Token-Typen deklariert im Muster.Zum Beispiel, Dieses Code markiert Host als function Token-Typ, HostName als keyword und yes, no, any & ask als literal:[\"Host\"]\\t= \"function\",\n[\"HostName\"]\\t= \"keyword\",\n[\"yes\"]\\t= \"literal\",\n[\"no\"]\\t= \"literal\",\n[\"any\"]\\t= \"literal\",\n[\"ask\"]\\t= \"literal\",\nTips: Überprüfe deine Muster!Es gibt häufige Fehler die gemacht werden können wenn man das symbols Table in Verbindung mit Muster benutzt.Fall 1: Leerzeichen zwischen zwei symbols Token:Nehmen wir mal ein Beispiel:{ pattern = \"[%a_][%w_]+%s+()[%a_][%w_]+\", type = { \"keyword2\", \"symbol\" } }\nJetzt erklären wir mal das Muster ein bisschen (Lasse die Leeren Klammer weg):[%a_] = alle Buchstaben und Unterstriche\n[%w_] = alle Buchstaben, Nummern und Unterstriche\n%s = alle Leerzeichen Charaktere\nWORD =\n\\t[%a_] gefolgt von (1 oder mehr [%w_])\npattern =\n\\tWORD, gefolgt von (einem oder mehreren %s), gefolgt von WORD\nNachher fügst du einen Eintrag [\"my\"] = \"literal\" im symbols Table.\nDu kannst die Syntax testen mit my function, und findest heraus das \"my\" nicht als literal markiert wurde. Warum ist das passiert?**symbols table braucht eine genaue Übereinstimmung.\nWenn du sorgfältig schaust, siehst du dass leere Klammern **nach dem Leerzeichen platziert wurden!\nDass sagt Lite XL dass [%a_] gefolgt von (1 oder mehr [%w_]) ein Token ist, dass my übereinstimmen soll (bemerke das Leerzeichen in der Übereinstimmung).Das Lösung steckt darin, ein normal Token für Leerzeichen zwischen zwei Tokens hinzuzufügen:{ pattern = \"[%a_][%w_]+()%s+()[%a_][%w_]+\", type = { \"keyword2\", \"normal\", \"symbol\" } }\nFall 2: Muster & symbols TokenMan könnte annehmen dass Lite XL magisch Text mit den symbols Table vergleicht. Dies ist nicht der Fall.In manchen Sprachen fügen Leute generische Muster hinzu, um den Abgleich an die Tabelle symbols zu delegieren.{ pattern = \"[%a_][%w_]*\", \"symbol\" }\nJedoch könnte das symbols Table so ausschauen:symbols = {\n\\t[\"my-symbol\"] = \"function\",\n\\t[\"..something_else\"] = \"literal\"\n}\nmy-symbol enthält ein Strich (-) und \"..something_else\" enthält zwei Punkte (.).\nKeinen von diesen Charakteren stimmt mit [%a_][%w_]* überein!Vorsicht vor dem Text den du im symbols Table übereinstimmen willst.\nWenn du es benutzen willst, musst du dir sicher sein, dass es mit einer dieser Muster übereinstimmt.Die richtigen Muster sind:{ pattern = \"[%a_][%w%-_]*\", \"symbol\" },\n{ pattern = \"%.%.[%a_][%w_]*\", \"symbol\" },\nDeine neue Syntax testenUm deine neue Syntaxhervorhebung zu testen musst du diesen zwei Dinge machen:Lade den Lite XL Core neu\nLade eine Datei deiner ausgewählten Sprache und schaue an wie es ausschaut\nUm den Core neuzuladen kannst du entweder Lite XL neustarten, oder du ladest den Core über das Befehlspalette neu.\nUm dies zu machen, drücke ctrl+shit+ Befehlspalette zu zeigen, dann wähle Core: Restart aus (oder schreibe crr oder ähnliches um es zu finden), dann drücke Enter. Du musst den Core immer neustarten wenn du änderungen zur Syntaxhervorhebung machst.Beispiel des fortschrittlichen Syntax: MarkdownBemerke: Dieses Beispiel hat Funktionen von 2.1. Es ist nicht kompatible mit älteren Versionen von lite-xlNicht alle Sprachen sind so leicht wie SSH config Dateien. Markup Sprache wie HTML und Markdown sind sehr schwer richtig zu analysieren. Hier ist die Markdown Syntaxhervorhebung Datei in seiner vollen Pracht:-- mod-version:3\nlocal syntax = require \"core.syntax\"\nlocal style = require \"core.style\"\nlocal core = require \"core\"\nlocal initial_color = style.syntax[\"keyword2\"]\n-- Add 3 type of font styles for use on markdown files\nfor _, attr in pairs({\"bold\", \"italic\", \"bold_italic\"}) do\n\\tlocal attributes = {}\n\\tif attr ~= \"bold_italic\" then\n\\tattributes[attr] = true\n\\telse\n\\tattributes[\"bold\"] = true\n\\tattributes[\"italic\"] = true\n\\tend\n\\t-- no way to copy user custom font with additional attributes :(\n\\tstyle.syntax_fonts[\"markdown_\"..attr] = renderer.font.load(\n\\tDATADIR .. \"/fonts/JetBrainsMono-Regular.ttf\",\n\\tstyle.code_font:get_size(),\n\\tattributes\n\\t)\n\\t-- also add a color for it\n\\tstyle.syntax[\"markdown_\"..attr] = style.syntax[\"keyword2\"]\nend\nlocal in_squares_match = \"^%[%]\"\nlocal in_parenthesis_match = \"^%(%)\"\nsyntax.add {\n\\tname = \"Markdown\",\n\\tfiles = { \"%.md$\", \"%.markdown$\" },\n\\tblock_comment = { \"<!--\", \"-->\" },\n\\tspace_handling = false, -- turn off this feature to handle it our selfs\n\\tpatterns = {\n\\t---- Place patterns that require spaces at start to optimize matching speed\n\\t---- and apply the %s+ optimization immediately afterwards\n\\t-- bullets\n\\t{ pattern = \"^%s*%*%s\",\\ttype = \"number\" },\n\\t{ pattern = \"^%s*%-%s\",\\ttype = \"number\" },\n\\t{ pattern = \"^%s*%+%s\",\\ttype = \"number\" },\n\\t-- numbered bullet\n\\t{ pattern = \"^%s*[0-9]+[%.%)]%s\",\\ttype = \"number\" },\n\\t-- blockquote\n\\t{ pattern = \"^%s*>+%s\",\\ttype = \"string\" },\n\\t-- alternative bold italic formats\n\\t{ pattern = { \"%s___\", \"___%f[%s]\" },\\ttype = \"markdown_bold_italic\" },\n\\t{ pattern = { \"%s__\", \"__%f[%s]\" },\\ttype = \"markdown_bold\" },\n\\t{ pattern = { \"%s_[%S]\", \"_%f[%s]\" },\\ttype = \"markdown_italic\" },\n\\t-- reference links\n\\t{\n\\tpattern = \"^%s*%[%^()[\"..in_squares_match..\"]+()%]: \",\n\\ttype = { \"function\", \"number\", \"function\" }\n\\t},\n\\t{\n\\tpattern = \"^%s*%[%^?()[\"..in_squares_match..\"]+()%]:%s+.+\\n\",\n\\ttype = { \"function\", \"number\", \"function\" }\n\\t},\n\\t-- optimization\n\\t{ pattern = \"%s+\",\\ttype = \"normal\" },\n\\t---- HTML rules imported and adapted from language_html\n\\t---- to not conflict with markdown rules\n\\t-- Inline JS and CSS\n\\t{\n\\tpattern = {\n\\t\"<%s*[sS][cC][rR][iI][pP][tT]%s+[tT][yY][pP][eE]%s*=%s*\" ..\n\\t\"['\\\"]%a+/[jJ][aA][vV][aA][sS][cC][rR][iI][pP][tT]['\\\"]%s*>\",\n\\t\"<%s*/[sS][cC][rR][iI][pP][tT]>\"\n\\t},\n\\tsyntax = \".js\",\n\\ttype = \"function\"\n\\t},\n\\t{\n\\tpattern = {\n\\t\"<%s*[sS][cC][rR][iI][pP][tT]%s*>\",\n\\t\"<%s*/%s*[sS][cC][rR][iI][pP][tT]>\"\n\\t},\n\\tsyntax = \".js\",\n\\ttype = \"function\"\n\\t},\n\\t{\n\\tpattern = {\n\\t\"<%s*[sS][tT][yY][lL][eE][^>]*>\",\n\\t\"<%s*/%s*[sS][tT][yY][lL][eE]%s*>\"\n\\t},\n\\tsyntax = \".css\",\n\\ttype = \"function\"\n\\t},\n\\t-- Comments\n\\t{ pattern = { \"<!%-%-\", \"%-%->\" },\\ttype = \"comment\" },\n\\t-- Tags\n\\t{ pattern = \"%f[^<]![%a_][%w_]*\",\\ttype = \"keyword2\" },\n\\t{ pattern = \"%f[^<][%a_][%w_]*\",\\ttype = \"function\" },\n\\t{ pattern = \"%f[^<]/[%a_][%w_]*\",\\ttype = \"function\" },\n\\t-- Attributes\n\\t{\n\\tpattern = \"[a-z%-]+%s*()=%s*()\\\".-\\\"\",\n\\ttype = { \"keyword\", \"operator\", \"string\" }\n\\t},\n\\t{\n\\tpattern = \"[a-z%-]+%s*()=%s*()'.-'\",\n\\ttype = { \"keyword\", \"operator\", \"string\" }\n\\t},\n\\t{\n\\tpattern = \"[a-z%-]+%s*()=%s*()%-?%d[%d%.]*\",\n\\ttype = { \"keyword\", \"operator\", \"number\" }\n\\t},\n\\t-- Entities\n\\t{ pattern = \"&#?[a-zA-Z0-9]+;\",\\ttype = \"keyword2\" },\n\\t---- Markdown rules\n\\t-- math\n\\t{ pattern = { \"%$%$\", \"%$%$\", \"\\\\\"\\t},\\ttype = \"string\", syntax = \".tex\"},\n\\t{ pattern = { \"%$\", \"%$\", \"\\\\\" },\\ttype = \"string\", syntax = \".tex\"},\n\\t-- code blocks\n\\t{ pattern = { \"```c++\", \"```\" },\\ttype = \"string\", syntax = \".cpp\" },\n\\t-- ... there's some other patterns here, but I removed them for brevity\n\\t{ pattern = { \"```lobster\", \"```\" },\\ttype = \"string\", syntax = \".lobster\" },\n\\t{ pattern = { \"```\", \"```\" },\\ttype = \"string\" },\n\\t{ pattern = { \"``\", \"``\" },\\ttype = \"string\" },\n\\t{ pattern = { \"%f[\\\\`]%`[%S]\", \"`\" },\\ttype = \"string\" },\n\\t-- strike\n\\t{ pattern = { \"~~\", \"~~\" },\\ttype = \"keyword2\" },\n\\t-- highlight\n\\t{ pattern = { \"==\", \"==\" },\\ttype = \"literal\" },\n\\t-- lines\n\\t{ pattern = \"^%-%-%-+\\n\",\\ttype = \"comment\" },\n\\t{ pattern = \"^%*%*%*+\\n\",\\ttype = \"comment\" },\n\\t{ pattern = \"^___+\\n\",\\ttype = \"comment\" },\n\\t-- bold and italic\n\\t{ pattern = { \"%*%*%*%S\", \"%*%*%*\" },\\ttype = \"markdown_bold_italic\" },\n\\t{ pattern = { \"%*%*%S\", \"%*%*\" },\\ttype = \"markdown_bold\" },\n\\t-- handle edge case where asterisk can be at end of line and not close\n\\t{\n\\tpattern = { \"%f[\\\\%*]%*[%S]\", \"%*%f[^%*]\" },\n\\ttype = \"markdown_italic\"\n\\t},\n\\t-- alternative bold italic formats\n\\t{ pattern = \"^___[%s%p%w]+___%s\" ,\\ttype = \"markdown_bold_italic\" },\n\\t{ pattern = \"^__[%s%p%w]+__%s\" ,\\ttype = \"markdown_bold\" },\n\\t{ pattern = \"^_[%s%p%w]+_%s\" ,\\ttype = \"markdown_italic\" },\n\\t-- heading with custom id\n\\t{\n\\tpattern = \"^#+%s[%w%s%p]+(){()#[%w%-]+()}\",\n\\ttype = { \"keyword\", \"function\", \"string\", \"function\" }\n\\t},\n\\t-- headings\n\\t{ pattern = \"^#+%s.+\\n\",\\ttype = \"keyword\" },\n\\t-- superscript and subscript\n\\t{\n\\tpattern = \"%^()%d+()%^\",\n\\ttype = { \"function\", \"number\", \"function\" }\n\\t},\n\\t{\n\\tpattern = \"%~()%d+()%~\",\n\\ttype = { \"function\", \"number\", \"function\" }\n\\t},\n\\t-- definitions\n\\t{ pattern = \"^:%s.+\",\\ttype = \"function\" },\n\\t-- emoji\n\\t{ pattern = \":[a-zA-Z0-9_%-]+:\",\\ttype = \"literal\" },\n\\t-- images and link\n\\t{\n\\tpattern = \"!?%[!?%[()[\"..in_squares_match..\"]+()%]%(()[\"..in_parenthesis_match..\"]+()%)%]%(()[\"..in_parenthesis_match..\"]+()%)\",\n\\ttype = { \"function\", \"string\", \"function\", \"number\", \"function\", \"number\", \"function\" }\n\\t},\n\\t{\n\\tpattern = \"!?%[!?%[?()[\"..in_squares_match..\"]+()%]?%]%(()[\"..in_parenthesis_match..\"]+()%)\",\n\\ttype = { \"function\", \"string\", \"function\", \"number\", \"function\" }\n\\t},\n\\t-- reference links\n\\t{\n\\tpattern = \"%[()[\"..in_squares_match..\"]+()%] *()%[()[\"..in_squares_match..\"]+()%]\",\n\\ttype = { \"function\", \"string\", \"function\", \"function\", \"number\", \"function\" }\n\\t},\n\\t{\n\\tpattern = \"!?%[%^?()[\"..in_squares_match..\"]+()%]\",\n\\ttype = { \"function\", \"number\", \"function\" }\n\\t},\n\\t-- url's and email\n\\t{\n\\tpattern = \"<[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+%.[a-zA-Z0-9-.]+>\",\n\\ttype = \"function\"\n\\t},\n\\t{ pattern = \"<https?://%S+>\",\\ttype = \"function\" },\n\\t{ pattern = \"https?://%S+\",\\ttype = \"function\" },\n\\t-- optimize consecutive dashes used in tables\n\\t{ pattern = \"%-+\",\\ttype = \"normal\" },\n\\t},\n\\tsymbols = { },\n}\n-- Adjust the color on theme changes\ncore.add_thread(function()\n\\twhile true do\n\\tif initial_color ~= style.syntax[\"keyword2\"] then\n\\tfor _, attr in pairs({\"bold\", \"italic\", \"bold_italic\"}) do\n\\tstyle.syntax[\"markdown_\"..attr] = style.syntax[\"keyword2\"]\n\\tend\n\\tinitial_color = style.syntax[\"keyword2\"]\n\\tend\n\\tcoroutine.yield(1)\n\\tend\nend)\nSyntaxschriftarten (Seit 1.16.10)Die Syntax erlaubt Benutzer verschiedene Schriftarten Stile (Bold, Italic, usw.) für verschiedene Muster zu setzen.\nUm ein Schriftarten Stil von ein Token zu ändern, füge eine Schriftarten bei style.syntax_fonts[token_type] hinzu.\nZum Beispiel:\n-- Wird sorgen, dass jedes \"fancysyntax_fancy_token\" Italic sein wird.\nstyle.syntax_fonts[\"fancysyntax_fancy_token\"] = renderer.font.load(\"myfont.ttf\", 14 * SCALE, { italic = true })\nDas Markdown Beispiele automatisiert dies mit einem for loop.Die Limitationen hier sind dass Schriftarten nicht von anderen Attributen kopiert werden können, also müssen Schriftartenpfade fest codiert werden.\nDer Missbrauch von style.syntax_fonts kann zur langsame Leistung und einen hohen Speicherverbrauch führen.\nDies ist bemerkbar wenn ein Benutzer versucht die Größe des Editors mit ctrl-scroll or ctrl+ and ctrl- zu ändern.\nBitte benutze es in Moderation.Leerzeichen Umgang (v2.1 (Bevorstehend) / master)Normalerweise stellt Lite XL das Muster { pattern = \"%s+\", type = \"normal\" } zu der Syntaxhervorhebung.\nDies verbessert die Leistung drastisch bei Zeilen die mit Leerzeichen (z.B schwer-eingerücke Zeilen)\nDurchs anpassen des Leerzeichens bevor andere Muster muss Lite XL nicht durch die ganze Syntax durchgehen.\nJedoch gibt es Syntaxen die Leerzeichen anpassen müssen (z.B Markdown mit einrückten Codeblocken)\nAlso kann dies deaktiviert werden indem man space_handling to false. stellt.Um die Leerzeichen Umgang Optimisierung zu behalten, oder um ältere Versionen von Lite XL zu unterstützen kann\n{ pattern = \"%s+\", type = \"normal\" } nach Muster, die Leerzeichen brauchen hinzugefügt werden.Einfache Muster mit mehrere Tokens (1.16.10)Dies ist ein Ausschnitt dass von der Markdown Syntaxhervorhebung genommen wurde:local in_squares_match = \"^%[%]\"\n-- reference links\n{\n\\tpattern = \"^%s*%[%^()[\"..in_squares_match..\"]+()%]: \",\n\\ttype = { \"function\", \"number\", \"function\" }\n},\nManchmal macht es Sinn verschiedene Teile eines Musters anderst zu hervorheben.\nLeere Klammer (()) in Lua Muster werden die Position vom Text in den Klammern zurückgeben.\nDies wird Lite XL sagen, wenn es den Typ des Tokens ändern muss.\nZum Beispiel, ^%s*%[%^ ist \"function\", [\"..in_squares_match..\"]+ ist \"number\" und %]: ist \"function\".Subsyntaxen (Seit 1.16.10)Lite XL unterschützt Einbettung von anderen Syntaxen in einer existierenden Syntax.\nDies kann benutzt werden, um Codeblöcke im Markdown Syntax zu Unterstützen.Zum Beispiel:\nlua\n{ pattern = { \"cpp\", \"\" },\\ttype = \"string\", syntax = \".cpp\" },\nDies würde `` cpp `` und `` `mit\"string\"markieren während alles innerhalb mit der Syntax dass mit\".cpp\"` übereinstimmt markiert wird."},{"id":"de/tutorials/system-fonts.html","title":"Lite XL - Systemschriftarten Benutzen","category":["tutorials"],"content":"Systemschriftarten BenutzenLite XL bietet keinen Weg um Schriftarten vom System zu benutzen.\nWeil jede Platform die wir unterstützen (Windows, Linux und Mac) es anders macht.\nHier kommt fontconfig zur Rettung. fontconfig kann man auf verschiedene Betriebssysteme installieren.lite-xl hat ein fontconfig Plugin dass wir benutzen können um Systemschriftarten zu finden.fontconfig InstallierenWindowsmingw-w64-fontconfig bietet einen Build, der direkt auf Windows benutzt werden kann.\nLade die Datei herunter, extrahiere es irgendwo und (optional) füge es zu den PATH hinzu.LinuxÜberprüfe distro-spezifische Anweisungen.# ubuntu / debian\napt install fontconfig\n# arch\npacman -Su fontconfig\n# fedora\ndnf install fontconfig\n...\nMacOSbrew install fontconfig\nEinstellenInstalliere das Plugin\nGebe es in dein Benutzer Modul:\nlocal fontconfig = require \"plugins.fontconfig\"\nfontconfig.use {\n\\tfont = { name = \"sans\", size = 13 * SCALE },\n\\tcode_font = { name = \"monospace\", size = 13 * SCALE }\n}\n\"sans\" und \"monospace\" kann eine beliebige fontconfig Syntax sein. (sehe \"Font Names\")Beachte: Die Schriftart könnte nicht sofort laden (Weil wir auf fc-match warten müssen).\nWenn du es so haben willst, dann ersetze fontconfig.use mit fontconfig.use_blocking. Wenn du dass machst dann\nmuss lite-xl auf fc-match warten, was viel langsamer sein kann."},{"id":"en/404.html","title":"Lite XL - Not Found","category":[],"content":"Not FoundThis page couldn't be found. Please note, that the site is undergoing testing at present, so pages may be missing/moved."},{"id":"en/about/contributors.html","title":"Lite XL - Contributors","category":["about"],"content":"Contributors"},{"id":"en/about/faq.html","title":"Lite XL - FAQ","category":["about"],"content":"FAQCan I get smart autocompletion (intellisense/LSP)?Check out the LSP plugin.Where is the integrated terminal?You can try lite-xl-terminal.Tabs and indent size?In your user config (the cog icon in the file tree):config.tab_type = \"soft\" -- soft for spaces, hard for real tabs (\\t)\nconfig.indent_size = 4\\t-- 4 spaces\nHow to bind commands to keys?local keymap = require \"core.keymap\"\nkeymap.add { [\"ctrl+escape\"] = \"core:quit\" }\nHow to unbind commands for certain keys?-- the second parameter lets you override commands for certain keys\n-- in this case it maps it to nothing\nkeymap.add({ [\"ctrl+escape\"] = {} }, true)\nHow to get commands for those keybinds?You can search for commands in the command palette.For each command, replace the spaces in the right side with dashes.For example: Core: Find Command → core:find-commandWhat version of Lua does Lite XL use?Lua 5.4.Vim mode?You need to vibe.Plugin recommendationsJust in case you don't want to comb through our plugin repository,\nthese are a list of plugins that just makes Lite XL a lot more pleasant.Where's feature X? How about Y?You can get more info in the Features page."},{"id":"en/about/features.html","title":"Lite XL - Features","category":["about"],"content":"FeaturesCurrently, Lite XL offers a lot of features out of the box.Cross-PlatformWe currently support Windows, Linux and MacOS (with Retina display support).LightweightWe are currently around 3MB in size and takes about 10MB in RAM (can be lower). No Electron / WebView involved. The whole thing is just Lua running on a rendering engine.ExtensibleWhile the editor is minimal by default, it is very extensible using Lua. In fact, a lot of features are provided by plugins. For example, VSC-like intellisenseBetter font renderingThe editor looks good in screen of any sizes. Some other options are also configurable, such as hinting and antialiasing.Multi-cursor editingYou can now place multiple cursors by ctrl + lclick on lines or ctrl + shift + up or ctrl + shift + down.Here are some features that aren't implemented with the rationales behind it.\nSome of these may be implemented via plugins.\nWe encourage you to give it a shot.Hardware accelerated renderingtl;dr -\\tfranko stated that he isn't considering using OpenGL due to the skills and work involved.Hardware acceleration was brought up in this discussion.\nTakase had made 2 attempts at this - at first using NanoVG and then forcing SDL to use GPU rendering.\nIn both attempts, the performance gains at best is negligible, while at worst its completely unusable.\nRight now, we decided to focus on optimizing the software renderer and various part of Lua code.System fontsThis is painful because various systems has their own mechanism of managing fonts.\nFor now, users can use the fontconfig plugin.\nFontconfig is widely available on Linux and installable on MacOS, while Windows builds are available.\nIn the future, we might consider adding API to read font metadata, allowing us to write a fontconfig alternative in Lua. (no promises here)Opening UNC paths on Windows (network drives, accessing WSL2 files from Windows)Our path handling code can only handle POSIX and Windows paths.\nWe also aren't sure how Lite XL will behave in these scenarios.Inter-window communication (dragging tabs between windows and other magic)This is by far the hardest to achieve.\nLite XL has no intention to link to any widget toolkits (Qt and GTK) which are required for these features.\nAn alternative approach is to create our own IPC mechanism, but that's reinventing the wheel.Integrated terminalA terminal is complex to implement.\nThere are projects that can be ported to Lua, such as xterm.js.\nIf someone is interested, they can do so."},{"id":"en/about/index.html","title":"Lite XL - About","category":["about"],"content":"AboutThese pages contain information about Lite XL's features, screenshots and developers. It also contains a FAQ section.Contributors\nFAQ\nFeatures\nScreenshots"},{"id":"en/about/screenshots.html","title":"Lite XL - Screenshots","category":["about"],"content":"Screenshots![Screenshot 1](/assets/img/editor.png)\n![Screenshot 2](/assets/img/editor2.png)"},{"id":"en/documentation/build.html","title":"Lite XL - Build","category":["documentation"],"content":"BuildOnce you have downloaded the source code, you can build Lite XL yourself using Meson.\nIn addition, the build-packages.sh script can be used to compile Lite XL and\ncreate an OS-specific package for Linux, Windows or macOS.The following libraries are required:freetype2\nSDL2\nThe following libraries are optional:libagg\nLua 5.2\nIf they are not found, they will be downloaded and compiled by Meson.\nOtherwise, if they are present, they will be used to compile Lite XL.Build ScriptIf you compile Lite XL yourself,\nit is recommended to use the script build-packages.sh:bash build-packages.sh -h\nThe script will run Meson and create a tar compressed archive with the application or,\nfor Windows, a zip file. Lite XL can be easily installed\nby unpacking the archive in any directory of your choice.On Windows two packages will be created, one called \"portable\" using the \"data\"\nfolder next to the executable and the other one using a unix-like file layout.\nBoth packages works correctly. The one with unix-like file layout is meant\nfor people using a unix-like shell and the command line.Please note that there aren't any hard-coded directories in the executable,\nso that the package can be extracted and used in any directory.PortableWhen performing the meson setup command you may enable the -Dportable=true\noption to specify whether files should be installed as in a portable application.If portable is enabled, Lite XL is built to use a data directory placed next\nto the executable.\nOtherwise, Lite XL will use unix-like directory locations.\nIn this case, the data directory will be $prefix/share/lite-xl\nand the executable will be located in $prefix/bin.\n$prefix is determined when the application starts as a directory such that\n$prefix/bin corresponds to the location of the executable.The user directory does not depend on the portable option and will always be\n$HOME/.config/lite-xl.\n$HOME is determined from the corresponding environment variable.\nAs a special case on Windows the variable $USERPROFILE will be used instead.LinuxOn Debian-based systems the required libraries and Meson can be installed\nusing the following commands:# To install the required libraries:\nsudo apt install libfreetype6-dev libsdl2-dev\n# To install Meson:\nsudo apt install meson\n# or pip3 install --user meson\nTo build Lite XL with Meson the commands below can be used:meson setup --buildtype=release --prefix <prefix> build\nmeson compile -C build\nDESTDIR=\"$(pwd)/lite-xl\" meson install --skip-subprojects -C build\nwhere <prefix> depends on the OS you are using:\n- on Linux is /usr\n- on macOS application bundle can be \"/Lite XL.app\"If you are using a version of Meson below 0.54\nyou need to use diffent commands to compile and install:meson setup --buildtype=release build\nninja -C build\nninja -C build install\nmacOSmacOS is fully supported and a notarized app disk image is provided in the\nrelease page. \nIn addition the application can be compiled using the generic instructions given above.Windows MSYS2The build environment chosen for Lite XL on Windows is MSYS2.\nFollow the install instructions in the link.Open MinGW 64-bit or MinGW 32-bit shell from the start menu.\nUpdate the MSYS2 installation with pacman -Syu\nRestart the shell\nInstall the dependencies:\npacman -S \\\n\\t${MINGW_PACKAGE_PREFIX}-freetype \\\n\\t${MINGW_PACKAGE_PREFIX}-gcc \\\n\\t${MINGW_PACKAGE_PREFIX}-ninja \\\n\\t${MINGW_PACKAGE_PREFIX}-pcre2 \\\n\\t${MINGW_PACKAGE_PREFIX}-pkg-config \\\n\\t${MINGW_PACKAGE_PREFIX}-python-pip \\\n\\t${MINGW_PACKAGE_PREFIX}-SDL2\npip3 install meson\n${MINGW_PACKAGE_PREFIX} expands either to mingw-w64-i686 or mingw-w64-x86_64\ndepending if the current shell is 32 or 64 bit."},{"id":"en/documentation/index.html","title":"Lite XL - Documentation","category":["documentation"],"content":"DocumentationThese pages contain documentation to build, run and use Lite XL.Build\nKeymap (MacOS)\nKeymap\nUsage"},{"id":"en/documentation/keymap-macos.html","title":"Lite XL - MacOS Keymap","category":["documentation"],"content":"MacOS KeymapKeymaps on different operating systems have the same functionality, just bound slightly differently\nin order to conform to normal expectations for that operating system.Currently, there are only two operating system layouts. MacOS, and everything else.Keymap"},{"id":"en/documentation/keymap.html","title":"Lite XL - Default Keymap","category":["documentation"],"content":"Default KeymapKeymaps on different operating systems have the same functionality, just bound slightly differently\nin order to conform to normal expectations for that operating system.Currently, there are only two operating system layouts. MacOS, and everything else.Keymap"},{"id":"en/documentation/usage.html","title":"Lite XL - Usage","category":["documentation"],"content":"UsageLite XL is a lightweight text editor written mostly in Lua — it aims to provide\nsomething practical, pretty, small and fast, implemented as simply as\npossible; easy to modify and extend, or to use without doing either.Lite XL is based on the Lite editor and provide some enhancements\nwhile remaining generally compatible with it.Getting StartedLite XL works using a project directory — this is the directory where your\nproject's code and other data resides.To open a specific project directory the directory name can be passed\nas a command-line argument (. can be passed to use the current directory)\nor the directory can be dragged onto either the executable or a running instance.Once started the project directory can be changed using the command\ncore:change-project-folder. The command will close all the documents\ncurrently opened and switch to the new project directory.If you want to open a project directory in a new window the command\ncore:open-project-folder will open a new editor window with the selected\nproject directory.The main way of opening files in Lite XL is through the core:find-file command\n— this provides a fuzzy finder over all of the project's files and can be\nopened using the ctrl+p shortcut by default.Commands can be run using keyboard shortcuts, or by using the core:find-command\ncommand bound to ctrl+shift+p by default. For example, pressing\nthe above combination and typing newdoc then pressing return\nwould open a new document. The current keyboard shortcut for a command\ncan be seen to the right of the command name on the command finder, thus to find\nthe shortcut for a command ctrl+shift+p can be pressed\nand the command name typed.User Data DirectoriesLite XL uses standard systems user directories; the user data can be found in\n$HOME/.config/lite-xl on Linux and macOS.\nOn Windows, the variable $USERPROFILE will be used instead of\n$HOME.User ModuleLite XL can be configured through use of the user module. The user module can be\nused for changing options in the config module, adding additional key bindings,\nloading custom color themes, modifying the style or changing any other part of\nthe editor to your personal preference.The user module is loaded when the application starts,\nafter the plugins have been loaded.The user module can be modified by running the core:open-user-module command\nor otherwise directly opening the $HOME/.config/lite-xl/init.lua file.On Windows, the variable $USERPROFILE will be used instead of\n$HOME.tl;dr:Windows: C:\\Users\\(username)\\.config\\lite-xl\\init.lua\nMacOS: /Users/(usernmame)/.config/lite-xl/init.lua\nLinux: /home/(username)/.config/lite-xl/init.lua\nThese aren't the exact location, but it gives you an idea where to find.Please note that Lite XL differs from the standard Lite editor for the location\nof the user's module.Project ModuleThe project module is an optional module which is loaded from the current\nproject's directory when Lite XL is started. Project modules can be useful for\nthings like adding custom commands for project-specific build systems, or\nloading project-specific plugins.The project module is loaded when the application starts,\nafter both the plugins and user module have been loaded.The project module can be edited by running the core:open-project-module\ncommand — if the module does not exist for the current project when the\ncommand is run it will be created.Add directories to a projectIn addition to the project directories it is possible to add other directories\nusing the command core:add-directory.\nOnce added a directory it will be shown in the tree-view on the left side and\nthe additional files will be reachable using the ctrl+p command (find file).\nThe additonal files will be also visible when searching across the project.The additional directories can be removed using the command core:remove-directory.When you will open again Lite XL on the same project folder the application will\nremember your workspace including the additonal project directories.Since version 1.15 Lite XL does not need a workspace plugin as it is now\nbundled with the editor.Create new empty directoryUsing the command files:create-directory or control-click in a directory in the\ntree-view to create a new empty subdirectory.CommandsCommands are used both through the command finder (ctrl+shift+p) and\nby Lite XL's keyboard shortcut system. Commands consist of 3 components:Name — The command name in the form of namespace:action-name, for\nexample: doc:select-all\nPredicate — A function that returns true if the command can be ran, for\nexample, for any document commands the predicate checks whether the active\nview is a document\nFunction — The function which performs the command itself\nCommands can be added using the command.add function provided by the\ncore.command module:local core = require \"core\"\nlocal command = require \"core.command\"\ncommand.add(\"core.docview\", {\n\\t[\"doc:save\"] = function()\n\\tcore.active_view.doc:save()\n\\tcore.log(\"Saved '%s'\", core.active_view.doc.filename)\n\\tend\n})\nCommands can be performed programatically (eg. from another command or by your\nuser module) by calling the command.perform function after requiring the\ncommand module:local command = require \"core.command\"\ncommand.perform \"core:quit\"\nKeymapAll keyboard shortcuts are handled by the core.keymap module.\nA key binding maps a \"stroke\" (eg. ctrl+q) to one or more commands\n(eg. core:quit). When the shortcut is pressed Lite XL will iterate each command\nassigned to that key and run the predicate function for that command — if the\npredicate passes it stops iterating and runs the command.An example of where this used is the default binding of the tab key:\\t[\"tab\"] = { \"command:complete\", \"doc:indent\" },\nWhen tab is pressed the command:complete command is attempted which will only\nsucceed if the command-input at the bottom of the window is active. Otherwise\nthe doc:indent command is attempted which will only succeed if we have a\ndocument as our active view.A new mapping can be added by your user module as follows:local keymap = require \"core.keymap\"\nkeymap.add { [\"ctrl+q\"] = \"core:quit\" }\nA list of default mappings can be viewed here.Global variablesThere are a few global variables set by the editor.\nThese variables are available everywhere and shouldn't be overwritten.ARGS: command-line arguments. argv[1] is the program name, argv[2] is the 1st parameter, ...\nPLATFORM: Output from SDL_GetPlatform(). Can be Windows, Mac OS X, Linux, iOS and Android.\nSCALE: Font scale. Usually 1, but can be higher on HiDPI systems.\nEXEFILE: An absolute path to the executable.\nEXEDIR: The executable directory. DO NOT WRITE TO THIS DIRECTORY.\nVERSION: lite-xl version.\nMOD_VERSION: mod-version used in plugins. This is usually incremented when there are API changes.\nPATHSEP: Path seperator. \\ (Windows) or / (Other OSes)\nDATADIR: The data directory, where the Lua part of lite-xl resides. DO NOT WRITE TO THIS DIRECTORY.\nUSERDIR: User configuration directory.\nUSERDIR should be used instead of DATADIR when configuring the editor\nbecause DATADIR might not be writable.\n(for example, if the editor is installed in /usr, DATADIR will be /usr/share/lite-xl!)\nUSERDIR on the other hand should always be writable for the user, and allows multiple users to customize\ntheir own editor.PluginsPlugins in Lite XL are normal lua modules and are treated as such — no\ncomplicated plugin manager is provided, and, once a plugin is loaded, it is never\nexpected be to have to unload itself.To install a plugin simply drop it in the plugins directory in the user\nmodule directory.\nWhen Lite XL starts it will first load the plugins included in the data directory\nand will then loads the plugins located in the user module directory.To uninstall a plugin the plugin file can be deleted — any plugin\n(including those included with the default installation)\ncan be deleted to remove its functionality.If you want to load a plugin only under a certain circumstance (for example,\nonly on a given project) the plugin can be placed somewhere other than the\nplugins directory so that it is not automatically loaded. The plugin can\nthen be loaded manually as needed by using the require function.Plugins can be downloaded from the plugins repository.Restarting the editorIf you modify the user configuration file or some of the Lua implementation files\nyou may restart the editor using the command core:restart.\nThe entire application will be restarting by keeping the window that is already in use.Color ThemesColors themes in Lite XL are lua modules which overwrite the color fields of\nLite XL's core.style module.\nPre-defined color methods are located in the colors folder in the data directory.\nAdditional color themes can be installed in the user's directory in a folder named\ncolors.A color theme can be set by requiring it in your user module:core.reload_module \"colors.winter\"\nIn the Lite editor the function require is used instead of core.reload_module.\nIn Lite XL core.reload_module should be used to ensure that the color module\nis actually reloaded when saving the user's configuration file.Color themes can be downloaded from the color themes repository.\nThey are included with Lite XL release packages."},{"id":"en/downloads.html","title":"Lite XL - Downloads","category":[],"content":"DownloadsBinary packagesBinary packages are available on the GitHub releases page.Install via package managementAlternatively, you can install lite-xl from your distribution's package manager.\nThese packages are maintained by the community and may be outdated.Windows (Chocolatey / Scoop)\nMac OS (MacPorts)\nArch Linux (AUR)\nNixOS (nixpkgs)\nFedora\nchoco install lite-xl\\t# chocolatey\nscoop bucket add extras && scoop install lite-xl\\t# scoop\nsudo port install lite-xl\\t# macports\nyay -S lite-xl\\t# or your favorite AUR helper\nnix-env -i lite-xl\\t# nixos\nsudo dnf install lite-xl\\t# fedora\nSource CodeSource code is available on GitHub, by downloading zip or tar archives,\nor directly via git:git clone https://github.com/lite-xl/lite-xl.git"},{"id":"en/index.html","title":"Lite XL","category":[],"content":"Lite XLA lightweight, simple, fast, feature-filled, and extremely extensible text editor written in C, and Lua, adapted from lite.![Lite XL Editor](/assets/img/editor.png)"},{"id":"en/tutorials/api-overview.html","title":"Lite XL - API Overview","category":["tutorials"],"content":"API OverviewThis is a work in progress.Here we provide some resources and explanation to some API and aspects of Lite XL.\nFor API docs, it's available in the repo\nThus, we'll not explain everything, only the more important and frequently used features.Built-in APIs:Process API\nSystem API\nRegex API"},{"id":"en/tutorials/index.html","title":"Lite XL - Tutorials","category":["tutorials"],"content":"TutorialsThese pages contain tutorials and documentations for building plugins in Lite XL.API Overview\nSimple Plugin\nSyntax Highlighting\nSystem Fonts"},{"id":"en/tutorials/overview/process.html","title":"Lite XL - Process API","category":["tutorials","overview"],"content":"Process APILite XL provides a process API to launch external applications. This API is meant to replace\nlua's io.popen and lite's pipe-to-a-file approach.Advantages of this API includes:Proper argument escaping (arguments are supplied via a table)\nNonblocking IO\nAble to detach processes from Lite XL (in progress)\nDoes not create temporary files\nMostly cross-platform (does not require special code for each shell)\nUsing the Process APIError handlingprocess.start() may throw errors if it cannot run the program.\nprocess.read* and process.write functions may throw errors if\nthe process ended\nthe process closed the stream\nyou closed the stream\nthere might be other errors to look forward to too\nStarting a processTo start a process, use process.start(args, options).Here are some of the more useful arguments.args: The executable and any arguments, eg: { \"sh\", \"-c\", \"echo hello world\" }\noptions: Options for process.start()\nenv: A key-value table containing the env. Note that if this is provided,\n\\tenvironment variables will not be inherited.\nstdin: Specify where to redirect stdin\nstdout: Specify where to redirect stdout\nstderr: Specify where to redirect stderr\nfor options.std{in,out,err}, valid values are:process.REDIRECT_PIPE (Make it available to subprocess API for reading / writing)\nprocess.REDIRECT_DISCARD (Discard the output. Use this to prevent buffering)\nprocess.REDIRECT_STDOUT (stderr only, for redirecting stderr to stdout)\nReading from processTo read from stdout or stderr of a process, use process:read_stdout() and\nprocess:read_stderr() respectively.You can specify a numeric argument to them, which will change the size of internal buffer used\nto read the output.Alternatively, you could use process:read() with process.STREAM_STDERR and process.STREAM_STDOUT.Example:local proc = process.start { \"sh\", \"-c\", \"echo hello world!\" }\n-- do not use `while proc:running()` if you care about output.\n-- The process could die and leave data in the buffer\n-- You should just read until `proc:read_stdout()` returns nil\nwhile true do\n\\tlocal rdbuf = proc:read_stdout()\n\\tif not rdbuf then break end\n\\t-- yay, output\nend\nWriting to processYou can use process:write(data) to write a string to stdin.Checking completionprocess:running() returns a boolean to indicate whether if the process is running.\nprocess:wait(time) also does the same thing, but you specify how long it should wait (or 0 to return immediately).\nTerminating processprocess:terminate() sends SIGTERM (or Windows equivalent) to the process.\nprocess:kill() sends SIGKILL (or Windows equivalent) to the progress.\nUse this only if process:terminate() cannot kill the process, as it can cause issues.\nMiscprocess:pid() returns the PID of the process.\nThere are no guarantees for this PID to be correct if the process terminated early.\nprocess:returncode() returns the exit code of the process, if any\nprocess:close_stream() closes stdin, stdout or stderr stream of the process."},{"id":"en/tutorials/overview/regex.html","title":"Lite XL - Regex API","category":["tutorials","overview"],"content":"Regex APIThis API provides PCRE regular expressions for those who needs more power in matching text.\nThis API written in C and Lua.Creating a regexUse regex.compile(pattern, options) to compile a regex.pattern: The regex pattern\noptions: regex modifiers as a string, eg \"im\"\n\"i\": Case-insensitive search\n\"m\": Multiline search\n\"s\": Match all characters with dot (.), including newlines.\nMatchingLow level functionsregex:cmatch(str, offset, options) low-level matching function\nstr: The string to match against\noffset: Where to start matching\noptions: A bit field of options\nregex.ANCHORED: Only match from the start of the string\nregex.ENDANCHORED: Only match from the end of the string\nregex.NOTBOL: String is not beginning of line\nregex.NOTEOL: String is not the end of line\nregex.NOTEMPTY: Do not match an empty string\nregex.NOTEMPTY_ATSTART: Do not match empty string at the start\nNote: regex:cmatch() returns wrong indexes (currently at version 2.0.2).\n\\tThe end index returned by regex:cmatch() is always off by 1 (-1 to get the actual end index).High level functionsAll the functions below can be in 2 forms:\n- regex:fn(...) where regex is the compiled regex instance\n- regex.fn(pattern, ...) where pattern is a pattern string to be compiled and used directly.We will only document the first form.regex:match(str, offset, options) high level matching function. This function accepts\nthe same arguments as regex:cmatch()\nregex:gsub(str, replacement) replaces matches in str with replacement.\nCapture groups are identified with \\\\0 to \\\\9, this might change in the future."},{"id":"en/tutorials/overview/system.html","title":"Lite XL - System API","category":["tutorials","overview"],"content":"System APIThis is where Lite XL's lua code interact with its underlying C engine.\nSome of the functions here will be omitted because they're not useful for\nplugins.Clipboardsystem.set_clipboard(text) sets the clipboard content.\nsystem.get_clipboard() retrieves the content of the clipboard.\nFile / Directory manipulationsystem.list_dir(dir) returns a list of filenames in a directory.\nsystem.rmdir(dir) removes a directory. Use this instead of os.remove().\nThe directory must be empty.\nsystem.chdir(dir) changes the current working directory (like cd).\nsystem.mkdir(dir) creates a new directory.\nIt does not recursively create directories.\nsystem.absolute_path(path) resolves the path components (.. and .) to an absolute path.\nsystem.get_file_info(path) returns info about a path.\nmodified: last modification time of the file in seconds since UNIX epoch.\nsize: file size in bytes.\ntype: Path type (\"file\" or \"dir\").\nTimingsystem.get_time() returns time in seconds (as floating point number) since Lite XL started.\nUse this instead of os.time() for higher precision timers.\nsystem.sleep(time) sleeps for time in milliseconds.\nDo not use this. Write asynchronous code.\nWindow manipulationsystem.set_window_opacity(o) sets the window opacity from 0 to 1.\nsystem.set_window_title(title) sets the window title.\nsystem.set_window_mode(mode) sets window mode:\n\"normal\": also known as \"restored\" on Windows.\n\"maximized\": Maximize the window.\n\"minimized\": Minimize the window.\n\"fullscreen\": Fullscreen\nsystem.set_window_bordered(bordered) enables or disable window border (decoration).\nsystem.set_window_hit_test(height, control_width, resize_border) sets window hit test (used for\nconfig.borderless to make custom drawn border interactable).\nIf no argument is supplied, reset the hit test values.\nheight: height of the title bar.\ncontrols_width: Not too sure about this, but it should be the size of the title bar controls\n(Maximize, Minimize and Normal buttons on the right).\nIt seems to be fixed at the right side of the title bar.\nresize_border: Number of pixels reserved for resizing the window.\n(setting this to a large value means that you can resize the window way easier)\nsystem.get_window_size() gets the window size.\nsystem.set_window_size(w, h, x, y) sets the window size (and also position).\nsystem.window_has_focus() checks whether the window is in focus.\nsystem.show_fatal_error(title, msg) shows an system error message box.\nUse nagview whenever possible.\nMiscsystem.exec(command) runs a command. Use the Process API instead of this.\nsystem.fuzzy_match(haystack, needle, file) generates a score depends on how close the needle\nmatches the haystack.\nfile: match backwards (more accurate for filename matching)."},{"id":"en/tutorials/simple-plugin.html","title":"Lite XL - Simple Plugin","category":["tutorials"],"content":"Simple PluginWhat is Simple?Simple is a very basic plugin written with the intention of introducing developers\nwho are new to Lite XL to the process of writing plugins for the editor.What does the plugin do?The plugin displays a message (that is taken as input from the user) at the top\nright corner of the editor window. It also allows the user to toggle\nthe visibility of the message.I can't write Lua!If you come from other programming languages, take a look at Lua cheatsheet.\nIf you're new to programming, you can read this.Format of the tutorialThe code contains comments detailing what most (if not all)\nof the code in the file does.The code :-- mod-version:3\n-- you MUST put mod-version:x on the first line of your plugin\n-- mod-version usually maps to lite-xl releases (eg. mod-version: 2 == lite-xl 2.0)\n-- lite-xl won't load the plugin if the mod-version mismatches\n-----------------------------------------------------------------------\n-- NAME\\t: Simple\n-- DESCRIPTION: A simple guide on how to make your first Lite XL plugin\n-- AUTHOR\\t: Ashwin Godbole (aelobdog)\n-- GOALS\\t: To render some text inside the editor\n-----------------------------------------------------------------------\n-- Disclaimer :\n-- I am not a lua developer, and my knowledge about writing plugins for\n-- Lite XL is very limited. This file serves the purpose of helping the\n-- reader get started with plugin development for Lite XL, and therefore\n-- demonstrates only some very basic features. For more complex plugin\n-- development, be sure to check out the source code of some other\n-- plugins after going through this file.\n-----------------------------------------------------------------------\n-- Before we start writing any code for the plugin, we must import the\n-- required modules from the \"core\" package.\n-- the \"core\" module\nlocal core = require \"core\"\n-- the \"command\" module will help us register commands for our plugin.\nlocal command = require \"core.command\"\n-- the \"style\" module will allow us to use styling options\nlocal style = require \"core.style\"\n-- the \"config\" module will be used to store certain things like colors\n-- and functions\nlocal config = require \"core.config\"\n-- the \"keymap\" module will allow us to set keybindings for our commands\nlocal keymap = require \"core.keymap\"\n-- since we want to modify RootView, we'll need to require it first\nlocal RootView = require \"core.rootview\"\n-----------------------------------------------------------------------\n-- per-plugin config must stay in config.plugins.(plugin name)\nconfig.plugins.simple = {}\n-- colors are just three or four comma separated values (RGBA) (range 0 - 255)\n-- put inside of '{ }'. We will add our color to the config module.\nconfig.plugins.simple.text_color = {200, 140, 220} -- or use `{ common.color \"#C88CDC\" }`\n-----------------------------------------------------------------------\n-- Let's create a function to calculate the coordinates of our text.\n-- While we're at it, let's add our function to the `config` module.\n-- We'll take the message we want to display as the argument to the\n-- function to determine the x and y coordinates of the text.\nfunction config.plugins.simple.get_text_coordinates(message)\n\\t-- For this plugin, we want to display the text on the top right\n\\t-- corner of the screen. For this, we need to know the editor's width\n\\t-- and height.\n\\t-- The current font's size can be obtained from the \"style\" module.\n\\t-- The editor's dimensions can be obtained by\n\\t--\\t1. WIDTH\\t: core.root_view.size.x\n\\t--\\t2. HEIGHT : core.root_view.size.y\n\\tlocal message_width = style.code_font:get_width(message..\" \")\n\\tlocal font_height = style.code_font:get_size()\n\\tlocal x = core.root_view.size.x - message_width\n\\tlocal y = font_height / 2\n\\treturn x, y\nend\n-----------------------------------------------------------------------\n-- Let's now get to actually drawing the text inside the editor.\n-- In order to \"inject\" our own code to draw text,\n-- we'll need to save the original draw function\n-- We'll save `RootView.draw` to a variable we call `parent_draw`\nlocal parent_draw = RootView.draw\n-- Now let's overload the original definition of `draw` in RootView\n-- by redefining the function.\nfunction RootView:draw()\n\\t-- We call the parent's function to keep the editor functional...\n\\t-- obviously we must still draw all the other stuff !\n\\t-- So we call the `parent_draw` function before doing anything else.\n\\tparent_draw(self)\n\\t-- we'll add an option to toggle the message on and off. let's use a\n\\t-- boolean variable to keep track of whether we want to display the\n\\t-- message or not.\n\\tif config.plugins.simple.show_my_message then\n\\t-- We'll be getting the message to display as input from the user\n\\t-- later. We'll store that user input in `config.plugins.simple.hw_message`.\n\\t-- (NOTE: this variable does not come in-built in lite-xl;\n\\t--\\tit is a variable that we will define later.)\n\\t-- let's store the value of config.plugins.simple.hw_message in a local variable\n\\t-- `message` in case config.plugins.simple.hw_message we set the message to\n\\t-- \"message not set yet!\"\n\\tlocal message\n\\tif config.plugins.simple.hw_message then\n\\tmessage = config.plugins.simple.hw_message\n\\telse\n\\tmessage = \"Message not set yet !\"\n\\tend\n\\t-- let's get the coordinates for our text\n\\tlocal x, y = config.plugins.simple.get_text_coordinates(message)\n\\t-- let's finally draw the text to the window !\n\\t-- the draw_text function from `renderer` is an important function\n\\t-- as it is used to display any and all text inside of the editor\n\\t-- window\n\\trenderer.draw_text(style.code_font, message, x, y, config.plugins.simple.text_color)\n\\tend\nend\n-----------------------------------------------------------------------\n-- Let's allow the user to turn the message on and off\n-- we'll write a function to flip our \"show\" boolean variable.\nlocal function toggle_helloworld()\n\\tconfig.plugins.simple.show_my_message = not config.plugins.simple.show_my_message\nend\n-----------------------------------------------------------------------\n-- Finally, let's add the toggle function to the command list so that\n-- we can call it from the C-S-p command panel. Let's add one command\n-- to toggle the visibility of the message on and off and one to get\n-- the user's message and then display it.\ncommand.add(nil, {\n\\t-- Toggle the visibility of the message\n\\t[\"simple:toggle\"] = toggle_helloworld,\n\\t-- Set and show the message\n\\t-- This is the way to get user input through the command bar.\n\\t-- `core.command_view:enter` takes 2 arguments:\n\\t--\\t* the prompt to display before taking input\n\\t--\\t* a function that takes the \"input\" as its argument\n\\t-- (NOTE: here the variable we are reading input into is `text`)\n\\t[\"simple:setshow\"] = function()\n\\tcore.command_view:enter(\"Test to display\", {\n\\tsubmit = function(text)\n\\tconfig.plugins.simple.hw_message = text\n\\tconfig.plugins.simple.show_my_message = true\n\\tend\n\\t})\n\\tend\n})\n-----------------------------------------------------------------------\n-- Just for fun, let's assign our commands their own keybindings.\n-- Here, we assign the keybinding the same string(its name) as the one\n-- that we set while creating the command\nkeymap.add {\n\\t[\"alt+s\"] = \"simple:setshow\",\n\\t[\"alt+t\"] = \"simple:toggle\",\n}\nFurther readingLite: An Implementation Overview, an excellent post by rxi that stays mostly relevant to lite-xl.\nAPI overview, where some of the APIs are explained."},{"id":"en/tutorials/syntax-highlighting.html","title":"Lite XL - Syntax Highlighting","category":["tutorials"],"content":"Syntax HighlightingHow to create syntax highlighting plugins for Lite XLSyntax highlighting plugins for Lite XL are Lua files. These define some patterns or regular expressions that\nmatch different parts of a given language, assigning token types to each match.\nThese different token types are then given different colors by your chosen color scheme.Like other plugins, syntax definitions are sourced from the following folders, in order:/usr/share/lite-xl/plugins/\n$HOME/.config/lite-xl/plugins/\nNOTE: The exact location of these folders will depend on your OS and installation method. For example, on Windows, the variable $USERPROFILE will be used instead of $HOME.The user module folder for Lite XL can generally be found in these places on different OSes:Windows: C:\\Users\\(username)\\.config\\lite-xl\nMacOS: /Users/(usernmame)/.config/lite-xl\nLinux: /home/(username)/.config/lite-xl\nSo, to create a new syntax definition on Linux, you can just create a .lua file in your $HOME/.config/lite-xl/plugins/ folder.What syntax token types are supported?The supported syntax token types, defined by lite-xl/core/style.lua, are:normal\nsymbol\ncomment\nkeyword\nkeyword2\nnumber\nliteral\nstring\noperator\nfunction\nIn your syntax highlighting plugin, you write patterns to match parts of the language syntax, assigning these token types to matches. You don't have to use them all - just use as many as you need for your language.Let's walk through an example syntax definition and see how this works.Example syntax: ssh config filesThis is a small, simple example of a syntax definition. It's intended to highlight SSH Config files and looks like this:-- mod-version:2 -- lite-xl 2.0\nlocal syntax = require \"core.syntax\"\nsyntax.add {\n\\tfiles = { \"sshd?/?_?config$\" },\n\\tcomment = '#',\n\\tpatterns = {\n\\t{ pattern = \"#.*\\n\",\\ttype = \"comment\"\\t},\n\\t{ pattern = \"%d+\",\\ttype = \"number\"\\t},\n\\t{ pattern = \"[%a_][%w_]*\",\\ttype = \"symbol\"\\t},\n\\t{ pattern = \"@\",\\ttype = \"operator\" },\n\\t},\n\\tsymbols = {\n\\t-- ssh config\n\\t[\"Host\"]\\t= \"function\",\n\\t[\"ProxyCommand\"]\\t= \"function\",\n\\t[\"HostName\"]\\t= \"keyword\",\n\\t[\"IdentityFile\"]\\t= \"keyword\",\n\\t...\n\\t-- sshd config\n\\t[\"Subsystem\"]\\t= \"keyword2\",\n\\t-- Literals\n\\t[\"yes\"]\\t= \"literal\",\n\\t[\"no\"]\\t= \"literal\",\n\\t[\"any\"]\\t= \"literal\",\n\\t[\"ask\"]\\t= \"literal\",\n\\t},\n}\nLet's take each section in turn and see how it works.HeaderThe first line is a Lua comment & tells Lite XL which version this plugin requires. The second imports the core.syntax module\nfor us to use:-- mod-version:2 -- lite-xl 2.0\nlocal syntax = require \"core.syntax\"\nWe then add a syntax definition to lite, using syntax.add {...}. The contents of this definition are covered next.FilesThe files property tells Lite XL which files this syntax should be used for. This is a Lua pattern that matches against the full path of the file being opened. For example, to match against Markdown files - with either a .md or a .markdown extension,\nyou could do this:files = { \"%.md$\", \"%.markdown$\" },\nIn our original example, we match against the end of the path rather than the extension, because SSH config files don't have extensions - and we don't want to match all config files. We expect the path for SSH config files to look something like one of these:~/.ssh/config\n/etc/ssh/ssh_config\n/etc/ssh/sshd_config\nThis pattern matches paths that look like that:files = { \"sshd?/?_?config$\" },\nCommentThe comment property doesn't define which parts of the syntax are comments - see Patterns for that, below. This property tells Lite XL which character to insert at the start of selected lines when you press ctrl+/.\nYou can also use block_comment to tell Lite XL how to create multiline / block comments.PatternsA given piece of text can only match one pattern. Once Lite XL decides that a piece of text matches a pattern, it will assign that token type to that piece and move on.\nPatterns are tested in the order that they are written in the syntax definition, so the first match will win.Each pattern takes one of the following forms:Simple Pattern{ pattern = \"#.*\\n\",\\ttype = \"comment\" },\nThis form matches the line against the pattern and if it matches, assigns the matching text to the given token type - comment, in this case.Start & End Pattern{ pattern = { \"%[\", \"%]\" }, type = \"keyword\" },\nThis form has two patterns - one that matches against the start of the range and one that matches against the end. Everything between the start and the end will be assigned the given token type.Start & End Pattern, with Escape{ pattern = { '\"', '\"', '\\\\' }, type = \"string\" },\nThis is the same as the previous form, but with an extra, third parameter.\nThe 3rd part, the '\\\\' part in this example, specifies the character that allows escaping the closing match.For more on Lua Patterns, see: Lua Pattern ReferenceIf you need to use PCRE Regular Expressions, instead of Lua Patterns, you can use the regex keyword here, instead of pattern.SymbolsThis is not related to the symbol token type.The symbols section allows you to assign token types to particular keywords or strings - usually reserved words in the language you are highlighting.\nThe token type in this section always take precedence over token types declared in patterns.For example this highlights Host using the function token type, HostName as a keyword and yes, no, any & ask as a literal:[\"Host\"]\\t= \"function\",\n[\"HostName\"]\\t= \"keyword\",\n[\"yes\"]\\t= \"literal\",\n[\"no\"]\\t= \"literal\",\n[\"any\"]\\t= \"literal\",\n[\"ask\"]\\t= \"literal\",\nTips: double check your patterns!There are a few common mistakes that can be made when using the symbols table in conjunction with patterns.Case 1: Spaces between two symbols tokensLet's have an example:{ pattern = \"[%a_][%w_]+%s+()[%a_][%w_]+\", type = { \"keyword2\", \"symbol\" } }\nLet's explain the pattern a bit (omitting the empty parentheses):[%a_] = any alphabet and underscore\n[%w_] = any alphabet, numbers and underscore\n%s = any whitespace character\nWORD =\n\\t[%a_] followed by (1 or more [%w_])\npattern =\n\\tWORD followed by (one or more %s) followed by WORD\nAfterwards, you add an entry [\"my\"] = \"literal\" in the symbols table.\nYou test the syntax with my function found that \"my\" isn't highlighted as literal. Why did that happen?**symbols table requires an exact match.\nIf you look carefully, the empty parentheses (()) is placed **after the space!\nThis tells Lite XL that WORD followed by (one or more %s) is a token, which will match my (note the space in the match).The fix is to add a normal token for the whitespace between the two tokens:{ pattern = \"[%a_][%w_]+()%s+()[%a_][%w_]+\", type = { \"keyword2\", \"normal\", \"symbol\" } }\nCase 2: Patterns & symbols tokensOne might assume that Lite XL magically matches text against the symbols table. This is not the case.In some languages, people may add a generic pattern to delegate the matching to the symbols table.{ pattern = \"[%a_][%w_]*\", \"symbol\" }\nHowever, the symbols table may look like this:symbols = {\n\\t[\"my-symbol\"] = \"function\",\n\\t[\"..something_else\"] = \"literal\"\n}\n\"my-symbol contains a dash (-) and \"..something_else\" contains 2 dots (.).\nNone of the characters are matched by [%a_][%w_]*!Beware of the text you intend to match in the symbols table.\nIf you want to use it, you need to ensure that it can matched by one of the patterns.The correct patterns are:{ pattern = \"[%a_][%w%-_]*\", \"symbol\" },\n{ pattern = \"%.%.[%a_][%w_]*\", \"symbol\" },\nTesting Your New SyntaxTo test your new syntax highlighting you need to do two things:Reload the Lite XL core\nLoad a file in your chosen language and see how it looks\nTo reload the core, you can either restart Lite XL, or reload the core from the command palette, without needing to restart.\nTo do this, type ctrl+shit+p to show the command palette, then select Core: Restart (or type crr or something similar to match it), then press Enter. You will need to restart the core after any changes you make to the syntax highlighting definition.Example advanced syntax: MarkdownNote: This example has features from 2.1. It is not compatible with older versions of lite-xl.Not all languages are as simple as SSH config files. Markup languages like HTML and Markdown are especially hard to parse correctly. Here's the markdown syntax file in its full glory:-- mod-version:3\nlocal syntax = require \"core.syntax\"\nlocal style = require \"core.style\"\nlocal core = require \"core\"\nlocal initial_color = style.syntax[\"keyword2\"]\n-- Add 3 type of font styles for use on markdown files\nfor _, attr in pairs({\"bold\", \"italic\", \"bold_italic\"}) do\n\\tlocal attributes = {}\n\\tif attr ~= \"bold_italic\" then\n\\tattributes[attr] = true\n\\telse\n\\tattributes[\"bold\"] = true\n\\tattributes[\"italic\"] = true\n\\tend\n\\t-- no way to copy user custom font with additional attributes :(\n\\tstyle.syntax_fonts[\"markdown_\"..attr] = renderer.font.load(\n\\tDATADIR .. \"/fonts/JetBrainsMono-Regular.ttf\",\n\\tstyle.code_font:get_size(),\n\\tattributes\n\\t)\n\\t-- also add a color for it\n\\tstyle.syntax[\"markdown_\"..attr] = style.syntax[\"keyword2\"]\nend\nlocal in_squares_match = \"^%[%]\"\nlocal in_parenthesis_match = \"^%(%)\"\nsyntax.add {\n\\tname = \"Markdown\",\n\\tfiles = { \"%.md$\", \"%.markdown$\" },\n\\tblock_comment = { \"<!--\", \"-->\" },\n\\tspace_handling = false, -- turn off this feature to handle it our selfs\n\\tpatterns = {\n\\t---- Place patterns that require spaces at start to optimize matching speed\n\\t---- and apply the %s+ optimization immediately afterwards\n\\t-- bullets\n\\t{ pattern = \"^%s*%*%s\",\\ttype = \"number\" },\n\\t{ pattern = \"^%s*%-%s\",\\ttype = \"number\" },\n\\t{ pattern = \"^%s*%+%s\",\\ttype = \"number\" },\n\\t-- numbered bullet\n\\t{ pattern = \"^%s*[0-9]+[%.%)]%s\",\\ttype = \"number\" },\n\\t-- blockquote\n\\t{ pattern = \"^%s*>+%s\",\\ttype = \"string\" },\n\\t-- alternative bold italic formats\n\\t{ pattern = { \"%s___\", \"___%f[%s]\" },\\ttype = \"markdown_bold_italic\" },\n\\t{ pattern = { \"%s__\", \"__%f[%s]\" },\\ttype = \"markdown_bold\" },\n\\t{ pattern = { \"%s_[%S]\", \"_%f[%s]\" },\\ttype = \"markdown_italic\" },\n\\t-- reference links\n\\t{\n\\tpattern = \"^%s*%[%^()[\"..in_squares_match..\"]+()%]: \",\n\\ttype = { \"function\", \"number\", \"function\" }\n\\t},\n\\t{\n\\tpattern = \"^%s*%[%^?()[\"..in_squares_match..\"]+()%]:%s+.+\\n\",\n\\ttype = { \"function\", \"number\", \"function\" }\n\\t},\n\\t-- optimization\n\\t{ pattern = \"%s+\",\\ttype = \"normal\" },\n\\t---- HTML rules imported and adapted from language_html\n\\t---- to not conflict with markdown rules\n\\t-- Inline JS and CSS\n\\t{\n\\tpattern = {\n\\t\"<%s*[sS][cC][rR][iI][pP][tT]%s+[tT][yY][pP][eE]%s*=%s*\" ..\n\\t\"['\\\"]%a+/[jJ][aA][vV][aA][sS][cC][rR][iI][pP][tT]['\\\"]%s*>\",\n\\t\"<%s*/[sS][cC][rR][iI][pP][tT]>\"\n\\t},\n\\tsyntax = \".js\",\n\\ttype = \"function\"\n\\t},\n\\t{\n\\tpattern = {\n\\t\"<%s*[sS][cC][rR][iI][pP][tT]%s*>\",\n\\t\"<%s*/%s*[sS][cC][rR][iI][pP][tT]>\"\n\\t},\n\\tsyntax = \".js\",\n\\ttype = \"function\"\n\\t},\n\\t{\n\\tpattern = {\n\\t\"<%s*[sS][tT][yY][lL][eE][^>]*>\",\n\\t\"<%s*/%s*[sS][tT][yY][lL][eE]%s*>\"\n\\t},\n\\tsyntax = \".css\",\n\\ttype = \"function\"\n\\t},\n\\t-- Comments\n\\t{ pattern = { \"<!%-%-\", \"%-%->\" },\\ttype = \"comment\" },\n\\t-- Tags\n\\t{ pattern = \"%f[^<]![%a_][%w_]*\",\\ttype = \"keyword2\" },\n\\t{ pattern = \"%f[^<][%a_][%w_]*\",\\ttype = \"function\" },\n\\t{ pattern = \"%f[^<]/[%a_][%w_]*\",\\ttype = \"function\" },\n\\t-- Attributes\n\\t{\n\\tpattern = \"[a-z%-]+%s*()=%s*()\\\".-\\\"\",\n\\ttype = { \"keyword\", \"operator\", \"string\" }\n\\t},\n\\t{\n\\tpattern = \"[a-z%-]+%s*()=%s*()'.-'\",\n\\ttype = { \"keyword\", \"operator\", \"string\" }\n\\t},\n\\t{\n\\tpattern = \"[a-z%-]+%s*()=%s*()%-?%d[%d%.]*\",\n\\ttype = { \"keyword\", \"operator\", \"number\" }\n\\t},\n\\t-- Entities\n\\t{ pattern = \"&#?[a-zA-Z0-9]+;\",\\ttype = \"keyword2\" },\n\\t---- Markdown rules\n\\t-- math\n\\t{ pattern = { \"%$%$\", \"%$%$\", \"\\\\\"\\t},\\ttype = \"string\", syntax = \".tex\"},\n\\t{ pattern = { \"%$\", \"%$\", \"\\\\\" },\\ttype = \"string\", syntax = \".tex\"},\n\\t-- code blocks\n\\t{ pattern = { \"```c++\", \"```\" },\\ttype = \"string\", syntax = \".cpp\" },\n\\t-- ... there's some other patterns here, but I removed them for brevity\n\\t{ pattern = { \"```lobster\", \"```\" },\\ttype = \"string\", syntax = \".lobster\" },\n\\t{ pattern = { \"```\", \"```\" },\\ttype = \"string\" },\n\\t{ pattern = { \"``\", \"``\" },\\ttype = \"string\" },\n\\t{ pattern = { \"%f[\\\\`]%`[%S]\", \"`\" },\\ttype = \"string\" },\n\\t-- strike\n\\t{ pattern = { \"~~\", \"~~\" },\\ttype = \"keyword2\" },\n\\t-- highlight\n\\t{ pattern = { \"==\", \"==\" },\\ttype = \"literal\" },\n\\t-- lines\n\\t{ pattern = \"^%-%-%-+\\n\",\\ttype = \"comment\" },\n\\t{ pattern = \"^%*%*%*+\\n\",\\ttype = \"comment\" },\n\\t{ pattern = \"^___+\\n\",\\ttype = \"comment\" },\n\\t-- bold and italic\n\\t{ pattern = { \"%*%*%*%S\", \"%*%*%*\" },\\ttype = \"markdown_bold_italic\" },\n\\t{ pattern = { \"%*%*%S\", \"%*%*\" },\\ttype = \"markdown_bold\" },\n\\t-- handle edge case where asterisk can be at end of line and not close\n\\t{\n\\tpattern = { \"%f[\\\\%*]%*[%S]\", \"%*%f[^%*]\" },\n\\ttype = \"markdown_italic\"\n\\t},\n\\t-- alternative bold italic formats\n\\t{ pattern = \"^___[%s%p%w]+___%s\" ,\\ttype = \"markdown_bold_italic\" },\n\\t{ pattern = \"^__[%s%p%w]+__%s\" ,\\ttype = \"markdown_bold\" },\n\\t{ pattern = \"^_[%s%p%w]+_%s\" ,\\ttype = \"markdown_italic\" },\n\\t-- heading with custom id\n\\t{\n\\tpattern = \"^#+%s[%w%s%p]+(){()#[%w%-]+()}\",\n\\ttype = { \"keyword\", \"function\", \"string\", \"function\" }\n\\t},\n\\t-- headings\n\\t{ pattern = \"^#+%s.+\\n\",\\ttype = \"keyword\" },\n\\t-- superscript and subscript\n\\t{\n\\tpattern = \"%^()%d+()%^\",\n\\ttype = { \"function\", \"number\", \"function\" }\n\\t},\n\\t{\n\\tpattern = \"%~()%d+()%~\",\n\\ttype = { \"function\", \"number\", \"function\" }\n\\t},\n\\t-- definitions\n\\t{ pattern = \"^:%s.+\",\\ttype = \"function\" },\n\\t-- emoji\n\\t{ pattern = \":[a-zA-Z0-9_%-]+:\",\\ttype = \"literal\" },\n\\t-- images and link\n\\t{\n\\tpattern = \"!?%[!?%[()[\"..in_squares_match..\"]+()%]%(()[\"..in_parenthesis_match..\"]+()%)%]%(()[\"..in_parenthesis_match..\"]+()%)\",\n\\ttype = { \"function\", \"string\", \"function\", \"number\", \"function\", \"number\", \"function\" }\n\\t},\n\\t{\n\\tpattern = \"!?%[!?%[?()[\"..in_squares_match..\"]+()%]?%]%(()[\"..in_parenthesis_match..\"]+()%)\",\n\\ttype = { \"function\", \"string\", \"function\", \"number\", \"function\" }\n\\t},\n\\t-- reference links\n\\t{\n\\tpattern = \"%[()[\"..in_squares_match..\"]+()%] *()%[()[\"..in_squares_match..\"]+()%]\",\n\\ttype = { \"function\", \"string\", \"function\", \"function\", \"number\", \"function\" }\n\\t},\n\\t{\n\\tpattern = \"!?%[%^?()[\"..in_squares_match..\"]+()%]\",\n\\ttype = { \"function\", \"number\", \"function\" }\n\\t},\n\\t-- url's and email\n\\t{\n\\tpattern = \"<[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+%.[a-zA-Z0-9-.]+>\",\n\\ttype = \"function\"\n\\t},\n\\t{ pattern = \"<https?://%S+>\",\\ttype = \"function\" },\n\\t{ pattern = \"https?://%S+\",\\ttype = \"function\" },\n\\t-- optimize consecutive dashes used in tables\n\\t{ pattern = \"%-+\",\\ttype = \"normal\" },\n\\t},\n\\tsymbols = { },\n}\n-- Adjust the color on theme changes\ncore.add_thread(function()\n\\twhile true do\n\\tif initial_color ~= style.syntax[\"keyword2\"] then\n\\tfor _, attr in pairs({\"bold\", \"italic\", \"bold_italic\"}) do\n\\tstyle.syntax[\"markdown_\"..attr] = style.syntax[\"keyword2\"]\n\\tend\n\\tinitial_color = style.syntax[\"keyword2\"]\n\\tend\n\\tcoroutine.yield(1)\n\\tend\nend)\nSyntax fonts (Since 1.16.10)The syntax allows users to set different font styles (bold, italic, etc.) for different patterns.\nTo change the font style of a token, add a Font to style.syntax_fonts[token_type].\nFor example:\n-- will ensure every \"fancysyntax_fancy_token\" is italic\nstyle.syntax_fonts[\"fancysyntax_fancy_token\"] = renderer.font.load(\"myfont.ttf\", 14 * SCALE, { italic = true })\nThe markdown example automates this with a for loop.The limitations here are that fonts cannot be copied with different attributes, thus the font path has to be hardcoded.\nOther than that, abusing style.syntax_fonts may lead to slow performance and high memory consumption.\nThis is very obvious when the user tries to resize the editor with ctrl-scroll or ctrl+ and ctrl-.\nPlease use it in moderation.Space handling (v2.1 (upcoming) / master)By default, Lite XL prepends a pattern { pattern = \"%s+\", type = \"normal\" } to the syntax.\nThis improves the performance drastically on lines that starts with whitespaces (eg. heavily indented lines)\nby matching the whitespace before other patterns in order to prevent Lite XL from iterating the entire syntax.\nHowever, there may be syntaxes that require matching spaces (eg. Markdown with indented blocks)\nso this can be disabled by setting space_handling to false.To keep the space handling optimization or to support older versions of Lite XL,\n{ pattern = \"%s+\", type = \"normal\" } can be added after patterns that require space.Simple patterns with multiple tokens (v1.16.10)This is an excerpt taken from the markdown plugin:local in_squares_match = \"^%[%]\"\n-- reference links\n{\n\\tpattern = \"^%s*%[%^()[\"..in_squares_match..\"]+()%]: \",\n\\ttype = { \"function\", \"number\", \"function\" }\n},\nSometimes it makes sense to highlight different parts of a pattern differently.\nAn empty parentheses (()) in Lua patterns will return the position of the text in the parentheses.\nThis will tell Lite XL when to change the type of token.\nFor instance, ^%s*%[%^ is \"function\", [\"..in_squares_match..\"]+ is \"number\" and %]: is \"function\".Subsyntaxes (Since v1.16.10)Lite XL supports embedding another syntax into the existing syntax.\nThis is used to support code blocks inside the markdown syntax.For example:\nlua\n{ pattern = { \"cpp\", \"\" },\\ttype = \"string\", syntax = \".cpp\" },\nThis would highlight `` cpp `` and `` `with\"string\"while everything inside them will be highlighted with a syntax that matches\".cpp\"`."},{"id":"en/tutorials/system-fonts.html","title":"Lite XL - Using system fonts","category":["tutorials"],"content":"Using system fontslite-xl does not provide a convenient way to use fonts on the system.\nThere is literally _different APIs for the each platforms we support (Windows, Linux and Mac).\nThis is where fontconfig comes to our rescue. fontconfig is\ninstallable on a lot of OSes.lite-xl has a fontconfig plugin that we can use to find system fonts.Installing fontconfigWindowsmingw-w64-fontconfig provides a build that can be used directly on Windows.\nDownload the file, extract it to somewhere and (optionally) add it to the PATH.LinuxCheck your distro-specific instructions.# ubuntu / debian\napt install fontconfig\n# arch\npacman -Su fontconfig\n# fedora\ndnf install fontconfig\n...\nMacOSbrew install fontconfig\nSetting upInstall the plugin\nPut this in your user module:\nlocal fontconfig = require \"plugins.fontconfig\"\nfontconfig.use {\n\\tfont = { name = \"sans\", size = 13 * SCALE },\n\\tcode_font = { name = \"monospace\", size = 13 * SCALE }\n}\n\"sans\" and \"monospace\" can be any fontconfig syntax. (check \"Font Names\")Note that the font might not load immediately (because we need to wait for fc-match to return.\nIf you want that, replace fontconfig.use with fontconfig.use_blocking. Doing this will force\nlite-xl to wait for fc-match, which can be much slower."},{"id":"es/404.html","title":"Lite XL - No encontrado","category":[],"content":"No encontradoEsta página no existe.\nPor favor, ten en cuenta que la página esta en fase de prueba, así que quizás hayan páginas movidas o faltantes."},{"id":"es/about/contributors.html","title":"Lite XL - Contribuyentes","category":["about"],"content":"Contribuyentes"},{"id":"es/about/faq.html","title":"Lite XL - FAQ","category":["about"],"content":"FAQPuedo tener autocompletación intelligente (intellisense/LSP)?Consigue el plugin LSP.Donde está la terminal integrada?Prueba lite-xl-terminal.Y qué hay de los tabs y el tamaño de la indentación?Escribe en tu configuración de usuario (el icono de engranaje en el árbol de archivos):config.tab_type = \"soft\" -- 'soft' para usar espacios, 'hard' para tabs reales (\\t)\nconfig.indent_size = 4\\t-- 4 espacios\nCómo conecto commandos a ciertas teclas?local keymap = require \"core.keymap\"\nkeymap.add { [\"ctrl+escape\"] = \"core:quit\" }\nCómo desconecto commandos de ciertas teclas?-- el segundo argumento te permite sobreescribir los comandos de ciertas teclas\n-- en este caso, se conecta a nada\nkeymap.add({ [\"ctrl+escape\"] = {} }, true)\nCómo consigo los comandos conectados a esas teclas?Puedes buscar comandos en la paleta de comandos.Para cada comando, reemplaza los espacios del comando con guiones.Por ejemplo: Core: Find Command → core:find-commandQué versión de Lua usa el editor?Lua 5.4.Algún modo que emule a Vim?Consigue vibe.Recomendaciones de plugins?En caso de que no quieras revisar nuestro repositorio de plugins,\nesta es una lista de plugins que hacen a Lite XL más agradable.Donde está tal herramienta? Qué hay de X funcionalidad?Puedes tener más información en la página de características."},{"id":"es/about/features.html","title":"Lite XL - Características","category":["about"],"content":"CaracterísticasPor el momento, Lite XL ofrece un montón de funciones por defecto.Cross-PlatformTenemos ejecutables para Windows, Linux y MacOS (con soporte para pantallas Retina).LigeroEl editor pesa 3MB y usa 10MB de RAM (y posiblemente menos).\nNo usamos Electron o WebView. Es solo Lua corriendo en un motor de renderizado.ExtensibleMientras que el editor es mínimo por defecto, es muy extensible con Lua.\nDe hecho, muchas funciones se proveen a través de plugins. Por ejemplo,\nintellisense parecido al de VSCBetter font renderingEl editor se ve increíble en pantallas de cualquier tamaño.\nTambién hay opciones configurables, como hinting y antialiasing.Multi-cursor editingPuedes crear múltiples cursores usando ctrl + lclick sobre cualquier linea\no ctrl + shift + up o ctrl + shift + down.Estas son algunas funciones que no han sido implementadas junto a sus razones.\nAlgunos de estos pueden ser implementados vía plugins.\nTe alentamos a que lo intentes.Renderizado acelerado por hardwaretl;dr -\\tfranko ha dicho que no planea usar OpenGL debido a las habilidades y el trabajo que implica.Se sugirió la aceleración por hardware en esta discusión.\nTakase intentó hacerlo 2 veces - primero usando NanoVG\ny luego forzando a SDL a usar el renderizado por GPU.\nEn ambos intentos, las ganancias de rendimiento en el mejor de los casos son insignificantes,\nmientras que en el peor de los casos el editor se vuelve completamente inutilizable.\nHemos decidido optimizar el renderizador de software y varias partes del código en Lua por el momento.Fuentes del sistema.Esto es dificil ya que varios sistemas tienen su propio mecanismo para manejar fuentes.\nPor ahora, los usuarios pueden probar el plugin fontconfig.\nFontconfig esta disponible en Linux e instalable en MacOS,\nmientras que hay ejecutables disponibles para Windows.\nEn el futuro, quizá consideremos agregar API para leer metadatos de fuentes, lo que nos permitirá escribir\nuna alternativa a fontconfig en Lua. (no prometemos nada :P)Opening UNC paths on Windows (network drives, accessing WSL2 files from Windows)Our path handling code can only handle POSIX and Windows paths.\nWe also aren't sure how Lite XL will behave in these scenarios.Inter-window communication (dragging tabs between windows and other magic)This is by far the hardest to achieve.\nLite XL has no intention to link to any widget toolkits (Qt and GTK) which are required for these features.\nAn alternative approach is to create our own IPC mechanism, but that's reinventing the wheel.Integrated terminalA terminal is complex to implement.\nThere are projects that can be ported to Lua, such as xterm.js.\nIf someone is interested, they can do so."},{"id":"es/about/index.html","title":"Lite XL - Acerca de","category":["about"],"content":"Acerca deEstas páginas contienen información acerca de las características del editor, capturas de pantalla y desarrolladores.\nTambién contiene una sección de FAQs.Contribuyentes\nFAQ\nCaracterísticas\nCapturas de pantalla"},{"id":"es/about/screenshots.html","title":"Lite XL - Capturas de pantalla","category":["about"],"content":"Capturas de pantalla![Captura 1](/assets/img/editor.png)\n![Captura 2](/assets/img/editor2.png)"},{"id":"es/documentation/build.html","title":"Lite XL - Build","category":["documentation"],"content":"BuildOnce you have downloaded the source code, you can build Lite XL yourself using Meson.\nIn addition, the build-packages.sh script can be used to compile Lite XL and\ncreate an OS-specific package for Linux, Windows or macOS.The following libraries are required:freetype2\nSDL2\nThe following libraries are optional:libagg\nLua 5.2\nIf they are not found, they will be downloaded and compiled by Meson.\nOtherwise, if they are present, they will be used to compile Lite XL.Build ScriptIf you compile Lite XL yourself,\nit is recommended to use the script build-packages.sh:bash build-packages.sh -h\nThe script will run Meson and create a tar compressed archive with the application or,\nfor Windows, a zip file. Lite XL can be easily installed\nby unpacking the archive in any directory of your choice.On Windows two packages will be created, one called \"portable\" using the \"data\"\nfolder next to the executable and the other one using a unix-like file layout.\nBoth packages works correctly. The one with unix-like file layout is meant\nfor people using a unix-like shell and the command line.Please note that there aren't any hard-coded directories in the executable,\nso that the package can be extracted and used in any directory.PortableWhen performing the meson setup command you may enable the -Dportable=true\noption to specify whether files should be installed as in a portable application.If portable is enabled, Lite XL is built to use a data directory placed next\nto the executable.\nOtherwise, Lite XL will use unix-like directory locations.\nIn this case, the data directory will be $prefix/share/lite-xl\nand the executable will be located in $prefix/bin.\n$prefix is determined when the application starts as a directory such that\n$prefix/bin corresponds to the location of the executable.The user directory does not depend on the portable option and will always be\n$HOME/.config/lite-xl.\n$HOME is determined from the corresponding environment variable.\nAs a special case on Windows the variable $USERPROFILE will be used instead.LinuxOn Debian-based systems the required libraries and Meson can be installed\nusing the following commands:# To install the required libraries:\nsudo apt install libfreetype6-dev libsdl2-dev\n# To install Meson:\nsudo apt install meson\n# or pip3 install --user meson\nTo build Lite XL with Meson the commands below can be used:meson setup --buildtype=release --prefix <prefix> build\nmeson compile -C build\nDESTDIR=\"$(pwd)/lite-xl\" meson install --skip-subprojects -C build\nwhere <prefix> depends on the OS you are using:\n- on Linux is /usr\n- on macOS application bundle can be \"/Lite XL.app\"If you are using a version of Meson below 0.54\nyou need to use diffent commands to compile and install:meson setup --buildtype=release build\nninja -C build\nninja -C build install\nmacOSmacOS is fully supported and a notarized app disk image is provided in the\nrelease page. \nIn addition the application can be compiled using the generic instructions given above.Windows MSYS2The build environment chosen for Lite XL on Windows is MSYS2.\nFollow the install instructions in the link.Open MinGW 64-bit or MinGW 32-bit shell from the start menu.\nUpdate the MSYS2 installation with pacman -Syu\nRestart the shell\nInstall the dependencies:\npacman -S \\\n\\t${MINGW_PACKAGE_PREFIX}-freetype \\\n\\t${MINGW_PACKAGE_PREFIX}-gcc \\\n\\t${MINGW_PACKAGE_PREFIX}-ninja \\\n\\t${MINGW_PACKAGE_PREFIX}-pcre2 \\\n\\t${MINGW_PACKAGE_PREFIX}-pkg-config \\\n\\t${MINGW_PACKAGE_PREFIX}-python-pip \\\n\\t${MINGW_PACKAGE_PREFIX}-SDL2\npip3 install meson\n${MINGW_PACKAGE_PREFIX} expands either to mingw-w64-i686 or mingw-w64-x86_64\ndepending if the current shell is 32 or 64 bit."},{"id":"es/documentation/index.html","title":"Lite XL - Documentation","category":["documentation"],"content":"DocumentationThese pages contain documentation to build, run and use Lite XL.Build\nKeymap (MacOS)\nKeymap\nUsage"},{"id":"es/documentation/keymap-macos.html","title":"Lite XL - MacOS Keymap","category":["documentation"],"content":"MacOS KeymapKeymaps on different operating systems have the same functionality, just bound slightly differently\nin order to conform to normal expectations for that operating system.Currently, there are only two operating system layouts. MacOS, and everything else.Keymap"},{"id":"es/documentation/keymap.html","title":"Lite XL - Default Keymap","category":["documentation"],"content":"Default KeymapKeymaps on different operating systems have the same functionality, just bound slightly differently\nin order to conform to normal expectations for that operating system.Currently, there are only two operating system layouts. MacOS, and everything else.Keymap"},{"id":"es/documentation/usage.html","title":"Lite XL - Usage","category":["documentation"],"content":"UsageLite XL is a lightweight text editor written mostly in Lua — it aims to provide\nsomething practical, pretty, small and fast, implemented as simply as\npossible; easy to modify and extend, or to use without doing either.Lite XL is based on the Lite editor and provide some enhancements\nwhile remaining generally compatible with it.Getting StartedLite XL works using a project directory — this is the directory where your\nproject's code and other data resides.To open a specific project directory the directory name can be passed\nas a command-line argument (. can be passed to use the current directory)\nor the directory can be dragged onto either the executable or a running instance.Once started the project directory can be changed using the command\ncore:change-project-folder. The command will close all the documents\ncurrently opened and switch to the new project directory.If you want to open a project directory in a new window the command\ncore:open-project-folder will open a new editor window with the selected\nproject directory.The main way of opening files in Lite XL is through the core:find-file command\n— this provides a fuzzy finder over all of the project's files and can be\nopened using the ctrl+p shortcut by default.Commands can be run using keyboard shortcuts, or by using the core:find-command\ncommand bound to ctrl+shift+p by default. For example, pressing\nthe above combination and typing newdoc then pressing return\nwould open a new document. The current keyboard shortcut for a command\ncan be seen to the right of the command name on the command finder, thus to find\nthe shortcut for a command ctrl+shift+p can be pressed\nand the command name typed.User Data DirectoriesLite XL uses standard systems user directories; the user data can be found in\n$HOME/.config/lite-xl on Linux and macOS.\nOn Windows, the variable $USERPROFILE will be used instead of\n$HOME.User ModuleLite XL can be configured through use of the user module. The user module can be\nused for changing options in the config module, adding additional key bindings,\nloading custom color themes, modifying the style or changing any other part of\nthe editor to your personal preference.The user module is loaded when the application starts,\nafter the plugins have been loaded.The user module can be modified by running the core:open-user-module command\nor otherwise directly opening the $HOME/.config/lite-xl/init.lua file.On Windows, the variable $USERPROFILE will be used instead of\n$HOME.tl;dr:Windows: C:\\Users\\(username)\\.config\\lite-xl\\init.lua\nMacOS: /Users/(usernmame)/.config/lite-xl/init.lua\nLinux: /home/(username)/.config/lite-xl/init.lua\nThese aren't the exact location, but it gives you an idea where to find.Please note that Lite XL differs from the standard Lite editor for the location\nof the user's module.Project ModuleThe project module is an optional module which is loaded from the current\nproject's directory when Lite XL is started. Project modules can be useful for\nthings like adding custom commands for project-specific build systems, or\nloading project-specific plugins.The project module is loaded when the application starts,\nafter both the plugins and user module have been loaded.The project module can be edited by running the core:open-project-module\ncommand — if the module does not exist for the current project when the\ncommand is run it will be created.Add directories to a projectIn addition to the project directories it is possible to add other directories\nusing the command core:add-directory.\nOnce added a directory it will be shown in the tree-view on the left side and\nthe additional files will be reachable using the ctrl+p command (find file).\nThe additonal files will be also visible when searching across the project.The additional directories can be removed using the command core:remove-directory.When you will open again Lite XL on the same project folder the application will\nremember your workspace including the additonal project directories.Since version 1.15 Lite XL does not need a workspace plugin as it is now\nbundled with the editor.Create new empty directoryUsing the command files:create-directory or control-click in a directory in the\ntree-view to create a new empty subdirectory.CommandsCommands are used both through the command finder (ctrl+shift+p) and\nby Lite XL's keyboard shortcut system. Commands consist of 3 components:Name — The command name in the form of namespace:action-name, for\nexample: doc:select-all\nPredicate — A function that returns true if the command can be ran, for\nexample, for any document commands the predicate checks whether the active\nview is a document\nFunction — The function which performs the command itself\nCommands can be added using the command.add function provided by the\ncore.command module:local core = require \"core\"\nlocal command = require \"core.command\"\ncommand.add(\"core.docview\", {\n\\t[\"doc:save\"] = function()\n\\tcore.active_view.doc:save()\n\\tcore.log(\"Saved '%s'\", core.active_view.doc.filename)\n\\tend\n})\nCommands can be performed programatically (eg. from another command or by your\nuser module) by calling the command.perform function after requiring the\ncommand module:local command = require \"core.command\"\ncommand.perform \"core:quit\"\nKeymapAll keyboard shortcuts are handled by the core.keymap module.\nA key binding maps a \"stroke\" (eg. ctrl+q) to one or more commands\n(eg. core:quit). When the shortcut is pressed Lite XL will iterate each command\nassigned to that key and run the predicate function for that command — if the\npredicate passes it stops iterating and runs the command.An example of where this used is the default binding of the tab key:\\t[\"tab\"] = { \"command:complete\", \"doc:indent\" },\nWhen tab is pressed the command:complete command is attempted which will only\nsucceed if the command-input at the bottom of the window is active. Otherwise\nthe doc:indent command is attempted which will only succeed if we have a\ndocument as our active view.A new mapping can be added by your user module as follows:local keymap = require \"core.keymap\"\nkeymap.add { [\"ctrl+q\"] = \"core:quit\" }\nA list of default mappings can be viewed here.Global variablesThere are a few global variables set by the editor.\nThese variables are available everywhere and shouldn't be overwritten.ARGS: command-line arguments. argv[1] is the program name, argv[2] is the 1st parameter, ...\nPLATFORM: Output from SDL_GetPlatform(). Can be Windows, Mac OS X, Linux, iOS and Android.\nSCALE: Font scale. Usually 1, but can be higher on HiDPI systems.\nEXEFILE: An absolute path to the executable.\nEXEDIR: The executable directory. DO NOT WRITE TO THIS DIRECTORY.\nVERSION: lite-xl version.\nMOD_VERSION: mod-version used in plugins. This is usually incremented when there are API changes.\nPATHSEP: Path seperator. \\ (Windows) or / (Other OSes)\nDATADIR: The data directory, where the Lua part of lite-xl resides. DO NOT WRITE TO THIS DIRECTORY.\nUSERDIR: User configuration directory.\nUSERDIR should be used instead of DATADIR when configuring the editor\nbecause DATADIR might not be writable.\n(for example, if the editor is installed in /usr, DATADIR will be /usr/share/lite-xl!)\nUSERDIR on the other hand should always be writable for the user, and allows multiple users to customize\ntheir own editor.PluginsPlugins in Lite XL are normal lua modules and are treated as such — no\ncomplicated plugin manager is provided, and, once a plugin is loaded, it is never\nexpected be to have to unload itself.To install a plugin simply drop it in the plugins directory in the user\nmodule directory.\nWhen Lite XL starts it will first load the plugins included in the data directory\nand will then loads the plugins located in the user module directory.To uninstall a plugin the plugin file can be deleted — any plugin\n(including those included with the default installation)\ncan be deleted to remove its functionality.If you want to load a plugin only under a certain circumstance (for example,\nonly on a given project) the plugin can be placed somewhere other than the\nplugins directory so that it is not automatically loaded. The plugin can\nthen be loaded manually as needed by using the require function.Plugins can be downloaded from the plugins repository.Restarting the editorIf you modify the user configuration file or some of the Lua implementation files\nyou may restart the editor using the command core:restart.\nThe entire application will be restarting by keeping the window that is already in use.Color ThemesColors themes in Lite XL are lua modules which overwrite the color fields of\nLite XL's core.style module.\nPre-defined color methods are located in the colors folder in the data directory.\nAdditional color themes can be installed in the user's directory in a folder named\ncolors.A color theme can be set by requiring it in your user module:core.reload_module \"colors.winter\"\nIn the Lite editor the function require is used instead of core.reload_module.\nIn Lite XL core.reload_module should be used to ensure that the color module\nis actually reloaded when saving the user's configuration file.Color themes can be downloaded from the color themes repository.\nThey are included with Lite XL release packages."},{"id":"es/downloads.html","title":"Lite XL - Descargas","category":[],"content":"DescargasBinariosHay ejecutables disponibles en la página de lanzamientos de GitHub.Instalar víaAlternatively, you can install lite-xl from your distribution's package manager.\nThese packages are maintained by the community and may be outdated.Windows (Chocolatey / Scoop)\nMac OS (MacPorts)\nArch Linux (AUR)\nNixOS (nixpkgs)\nFedora\nchoco install lite-xl\\t# chocolatey\nscoop bucket add extras && scoop install lite-xl\\t# scoop\nsudo port install lite-xl\\t# macports\nyay -S lite-xl\\t# or your favorite AUR helper\nnix-env -i lite-xl\\t# nixos\nsudo dnf install lite-xl\\t# fedora\nSource CodeSource code is available on GitHub, by downloading zip or tar archives,\nor directly via git:git clone https://github.com/lite-xl/lite-xl.git"},{"id":"es/index.html","title":"Lite XL","category":[],"content":"Lite XLUn editor de texto ligero, simple, rápido, lleno de características y extremadamente extensible escrito en C y Lua, adaptado de lite.![Editor Lite XL](/assets/img/editor.png)"},{"id":"es/tutorials/api-overview.html","title":"Lite XL - API Overview","category":["tutorials"],"content":"API OverviewThis is a work in progress.Here we provide some resources and explanation to some API and aspects of Lite XL.\nFor API docs, it's available in the repo\nThus, we'll not explain everything, only the more important and frequently used features.Built-in APIs:Process API\nSystem API\nRegex API"},{"id":"es/tutorials/index.html","title":"Lite XL - Tutorials","category":["tutorials"],"content":"TutorialsThese pages contain tutorials and documentations for building plugins in Lite XL.API Overview\nSimple Plugin\nSyntax Highlighting\nSystem Fonts"},{"id":"es/tutorials/overview/process.html","title":"Lite XL - Process API","category":["tutorials","overview"],"content":"Process APILite XL provides a process API to launch external applications. This API is meant to replace\nlua's io.popen and lite's pipe-to-a-file approach.Advantages of this API includes:Proper argument escaping (arguments are supplied via a table)\nNonblocking IO\nAble to detach processes from Lite XL (in progress)\nDoes not create temporary files\nMostly cross-platform (does not require special code for each shell)\nUsing the Process APIError handlingprocess.start() may throw errors if it cannot run the program.\nprocess.read* and process.write functions may throw errors if\nthe process ended\nthe process closed the stream\nyou closed the stream\nthere might be other errors to look forward to too\nStarting a processTo start a process, use process.start(args, options).Here are some of the more useful arguments.args: The executable and any arguments, eg: { \"sh\", \"-c\", \"echo hello world\" }\noptions: Options for process.start()\nenv: A key-value table containing the env. Note that if this is provided,\n\\tenvironment variables will not be inherited.\nstdin: Specify where to redirect stdin\nstdout: Specify where to redirect stdout\nstderr: Specify where to redirect stderr\nfor options.std{in,out,err}, valid values are:process.REDIRECT_PIPE (Make it available to subprocess API for reading / writing)\nprocess.REDIRECT_DISCARD (Discard the output. Use this to prevent buffering)\nprocess.REDIRECT_STDOUT (stderr only, for redirecting stderr to stdout)\nReading from processTo read from stdout or stderr of a process, use process:read_stdout() and\nprocess:read_stderr() respectively.You can specify a numeric argument to them, which will change the size of internal buffer used\nto read the output.Alternatively, you could use process:read() with process.STREAM_STDERR and process.STREAM_STDOUT.Example:local proc = process.start { \"sh\", \"-c\", \"echo hello world!\" }\n-- do not use `while proc:running()` if you care about output.\n-- The process could die and leave data in the buffer\n-- You should just read until `proc:read_stdout()` returns nil\nwhile true do\n\\tlocal rdbuf = proc:read_stdout()\n\\tif not rdbuf then break end\n\\t-- yay, output\nend\nWriting to processYou can use process:write(data) to write a string to stdin.Checking completionprocess:running() returns a boolean to indicate whether if the process is running.\nprocess:wait(time) also does the same thing, but you specify how long it should wait (or 0 to return immediately).\nTerminating processprocess:terminate() sends SIGTERM (or Windows equivalent) to the process.\nprocess:kill() sends SIGKILL (or Windows equivalent) to the progress.\nUse this only if process:terminate() cannot kill the process, as it can cause issues.\nMiscprocess:pid() returns the PID of the process.\nThere are no guarantees for this PID to be correct if the process terminated early.\nprocess:returncode() returns the exit code of the process, if any\nprocess:close_stream() closes stdin, stdout or stderr stream of the process."},{"id":"es/tutorials/overview/regex.html","title":"Lite XL - Regex API","category":["tutorials","overview"],"content":"Regex APIThis API provides PCRE regular expressions for those who needs more power in matching text.\nThis API written in C and Lua.Creating a regexUse regex.compile(pattern, options) to compile a regex.pattern: The regex pattern\noptions: regex modifiers as a string, eg \"im\"\n\"i\": Case-insensitive search\n\"m\": Multiline search\n\"s\": Match all characters with dot (.), including newlines.\nMatchingLow level functionsregex:cmatch(str, offset, options) low-level matching function\nstr: The string to match against\noffset: Where to start matching\noptions: A bit field of options\nregex.ANCHORED: Only match from the start of the string\nregex.ENDANCHORED: Only match from the end of the string\nregex.NOTBOL: String is not beginning of line\nregex.NOTEOL: String is not the end of line\nregex.NOTEMPTY: Do not match an empty string\nregex.NOTEMPTY_ATSTART: Do not match empty string at the start\nNote: regex:cmatch() returns wrong indexes (currently at version 2.0.2).\n\\tThe end index returned by regex:cmatch() is always off by 1 (-1 to get the actual end index).High level functionsAll the functions below can be in 2 forms:\n- regex:fn(...) where regex is the compiled regex instance\n- regex.fn(pattern, ...) where pattern is a pattern string to be compiled and used directly.We will only document the first form.regex:match(str, offset, options) high level matching function. This function accepts\nthe same arguments as regex:cmatch()\nregex:gsub(str, replacement) replaces matches in str with replacement.\nCapture groups are identified with \\\\0 to \\\\9, this might change in the future."},{"id":"es/tutorials/overview/system.html","title":"Lite XL - System API","category":["tutorials","overview"],"content":"System APIThis is where Lite XL's lua code interact with its underlying C engine.\nSome of the functions here will be omitted because they're not useful for\nplugins.Clipboardsystem.set_clipboard(text) sets the clipboard content.\nsystem.get_clipboard() retrieves the content of the clipboard.\nFile / Directory manipulationsystem.list_dir(dir) returns a list of filenames in a directory.\nsystem.rmdir(dir) removes a directory. Use this instead of os.remove().\nThe directory must be empty.\nsystem.chdir(dir) changes the current working directory (like cd).\nsystem.mkdir(dir) creates a new directory.\nIt does not recursively create directories.\nsystem.absolute_path(path) resolves the path components (.. and .) to an absolute path.\nsystem.get_file_info(path) returns info about a path.\nmodified: last modification time of the file in seconds since UNIX epoch.\nsize: file size in bytes.\ntype: Path type (\"file\" or \"dir\").\nTimingsystem.get_time() returns time in seconds (as floating point number) since Lite XL started.\nUse this instead of os.time() for higher precision timers.\nsystem.sleep(time) sleeps for time in milliseconds.\nDo not use this. Write asynchronous code.\nWindow manipulationsystem.set_window_opacity(o) sets the window opacity from 0 to 1.\nsystem.set_window_title(title) sets the window title.\nsystem.set_window_mode(mode) sets window mode:\n\"normal\": also known as \"restored\" on Windows.\n\"maximized\": Maximize the window.\n\"minimized\": Minimize the window.\n\"fullscreen\": Fullscreen\nsystem.set_window_bordered(bordered) enables or disable window border (decoration).\nsystem.set_window_hit_test(height, control_width, resize_border) sets window hit test (used for\nconfig.borderless to make custom drawn border interactable).\nIf no argument is supplied, reset the hit test values.\nheight: height of the title bar.\ncontrols_width: Not too sure about this, but it should be the size of the title bar controls\n(Maximize, Minimize and Normal buttons on the right).\nIt seems to be fixed at the right side of the title bar.\nresize_border: Number of pixels reserved for resizing the window.\n(setting this to a large value means that you can resize the window way easier)\nsystem.get_window_size() gets the window size.\nsystem.set_window_size(w, h, x, y) sets the window size (and also position).\nsystem.window_has_focus() checks whether the window is in focus.\nsystem.show_fatal_error(title, msg) shows an system error message box.\nUse nagview whenever possible.\nMiscsystem.exec(command) runs a command. Use the Process API instead of this.\nsystem.fuzzy_match(haystack, needle, file) generates a score depends on how close the needle\nmatches the haystack.\nfile: match backwards (more accurate for filename matching)."},{"id":"es/tutorials/simple-plugin.html","title":"Lite XL - Simple Plugin","category":["tutorials"],"content":"Simple PluginWhat is Simple?Simple is a very basic plugin written with the intention of introducing developers\nwho are new to Lite XL to the process of writing plugins for the editor.What does the plugin do?The plugin displays a message (that is taken as input from the user) at the top\nright corner of the editor window. It also allows the user to toggle\nthe visibility of the message.I can't write Lua!If you come from other programming languages, take a look at Lua cheatsheet.\nIf you're new to programming, you can read this.Format of the tutorialThe code contains comments detailing what most (if not all)\nof the code in the file does.The code :-- mod-version:3\n-- you MUST put mod-version:x on the first line of your plugin\n-- mod-version usually maps to lite-xl releases (eg. mod-version: 2 == lite-xl 2.0)\n-- lite-xl won't load the plugin if the mod-version mismatches\n-----------------------------------------------------------------------\n-- NAME\\t: Simple\n-- DESCRIPTION: A simple guide on how to make your first Lite XL plugin\n-- AUTHOR\\t: Ashwin Godbole (aelobdog)\n-- GOALS\\t: To render some text inside the editor\n-----------------------------------------------------------------------\n-- Disclaimer :\n-- I am not a lua developer, and my knowledge about writing plugins for\n-- Lite XL is very limited. This file serves the purpose of helping the\n-- reader get started with plugin development for Lite XL, and therefore\n-- demonstrates only some very basic features. For more complex plugin\n-- development, be sure to check out the source code of some other\n-- plugins after going through this file.\n-----------------------------------------------------------------------\n-- Before we start writing any code for the plugin, we must import the\n-- required modules from the \"core\" package.\n-- the \"core\" module\nlocal core = require \"core\"\n-- the \"command\" module will help us register commands for our plugin.\nlocal command = require \"core.command\"\n-- the \"style\" module will allow us to use styling options\nlocal style = require \"core.style\"\n-- the \"config\" module will be used to store certain things like colors\n-- and functions\nlocal config = require \"core.config\"\n-- the \"keymap\" module will allow us to set keybindings for our commands\nlocal keymap = require \"core.keymap\"\n-- since we want to modify RootView, we'll need to require it first\nlocal RootView = require \"core.rootview\"\n-----------------------------------------------------------------------\n-- per-plugin config must stay in config.plugins.(plugin name)\nconfig.plugins.simple = {}\n-- colors are just three or four comma separated values (RGBA) (range 0 - 255)\n-- put inside of '{ }'. We will add our color to the config module.\nconfig.plugins.simple.text_color = {200, 140, 220} -- or use `{ common.color \"#C88CDC\" }`\n-----------------------------------------------------------------------\n-- Let's create a function to calculate the coordinates of our text.\n-- While we're at it, let's add our function to the `config` module.\n-- We'll take the message we want to display as the argument to the\n-- function to determine the x and y coordinates of the text.\nfunction config.plugins.simple.get_text_coordinates(message)\n\\t-- For this plugin, we want to display the text on the top right\n\\t-- corner of the screen. For this, we need to know the editor's width\n\\t-- and height.\n\\t-- The current font's size can be obtained from the \"style\" module.\n\\t-- The editor's dimensions can be obtained by\n\\t--\\t1. WIDTH\\t: core.root_view.size.x\n\\t--\\t2. HEIGHT : core.root_view.size.y\n\\tlocal message_width = style.code_font:get_width(message..\" \")\n\\tlocal font_height = style.code_font:get_size()\n\\tlocal x = core.root_view.size.x - message_width\n\\tlocal y = font_height / 2\n\\treturn x, y\nend\n-----------------------------------------------------------------------\n-- Let's now get to actually drawing the text inside the editor.\n-- In order to \"inject\" our own code to draw text,\n-- we'll need to save the original draw function\n-- We'll save `RootView.draw` to a variable we call `parent_draw`\nlocal parent_draw = RootView.draw\n-- Now let's overload the original definition of `draw` in RootView\n-- by redefining the function.\nfunction RootView:draw()\n\\t-- We call the parent's function to keep the editor functional...\n\\t-- obviously we must still draw all the other stuff !\n\\t-- So we call the `parent_draw` function before doing anything else.\n\\tparent_draw(self)\n\\t-- we'll add an option to toggle the message on and off. let's use a\n\\t-- boolean variable to keep track of whether we want to display the\n\\t-- message or not.\n\\tif config.plugins.simple.show_my_message then\n\\t-- We'll be getting the message to display as input from the user\n\\t-- later. We'll store that user input in `config.plugins.simple.hw_message`.\n\\t-- (NOTE: this variable does not come in-built in lite-xl;\n\\t--\\tit is a variable that we will define later.)\n\\t-- let's store the value of config.plugins.simple.hw_message in a local variable\n\\t-- `message` in case config.plugins.simple.hw_message we set the message to\n\\t-- \"message not set yet!\"\n\\tlocal message\n\\tif config.plugins.simple.hw_message then\n\\tmessage = config.plugins.simple.hw_message\n\\telse\n\\tmessage = \"Message not set yet !\"\n\\tend\n\\t-- let's get the coordinates for our text\n\\tlocal x, y = config.plugins.simple.get_text_coordinates(message)\n\\t-- let's finally draw the text to the window !\n\\t-- the draw_text function from `renderer` is an important function\n\\t-- as it is used to display any and all text inside of the editor\n\\t-- window\n\\trenderer.draw_text(style.code_font, message, x, y, config.plugins.simple.text_color)\n\\tend\nend\n-----------------------------------------------------------------------\n-- Let's allow the user to turn the message on and off\n-- we'll write a function to flip our \"show\" boolean variable.\nlocal function toggle_helloworld()\n\\tconfig.plugins.simple.show_my_message = not config.plugins.simple.show_my_message\nend\n-----------------------------------------------------------------------\n-- Finally, let's add the toggle function to the command list so that\n-- we can call it from the C-S-p command panel. Let's add one command\n-- to toggle the visibility of the message on and off and one to get\n-- the user's message and then display it.\ncommand.add(nil, {\n\\t-- Toggle the visibility of the message\n\\t[\"simple:toggle\"] = toggle_helloworld,\n\\t-- Set and show the message\n\\t-- This is the way to get user input through the command bar.\n\\t-- `core.command_view:enter` takes 2 arguments:\n\\t--\\t* the prompt to display before taking input\n\\t--\\t* a function that takes the \"input\" as its argument\n\\t-- (NOTE: here the variable we are reading input into is `text`)\n\\t[\"simple:setshow\"] = function()\n\\tcore.command_view:enter(\"Test to display\", {\n\\tsubmit = function(text)\n\\tconfig.plugins.simple.hw_message = text\n\\tconfig.plugins.simple.show_my_message = true\n\\tend\n\\t})\n\\tend\n})\n-----------------------------------------------------------------------\n-- Just for fun, let's assign our commands their own keybindings.\n-- Here, we assign the keybinding the same string(its name) as the one\n-- that we set while creating the command\nkeymap.add {\n\\t[\"alt+s\"] = \"simple:setshow\",\n\\t[\"alt+t\"] = \"simple:toggle\",\n}\nFurther readingLite: An Implementation Overview, an excellent post by rxi that stays mostly relevant to lite-xl.\nAPI overview, where some of the APIs are explained."},{"id":"es/tutorials/syntax-highlighting.html","title":"Lite XL - Syntax Highlighting","category":["tutorials"],"content":"Syntax HighlightingHow to create syntax highlighting plugins for Lite XLSyntax highlighting plugins for Lite XL are Lua files. These define some patterns or regular expressions that\nmatch different parts of a given language, assigning token types to each match.\nThese different token types are then given different colors by your chosen color scheme.Like other plugins, syntax definitions are sourced from the following folders, in order:/usr/share/lite-xl/plugins/\n$HOME/.config/lite-xl/plugins/\nNOTE: The exact location of these folders will depend on your OS and installation method. For example, on Windows, the variable $USERPROFILE will be used instead of $HOME.The user module folder for Lite XL can generally be found in these places on different OSes:Windows: C:\\Users\\(username)\\.config\\lite-xl\nMacOS: /Users/(usernmame)/.config/lite-xl\nLinux: /home/(username)/.config/lite-xl\nSo, to create a new syntax definition on Linux, you can just create a .lua file in your $HOME/.config/lite-xl/plugins/ folder.What syntax token types are supported?The supported syntax token types, defined by lite-xl/core/style.lua, are:normal\nsymbol\ncomment\nkeyword\nkeyword2\nnumber\nliteral\nstring\noperator\nfunction\nIn your syntax highlighting plugin, you write patterns to match parts of the language syntax, assigning these token types to matches. You don't have to use them all - just use as many as you need for your language.Let's walk through an example syntax definition and see how this works.Example syntax: ssh config filesThis is a small, simple example of a syntax definition. It's intended to highlight SSH Config files and looks like this:-- mod-version:2 -- lite-xl 2.0\nlocal syntax = require \"core.syntax\"\nsyntax.add {\n\\tfiles = { \"sshd?/?_?config$\" },\n\\tcomment = '#',\n\\tpatterns = {\n\\t{ pattern = \"#.*\\n\",\\ttype = \"comment\"\\t},\n\\t{ pattern = \"%d+\",\\ttype = \"number\"\\t},\n\\t{ pattern = \"[%a_][%w_]*\",\\ttype = \"symbol\"\\t},\n\\t{ pattern = \"@\",\\ttype = \"operator\" },\n\\t},\n\\tsymbols = {\n\\t-- ssh config\n\\t[\"Host\"]\\t= \"function\",\n\\t[\"ProxyCommand\"]\\t= \"function\",\n\\t[\"HostName\"]\\t= \"keyword\",\n\\t[\"IdentityFile\"]\\t= \"keyword\",\n\\t...\n\\t-- sshd config\n\\t[\"Subsystem\"]\\t= \"keyword2\",\n\\t-- Literals\n\\t[\"yes\"]\\t= \"literal\",\n\\t[\"no\"]\\t= \"literal\",\n\\t[\"any\"]\\t= \"literal\",\n\\t[\"ask\"]\\t= \"literal\",\n\\t},\n}\nLet's take each section in turn and see how it works.HeaderThe first line is a Lua comment & tells Lite XL which version this plugin requires. The second imports the core.syntax module\nfor us to use:-- mod-version:2 -- lite-xl 2.0\nlocal syntax = require \"core.syntax\"\nWe then add a syntax definition to lite, using syntax.add {...}. The contents of this definition are covered next.FilesThe files property tells Lite XL which files this syntax should be used for. This is a Lua pattern that matches against the full path of the file being opened. For example, to match against Markdown files - with either a .md or a .markdown extension,\nyou could do this:files = { \"%.md$\", \"%.markdown$\" },\nIn our original example, we match against the end of the path rather than the extension, because SSH config files don't have extensions - and we don't want to match all config files. We expect the path for SSH config files to look something like one of these:~/.ssh/config\n/etc/ssh/ssh_config\n/etc/ssh/sshd_config\nThis pattern matches paths that look like that:files = { \"sshd?/?_?config$\" },\nCommentThe comment property doesn't define which parts of the syntax are comments - see Patterns for that, below. This property tells Lite XL which character to insert at the start of selected lines when you press ctrl+/.\nYou can also use block_comment to tell Lite XL how to create multiline / block comments.PatternsA given piece of text can only match one pattern. Once Lite XL decides that a piece of text matches a pattern, it will assign that token type to that piece and move on.\nPatterns are tested in the order that they are written in the syntax definition, so the first match will win.Each pattern takes one of the following forms:Simple Pattern{ pattern = \"#.*\\n\",\\ttype = \"comment\" },\nThis form matches the line against the pattern and if it matches, assigns the matching text to the given token type - comment, in this case.Start & End Pattern{ pattern = { \"%[\", \"%]\" }, type = \"keyword\" },\nThis form has two patterns - one that matches against the start of the range and one that matches against the end. Everything between the start and the end will be assigned the given token type.Start & End Pattern, with Escape{ pattern = { '\"', '\"', '\\\\' }, type = \"string\" },\nThis is the same as the previous form, but with an extra, third parameter.\nThe 3rd part, the '\\\\' part in this example, specifies the character that allows escaping the closing match.For more on Lua Patterns, see: Lua Pattern ReferenceIf you need to use PCRE Regular Expressions, instead of Lua Patterns, you can use the regex keyword here, instead of pattern.SymbolsThis is not related to the symbol token type.The symbols section allows you to assign token types to particular keywords or strings - usually reserved words in the language you are highlighting.\nThe token type in this section always take precedence over token types declared in patterns.For example this highlights Host using the function token type, HostName as a keyword and yes, no, any & ask as a literal:[\"Host\"]\\t= \"function\",\n[\"HostName\"]\\t= \"keyword\",\n[\"yes\"]\\t= \"literal\",\n[\"no\"]\\t= \"literal\",\n[\"any\"]\\t= \"literal\",\n[\"ask\"]\\t= \"literal\",\nTips: double check your patterns!There are a few common mistakes that can be made when using the symbols table in conjunction with patterns.Case 1: Spaces between two symbols tokensLet's have an example:{ pattern = \"[%a_][%w_]+%s+()[%a_][%w_]+\", type = { \"keyword2\", \"symbol\" } }\nLet's explain the pattern a bit (omitting the empty parentheses):[%a_] = any alphabet and underscore\n[%w_] = any alphabet, numbers and underscore\n%s = any whitespace character\nWORD =\n\\t[%a_] followed by (1 or more [%w_])\npattern =\n\\tWORD followed by (one or more %s) followed by WORD\nAfterwards, you add an entry [\"my\"] = \"literal\" in the symbols table.\nYou test the syntax with my function found that \"my\" isn't highlighted as literal. Why did that happen?**symbols table requires an exact match.\nIf you look carefully, the empty parentheses (()) is placed **after the space!\nThis tells Lite XL that WORD followed by (one or more %s) is a token, which will match my (note the space in the match).The fix is to add a normal token for the whitespace between the two tokens:{ pattern = \"[%a_][%w_]+()%s+()[%a_][%w_]+\", type = { \"keyword2\", \"normal\", \"symbol\" } }\nCase 2: Patterns & symbols tokensOne might assume that Lite XL magically matches text against the symbols table. This is not the case.In some languages, people may add a generic pattern to delegate the matching to the symbols table.{ pattern = \"[%a_][%w_]*\", \"symbol\" }\nHowever, the symbols table may look like this:symbols = {\n\\t[\"my-symbol\"] = \"function\",\n\\t[\"..something_else\"] = \"literal\"\n}\n\"my-symbol contains a dash (-) and \"..something_else\" contains 2 dots (.).\nNone of the characters are matched by [%a_][%w_]*!Beware of the text you intend to match in the symbols table.\nIf you want to use it, you need to ensure that it can matched by one of the patterns.The correct patterns are:{ pattern = \"[%a_][%w%-_]*\", \"symbol\" },\n{ pattern = \"%.%.[%a_][%w_]*\", \"symbol\" },\nTesting Your New SyntaxTo test your new syntax highlighting you need to do two things:Reload the Lite XL core\nLoad a file in your chosen language and see how it looks\nTo reload the core, you can either restart Lite XL, or reload the core from the command palette, without needing to restart.\nTo do this, type ctrl+shit+p to show the command palette, then select Core: Restart (or type crr or something similar to match it), then press Enter. You will need to restart the core after any changes you make to the syntax highlighting definition.Example advanced syntax: MarkdownNote: This example has features from 2.1. It is not compatible with older versions of lite-xl.Not all languages are as simple as SSH config files. Markup languages like HTML and Markdown are especially hard to parse correctly. Here's the markdown syntax file in its full glory:-- mod-version:3\nlocal syntax = require \"core.syntax\"\nlocal style = require \"core.style\"\nlocal core = require \"core\"\nlocal initial_color = style.syntax[\"keyword2\"]\n-- Add 3 type of font styles for use on markdown files\nfor _, attr in pairs({\"bold\", \"italic\", \"bold_italic\"}) do\n\\tlocal attributes = {}\n\\tif attr ~= \"bold_italic\" then\n\\tattributes[attr] = true\n\\telse\n\\tattributes[\"bold\"] = true\n\\tattributes[\"italic\"] = true\n\\tend\n\\t-- no way to copy user custom font with additional attributes :(\n\\tstyle.syntax_fonts[\"markdown_\"..attr] = renderer.font.load(\n\\tDATADIR .. \"/fonts/JetBrainsMono-Regular.ttf\",\n\\tstyle.code_font:get_size(),\n\\tattributes\n\\t)\n\\t-- also add a color for it\n\\tstyle.syntax[\"markdown_\"..attr] = style.syntax[\"keyword2\"]\nend\nlocal in_squares_match = \"^%[%]\"\nlocal in_parenthesis_match = \"^%(%)\"\nsyntax.add {\n\\tname = \"Markdown\",\n\\tfiles = { \"%.md$\", \"%.markdown$\" },\n\\tblock_comment = { \"<!--\", \"-->\" },\n\\tspace_handling = false, -- turn off this feature to handle it our selfs\n\\tpatterns = {\n\\t---- Place patterns that require spaces at start to optimize matching speed\n\\t---- and apply the %s+ optimization immediately afterwards\n\\t-- bullets\n\\t{ pattern = \"^%s*%*%s\",\\ttype = \"number\" },\n\\t{ pattern = \"^%s*%-%s\",\\ttype = \"number\" },\n\\t{ pattern = \"^%s*%+%s\",\\ttype = \"number\" },\n\\t-- numbered bullet\n\\t{ pattern = \"^%s*[0-9]+[%.%)]%s\",\\ttype = \"number\" },\n\\t-- blockquote\n\\t{ pattern = \"^%s*>+%s\",\\ttype = \"string\" },\n\\t-- alternative bold italic formats\n\\t{ pattern = { \"%s___\", \"___%f[%s]\" },\\ttype = \"markdown_bold_italic\" },\n\\t{ pattern = { \"%s__\", \"__%f[%s]\" },\\ttype = \"markdown_bold\" },\n\\t{ pattern = { \"%s_[%S]\", \"_%f[%s]\" },\\ttype = \"markdown_italic\" },\n\\t-- reference links\n\\t{\n\\tpattern = \"^%s*%[%^()[\"..in_squares_match..\"]+()%]: \",\n\\ttype = { \"function\", \"number\", \"function\" }\n\\t},\n\\t{\n\\tpattern = \"^%s*%[%^?()[\"..in_squares_match..\"]+()%]:%s+.+\\n\",\n\\ttype = { \"function\", \"number\", \"function\" }\n\\t},\n\\t-- optimization\n\\t{ pattern = \"%s+\",\\ttype = \"normal\" },\n\\t---- HTML rules imported and adapted from language_html\n\\t---- to not conflict with markdown rules\n\\t-- Inline JS and CSS\n\\t{\n\\tpattern = {\n\\t\"<%s*[sS][cC][rR][iI][pP][tT]%s+[tT][yY][pP][eE]%s*=%s*\" ..\n\\t\"['\\\"]%a+/[jJ][aA][vV][aA][sS][cC][rR][iI][pP][tT]['\\\"]%s*>\",\n\\t\"<%s*/[sS][cC][rR][iI][pP][tT]>\"\n\\t},\n\\tsyntax = \".js\",\n\\ttype = \"function\"\n\\t},\n\\t{\n\\tpattern = {\n\\t\"<%s*[sS][cC][rR][iI][pP][tT]%s*>\",\n\\t\"<%s*/%s*[sS][cC][rR][iI][pP][tT]>\"\n\\t},\n\\tsyntax = \".js\",\n\\ttype = \"function\"\n\\t},\n\\t{\n\\tpattern = {\n\\t\"<%s*[sS][tT][yY][lL][eE][^>]*>\",\n\\t\"<%s*/%s*[sS][tT][yY][lL][eE]%s*>\"\n\\t},\n\\tsyntax = \".css\",\n\\ttype = \"function\"\n\\t},\n\\t-- Comments\n\\t{ pattern = { \"<!%-%-\", \"%-%->\" },\\ttype = \"comment\" },\n\\t-- Tags\n\\t{ pattern = \"%f[^<]![%a_][%w_]*\",\\ttype = \"keyword2\" },\n\\t{ pattern = \"%f[^<][%a_][%w_]*\",\\ttype = \"function\" },\n\\t{ pattern = \"%f[^<]/[%a_][%w_]*\",\\ttype = \"function\" },\n\\t-- Attributes\n\\t{\n\\tpattern = \"[a-z%-]+%s*()=%s*()\\\".-\\\"\",\n\\ttype = { \"keyword\", \"operator\", \"string\" }\n\\t},\n\\t{\n\\tpattern = \"[a-z%-]+%s*()=%s*()'.-'\",\n\\ttype = { \"keyword\", \"operator\", \"string\" }\n\\t},\n\\t{\n\\tpattern = \"[a-z%-]+%s*()=%s*()%-?%d[%d%.]*\",\n\\ttype = { \"keyword\", \"operator\", \"number\" }\n\\t},\n\\t-- Entities\n\\t{ pattern = \"&#?[a-zA-Z0-9]+;\",\\ttype = \"keyword2\" },\n\\t---- Markdown rules\n\\t-- math\n\\t{ pattern = { \"%$%$\", \"%$%$\", \"\\\\\"\\t},\\ttype = \"string\", syntax = \".tex\"},\n\\t{ pattern = { \"%$\", \"%$\", \"\\\\\" },\\ttype = \"string\", syntax = \".tex\"},\n\\t-- code blocks\n\\t{ pattern = { \"```c++\", \"```\" },\\ttype = \"string\", syntax = \".cpp\" },\n\\t-- ... there's some other patterns here, but I removed them for brevity\n\\t{ pattern = { \"```lobster\", \"```\" },\\ttype = \"string\", syntax = \".lobster\" },\n\\t{ pattern = { \"```\", \"```\" },\\ttype = \"string\" },\n\\t{ pattern = { \"``\", \"``\" },\\ttype = \"string\" },\n\\t{ pattern = { \"%f[\\\\`]%`[%S]\", \"`\" },\\ttype = \"string\" },\n\\t-- strike\n\\t{ pattern = { \"~~\", \"~~\" },\\ttype = \"keyword2\" },\n\\t-- highlight\n\\t{ pattern = { \"==\", \"==\" },\\ttype = \"literal\" },\n\\t-- lines\n\\t{ pattern = \"^%-%-%-+\\n\",\\ttype = \"comment\" },\n\\t{ pattern = \"^%*%*%*+\\n\",\\ttype = \"comment\" },\n\\t{ pattern = \"^___+\\n\",\\ttype = \"comment\" },\n\\t-- bold and italic\n\\t{ pattern = { \"%*%*%*%S\", \"%*%*%*\" },\\ttype = \"markdown_bold_italic\" },\n\\t{ pattern = { \"%*%*%S\", \"%*%*\" },\\ttype = \"markdown_bold\" },\n\\t-- handle edge case where asterisk can be at end of line and not close\n\\t{\n\\tpattern = { \"%f[\\\\%*]%*[%S]\", \"%*%f[^%*]\" },\n\\ttype = \"markdown_italic\"\n\\t},\n\\t-- alternative bold italic formats\n\\t{ pattern = \"^___[%s%p%w]+___%s\" ,\\ttype = \"markdown_bold_italic\" },\n\\t{ pattern = \"^__[%s%p%w]+__%s\" ,\\ttype = \"markdown_bold\" },\n\\t{ pattern = \"^_[%s%p%w]+_%s\" ,\\ttype = \"markdown_italic\" },\n\\t-- heading with custom id\n\\t{\n\\tpattern = \"^#+%s[%w%s%p]+(){()#[%w%-]+()}\",\n\\ttype = { \"keyword\", \"function\", \"string\", \"function\" }\n\\t},\n\\t-- headings\n\\t{ pattern = \"^#+%s.+\\n\",\\ttype = \"keyword\" },\n\\t-- superscript and subscript\n\\t{\n\\tpattern = \"%^()%d+()%^\",\n\\ttype = { \"function\", \"number\", \"function\" }\n\\t},\n\\t{\n\\tpattern = \"%~()%d+()%~\",\n\\ttype = { \"function\", \"number\", \"function\" }\n\\t},\n\\t-- definitions\n\\t{ pattern = \"^:%s.+\",\\ttype = \"function\" },\n\\t-- emoji\n\\t{ pattern = \":[a-zA-Z0-9_%-]+:\",\\ttype = \"literal\" },\n\\t-- images and link\n\\t{\n\\tpattern = \"!?%[!?%[()[\"..in_squares_match..\"]+()%]%(()[\"..in_parenthesis_match..\"]+()%)%]%(()[\"..in_parenthesis_match..\"]+()%)\",\n\\ttype = { \"function\", \"string\", \"function\", \"number\", \"function\", \"number\", \"function\" }\n\\t},\n\\t{\n\\tpattern = \"!?%[!?%[?()[\"..in_squares_match..\"]+()%]?%]%(()[\"..in_parenthesis_match..\"]+()%)\",\n\\ttype = { \"function\", \"string\", \"function\", \"number\", \"function\" }\n\\t},\n\\t-- reference links\n\\t{\n\\tpattern = \"%[()[\"..in_squares_match..\"]+()%] *()%[()[\"..in_squares_match..\"]+()%]\",\n\\ttype = { \"function\", \"string\", \"function\", \"function\", \"number\", \"function\" }\n\\t},\n\\t{\n\\tpattern = \"!?%[%^?()[\"..in_squares_match..\"]+()%]\",\n\\ttype = { \"function\", \"number\", \"function\" }\n\\t},\n\\t-- url's and email\n\\t{\n\\tpattern = \"<[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+%.[a-zA-Z0-9-.]+>\",\n\\ttype = \"function\"\n\\t},\n\\t{ pattern = \"<https?://%S+>\",\\ttype = \"function\" },\n\\t{ pattern = \"https?://%S+\",\\ttype = \"function\" },\n\\t-- optimize consecutive dashes used in tables\n\\t{ pattern = \"%-+\",\\ttype = \"normal\" },\n\\t},\n\\tsymbols = { },\n}\n-- Adjust the color on theme changes\ncore.add_thread(function()\n\\twhile true do\n\\tif initial_color ~= style.syntax[\"keyword2\"] then\n\\tfor _, attr in pairs({\"bold\", \"italic\", \"bold_italic\"}) do\n\\tstyle.syntax[\"markdown_\"..attr] = style.syntax[\"keyword2\"]\n\\tend\n\\tinitial_color = style.syntax[\"keyword2\"]\n\\tend\n\\tcoroutine.yield(1)\n\\tend\nend)\nSyntax fonts (Since 1.16.10)The syntax allows users to set different font styles (bold, italic, etc.) for different patterns.\nTo change the font style of a token, add a Font to style.syntax_fonts[token_type].\nFor example:\n-- will ensure every \"fancysyntax_fancy_token\" is italic\nstyle.syntax_fonts[\"fancysyntax_fancy_token\"] = renderer.font.load(\"myfont.ttf\", 14 * SCALE, { italic = true })\nThe markdown example automates this with a for loop.The limitations here are that fonts cannot be copied with different attributes, thus the font path has to be hardcoded.\nOther than that, abusing style.syntax_fonts may lead to slow performance and high memory consumption.\nThis is very obvious when the user tries to resize the editor with ctrl-scroll or ctrl+ and ctrl-.\nPlease use it in moderation.Space handling (v2.1 (upcoming) / master)By default, Lite XL prepends a pattern { pattern = \"%s+\", type = \"normal\" } to the syntax.\nThis improves the performance drastically on lines that starts with whitespaces (eg. heavily indented lines)\nby matching the whitespace before other patterns in order to prevent Lite XL from iterating the entire syntax.\nHowever, there may be syntaxes that require matching spaces (eg. Markdown with indented blocks)\nso this can be disabled by setting space_handling to false.To keep the space handling optimization or to support older versions of Lite XL,\n{ pattern = \"%s+\", type = \"normal\" } can be added after patterns that require space.Simple patterns with multiple tokens (v1.16.10)This is an excerpt taken from the markdown plugin:local in_squares_match = \"^%[%]\"\n-- reference links\n{\n\\tpattern = \"^%s*%[%^()[\"..in_squares_match..\"]+()%]: \",\n\\ttype = { \"function\", \"number\", \"function\" }\n},\nSometimes it makes sense to highlight different parts of a pattern differently.\nAn empty parentheses (()) in Lua patterns will return the position of the text in the parentheses.\nThis will tell Lite XL when to change the type of token.\nFor instance, ^%s*%[%^ is \"function\", [\"..in_squares_match..\"]+ is \"number\" and %]: is \"function\".Subsyntaxes (Since v1.16.10)Lite XL supports embedding another syntax into the existing syntax.\nThis is used to support code blocks inside the markdown syntax.For example:\nlua\n{ pattern = { \"cpp\", \"\" },\\ttype = \"string\", syntax = \".cpp\" },\nThis would highlight `` cpp `` and `` `with\"string\"while everything inside them will be highlighted with a syntax that matches\".cpp\"`."},{"id":"es/tutorials/system-fonts.html","title":"Lite XL - Using system fonts","category":["tutorials"],"content":"Using system fontslite-xl does not provide a convenient way to use fonts on the system.\nThere is literally _different APIs for the each platforms we support (Windows, Linux and Mac).\nThis is where fontconfig comes to our rescue. fontconfig is\ninstallable on a lot of OSes.lite-xl has a fontconfig plugin that we can use to find system fonts.Installing fontconfigWindowsmingw-w64-fontconfig provides a build that can be used directly on Windows.\nDownload the file, extract it to somewhere and (optionally) add it to the PATH.LinuxCheck your distro-specific instructions.# ubuntu / debian\napt install fontconfig\n# arch\npacman -Su fontconfig\n# fedora\ndnf install fontconfig\n...\nMacOSbrew install fontconfig\nSetting upInstall the plugin\nPut this in your user module:\nlocal fontconfig = require \"plugins.fontconfig\"\nfontconfig.use {\n\\tfont = { name = \"sans\", size = 13 * SCALE },\n\\tcode_font = { name = \"monospace\", size = 13 * SCALE }\n}\n\"sans\" and \"monospace\" can be any fontconfig syntax. (check \"Font Names\")Note that the font might not load immediately (because we need to wait for fc-match to return.\nIf you want that, replace fontconfig.use with fontconfig.use_blocking. Doing this will force\nlite-xl to wait for fc-match, which can be much slower."}]